{
    "version": "https://jsonfeed.org/version/1",
    "title": "艾瑞可erik • All posts by \"服务器\" categories",
    "description": "一只PHP开发的程序猿，偶尔做做运维、Goland、Python、Java、摄影、画画、写作、顺便睡觉，反正整站都搞过。",
    "home_page_url": "https://erik.xyz",
    "items": [
        {
            "id": "https://erik.xyz/2023/02/02/40-ge-nginx-questions/",
            "url": "https://erik.xyz/2023/02/02/40-ge-nginx-questions/",
            "title": "40个 Nginx 常问面试题",
            "date_published": "2023-02-02T05:59:00.000Z",
            "content_html": "<h2 id=\"什么是-Nginx？\"><a href=\"#什么是-Nginx？\" class=\"headerlink\" title=\"什么是 Nginx？\"></a>什么是 Nginx？</h2><hr>\n<p>Nginx 是一个 轻量级 / 高性能的反向代理 Web 服务器，用于 HTTP、HTTPS、SMTP、POP3 和 IMAP 协议。他实现非常高效的反向代理、负载平衡，他可以处理 2-3 万并发连接数，官方监测能支持 5 万并发，现在中国使用 nginx 网站用户有很多，例如：新浪、网易、 腾讯等。</p>\n<h5 id=\"Nginx-有哪些优点？\"><a href=\"#Nginx-有哪些优点？\" class=\"headerlink\" title=\"Nginx 有哪些优点？\"></a>Nginx 有哪些优点？</h5><ul>\n<li><p>跨平台、配置简单。</p>\n</li>\n<li><p>非阻塞、高并发连接：处理 2-3 万并发连接数，官方监测能支持 5 万并发。</p>\n</li>\n<li><p>内存消耗</p>\n<span id=\"more\"></span></li>\n<li><p>小：开启 10 个 Nginx 才占 150M 内存。</p>\n</li>\n<li><p>成本低廉，且开源。</p>\n</li>\n<li><p>稳定性高，宕机的概率非常小。</p>\n</li>\n<li><p>内置的健康检查功能：如果有一个服务器宕机，会做一个健康检查，再发送的请求就不会发送到宕机的服务器了。重新将请求提交到其他的节点上</p>\n</li>\n</ul>\n<h2 id=\"Nginx-应用场景？\"><a href=\"#Nginx-应用场景？\" class=\"headerlink\" title=\"Nginx 应用场景？\"></a>Nginx 应用场景？</h2><hr>\n<ul>\n<li><p>http 服务器。Nginx 是一个 http 服务可以独立提供 http 服务。可以做网页静态服务器。</p>\n</li>\n<li><p>虚拟主机。可以实现在一台服务器虚拟出多个网站，例如个人网站使用的虚拟机。</p>\n</li>\n<li><p>反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用 nginx 做反向代理。并且多台服务器可以平均分担负载，不会应为某台服务器负载高宕机而某台服务器闲置的情况。</p>\n</li>\n<li><p>nginz 中也可以配置安全管理、比如可以使用 Nginx 搭建 API 接口网关, 对每个接口服务进行拦截。</p>\n</li>\n</ul>\n<h2 id=\"Nginx-怎么处理请求的？\"><a href=\"#Nginx-怎么处理请求的？\" class=\"headerlink\" title=\"Nginx 怎么处理请求的？\"></a>Nginx 怎么处理请求的？</h2><hr>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123; # 第一个Server区块开始，表示一个独立的虚拟主机站点</span><br><span class=\"line\">   listen       80；# 提供服务的端口，默认80</span><br><span class=\"line\">   server_name localhost; # 提供服务的域名主机名</span><br><span class=\"line\">   location / &#123; # 第一个location区块开始</span><br><span class=\"line\">     root   html; # 站点的根目录，相当于Nginx的安装目录</span><br><span class=\"line\">     index  index.html index.html; # 默认的首页文件，多个用空格分开</span><br><span class=\"line\">&#125; # 第一个location区块结果</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>首先，Nginx 在启动时，会解析配置文件，得到需要监听的端口与 IP 地址，然后在 Nginx 的 Master 进程里面先初始化好这个监控的 Socket(创建 S ocket，设置 addr、reuse 等选项，绑定到指定的 ip 地址端口，再 listen 监听)。</p>\n</li>\n<li><p>然后，再 fork(一个现有进程可以调用 fork 函数创建一个新进程。由 fork 创建的新进程被称为子进程) 出多个子进程出来。</p>\n</li>\n<li><p>之后，子进程会竞争 accept 新的连接。此时，客户端就可以向 nginx 发起连接了。当客户端与 nginx 进行三次握手，与 nginx 建立好一个连接后。此时，某一个子进程会 accept 成功，得到这个建立好的连接的 Socket ，然后创建 nginx 对连接的封装，即 ngx_connection_t 结构体。</p>\n</li>\n<li><p>接着，设置读写事件处理函数，并添加读写事件来与客户端进行数据的交换。</p>\n</li>\n<li><p>最后，Nginx 或客户端来主动关掉连接，到此，一个连接就寿终正寝了。</p>\n</li>\n</ul>\n<h2 id=\"Nginx-是如何实现高并发的？\"><a href=\"#Nginx-是如何实现高并发的？\" class=\"headerlink\" title=\"Nginx 是如何实现高并发的？\"></a>Nginx 是如何实现高并发的？</h2><hr>\n<pre><code>    如果一个 server 采用一个进程 (或者线程) 负责一个 request 的方式，那么进程数就是并发数。那么显而易见的，就是会有很多进程在等待中。等什么？最多的应该是等待网络传输。\n\n    而 Nginx 的异步非阻塞工作方式正是利用了这点等待的时间。在需要等待的时候，这些进程就空闲出来待命了。因此表现为少数几个进程就解决了大量的并发问题。\n\n    Nginx 是如何利用的呢，简单来说：同样的 4 个进程，如果采用一个进程负责一个 request 的方式，那么，同时进来 4 个 request 之后，每个进程就负责其中一个，直至会话关闭。期间，如果有第 5 个 request 进来了。就无法及时反应了，因为 4 个进程都没干完活呢，因此，一般有个调度进程，每当新进来了一个 request ，就新开个进程来处理。\n</code></pre><p>回想下，BIO 是不是存在酱紫的问题？</p>\n<pre><code>    Nginx 不这样，每进来一个 request ，会有一个 worker 进程去处理。但不是全程的处理，处理到什么程度呢？处理到可能发生阻塞的地方，比如向上游（后端）服务器转发 request ，并等待请求返回。那么，这个处理的 worker 不会这么傻等着，他会在发送完请求后，注册一个事件：“如果 upstream 返回了，告诉我一声，我再接着干”。于是他就休息去了。此时，如果再有 request 进来，他就可以很快再按这种方式处理。而一旦上游服务器返回了，就会触发这个事件，worker 才会来接手，这个 request 才会接着往下走。\n</code></pre><p>这就是为什么说，Nginx 基于事件模型。</p>\n<p>由于 web server 的工作性质决定了每个 request 的大部份生命都是在网络传输中，实际上花费在 server 机器上的时间片不多。这是几个进程就解决高并发的秘密所在。即：</p>\n<p>webserver 刚好属于网络 IO 密集型应用，不算是计算密集型。</p>\n<p>异步，非阻塞，使用 epoll ，和大量细节处的优化。也正是 Nginx 之所以然的技术基石。</p>\n<h2 id=\"什么是正向代理？\"><a href=\"#什么是正向代理？\" class=\"headerlink\" title=\"什么是正向代理？\"></a>什么是正向代理？</h2><hr>\n<pre><code>    一个位于客户端和原始服务器 (origin server) 之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。\n</code></pre><p>客户端才能使用正向代理。正向代理总结就一句话：代理端代理的是客户端。例如说：我们使用的 OpenVPN 等等。</p>\n<h3 id=\"什么是反向代理？\"><a href=\"#什么是反向代理？\" class=\"headerlink\" title=\"什么是反向代理？\"></a>什么是反向代理？</h3><hr>\n<p>反向代理（Reverse Proxy）方式，是指以代理服务器来接受 Internet 上的连接请求，然后将请求，发给内部网络上的服务器并将从服务器上得到的结果返回给 Internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>\n<pre><code>    反向代理总结就一句话：代理端代理的是服务端。\n</code></pre><h4 id=\"反向代理服务器的优点是什么\"><a href=\"#反向代理服务器的优点是什么\" class=\"headerlink\" title=\"反向代理服务器的优点是什么?\"></a>反向代理服务器的优点是什么?</h4><hr>\n<pre><code>    反向代理服务器可以隐藏源服务器的存在和特征。它充当互联网云和 web 服务器之间的中间层。这对于安全方面来说是很好的，特别是当您使用 web 托管服务时。\n</code></pre><h2 id=\"Nginx-目录结构有哪些？\"><a href=\"#Nginx-目录结构有哪些？\" class=\"headerlink\" title=\"Nginx 目录结构有哪些？\"></a>Nginx 目录结构有哪些？</h2><hr>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tree /usr/local/nginx</span><br><span class=\"line\">/usr/local/nginx</span><br><span class=\"line\">├── client_body_temp</span><br><span class=\"line\">├── conf # Nginx所有配置文件的目录</span><br><span class=\"line\">│ ├── fastcgi.conf # fastcgi相关参数的配置文件</span><br><span class=\"line\">│ ├── fastcgi.conf.default         # fastcgi.conf的原始备份文件</span><br><span class=\"line\">│ ├── fastcgi_params # fastcgi的参数文件</span><br><span class=\"line\">│ ├── fastcgi_params.default       </span><br><span class=\"line\">│ ├── koi-utf</span><br><span class=\"line\">│ ├── koi-win</span><br><span class=\"line\">│ ├── mime.types # 媒体类型</span><br><span class=\"line\">│ ├── mime.types.default</span><br><span class=\"line\">│ ├── nginx.conf # Nginx主配置文件</span><br><span class=\"line\">│ ├── nginx.conf.default</span><br><span class=\"line\">│ ├── scgi_params # scgi相关参数文件</span><br><span class=\"line\">│ ├── scgi_params.default  </span><br><span class=\"line\">│ ├── uwsgi_params # uwsgi相关参数文件</span><br><span class=\"line\">│ ├── uwsgi_params.default</span><br><span class=\"line\">│ └── win-utf</span><br><span class=\"line\">├── fastcgi_temp # fastcgi临时数据目录</span><br><span class=\"line\">├── html # Nginx默认站点目录</span><br><span class=\"line\">│ ├── 50x.html # 错误页面优雅替代显示文件，例如当出现502错误时会调用此页面</span><br><span class=\"line\">│ └── index.html # 默认的首页文件</span><br><span class=\"line\">├── logs # Nginx日志目录</span><br><span class=\"line\">│ ├── access.log # 访问日志文件</span><br><span class=\"line\">│ ├── error.log # 错误日志文件</span><br><span class=\"line\">│ └── nginx.pid # pid文件，Nginx进程启动后，会把所有进程的ID号写到此文件</span><br><span class=\"line\">├── proxy_temp # 临时目录</span><br><span class=\"line\">├── sbin # Nginx命令目录</span><br><span class=\"line\">│ └── nginx # Nginx的启动命令</span><br><span class=\"line\">├── scgi_temp # 临时目录</span><br><span class=\"line\">└── uwsgi_temp # 临时目录</span><br></pre></td></tr></table></figure>\n<h3 id=\"Nginx-配置文件-nginx-conf-有哪些属性模块\"><a href=\"#Nginx-配置文件-nginx-conf-有哪些属性模块\" class=\"headerlink\" title=\"Nginx 配置文件 nginx.conf 有哪些属性模块?\"></a>Nginx 配置文件 nginx.conf 有哪些属性模块?</h3><hr>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">worker_processes  1；# worker进程的数量</span><br><span class=\"line\">events &#123; # 事件区块开始</span><br><span class=\"line\">    worker_connections  1024；# 每个worker进程支持的最大连接数</span><br><span class=\"line\">&#125; # 事件区块结束</span><br><span class=\"line\">http &#123; # HTTP区块开始</span><br><span class=\"line\">    include       mime.types；# Nginx支持的媒体类型库文件</span><br><span class=\"line\">    default_type application/octet-stream；# 默认的媒体类型</span><br><span class=\"line\">    sendfile on；# 开启高效传输模式</span><br><span class=\"line\">    keepalive_timeout 65；# 连接超时</span><br><span class=\"line\">    server &#123; # 第一个Server区块开始，表示一个独立的虚拟主机站点</span><br><span class=\"line\">        listen       80；# 提供服务的端口，默认80</span><br><span class=\"line\">        server_name localhost；# 提供服务的域名主机名</span><br><span class=\"line\">        location / &#123; # 第一个location区块开始</span><br><span class=\"line\">            root   html；# 站点的根目录，相当于Nginx的安装目录</span><br><span class=\"line\">            index index.html index.htm；# 默认的首页文件，多个用空格分开</span><br><span class=\"line\">        &#125; # 第一个location区块结果</span><br><span class=\"line\">        error_page 500502503504  /50x.html；# 出现对应的http状态码时，使用50x.html回应客户</span><br><span class=\"line\">        location = /50x.html &#123; # location区块开始，访问50x.html</span><br><span class=\"line\">            root   html；# 指定对应的站点目录为html</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ......</span><br></pre></td></tr></table></figure>\n<h3 id=\"cookie-和-session-区别？\"><a href=\"#cookie-和-session-区别？\" class=\"headerlink\" title=\"cookie 和 session 区别？\"></a>cookie 和 session 区别？</h3><hr>\n<h5 id=\"共同：\"><a href=\"#共同：\" class=\"headerlink\" title=\"共同：\"></a>共同：</h5><p>存放用户信息。存放的形式：key-value 格式 变量和变量内容键值对。</p>\n<h5 id=\"区别：\"><a href=\"#区别：\" class=\"headerlink\" title=\"区别：\"></a>区别：</h5><p>cookie</p>\n<ul>\n<li><p>存放在客户端浏览器</p>\n</li>\n<li><p>每个域名对应一个 cookie，不能跨跃域名访问其他 cookie</p>\n</li>\n<li><p>用户可以查看或修改 cookie</p>\n</li>\n<li><p>http 响应报文里面给你浏览器设置</p>\n</li>\n<li><p>钥匙（用于打开浏览器上锁头）</p>\n</li>\n</ul>\n<p>session:</p>\n<ul>\n<li><p>存放在服务器（文件，数据库，redis）</p>\n</li>\n<li><p>存放敏感信息</p>\n</li>\n<li><p>锁头</p>\n</li>\n</ul>\n<h4 id=\"为什么-Nginx-不使用多线程？\"><a href=\"#为什么-Nginx-不使用多线程？\" class=\"headerlink\" title=\"为什么 Nginx 不使用多线程？\"></a>为什么 Nginx 不使用多线程？</h4><hr>\n<pre><code>    Apache: 创建多个进程或线程，而每个进程或线程都会为其分配 cpu 和内存（线程要比进程小的多，所以 worker 支持比 perfork 高的并发），并发过大会榨干服务器资源。\n</code></pre><p>Nginx: 采用单线程来异步非阻塞处理请求（管理员可以配置 Nginx 主进程的工作进程的数量）(epoll)，不会为每个请求分配 cpu 和内存资源，节省了大量资源，同时也减少了大量的 CPU 的上下文切换。所以才使得 Nginx 支持更高的并发。</p>\n<h4 id=\"nginx-和-apache-的区别\"><a href=\"#nginx-和-apache-的区别\" class=\"headerlink\" title=\"nginx 和 apache 的区别\"></a>nginx 和 apache 的区别</h4><hr>\n<p>轻量级，同样起 web 服务，比 apache 占用更少的内存和资源。</p>\n<p>抗并发，nginx 处理请求是异步非阻塞的，而 apache 则是阻塞性的，在高并发下 nginx 能保持低资源，低消耗高性能。</p>\n<p>高度模块化的设计，编写模块相对简单。</p>\n<p>最核心的区别在于 apache 是同步多进程模型，一个连接对应一个进程，nginx 是异步的，多个连接可以对应一个进程。<br><img src=\"/img/202301/20230221141046.png\" alt=\"erik.xyz\"></p>\n<h5 id=\"什么是动态资源、静态资源分离？\"><a href=\"#什么是动态资源、静态资源分离？\" class=\"headerlink\" title=\"什么是动态资源、静态资源分离？\"></a>什么是动态资源、静态资源分离？</h5><pre><code>    动态资源、静态资源分离，是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路。\n</code></pre><p>动态资源、静态资源分离简单的概括是：动态文件与静态文件的分离。</p>\n<h4 id=\"为什么要做动、静分离？\"><a href=\"#为什么要做动、静分离？\" class=\"headerlink\" title=\"为什么要做动、静分离？\"></a>为什么要做动、静分离？</h4><hr>\n<p>在我们的软件开发中，有些请求是需要后台处理的（如：.jsp,.do 等等），有些请求是不需要经过后台处理的（如：css、html、jpg、js 等等文件），这些不需要经过后台处理的文件称为静态文件，否则动态文件。</p>\n<pre><code>    因此我们后台处理忽略静态文件。这会有人又说那我后台忽略静态文件不就完了吗？当然这是可以的，但是这样后台的请求次数就明显增多了。在我们对资源的响应速度有要求的时候，我们应该使用这种动静分离的策略去解决动、静分离将网站静态资源（HTML，JavaScript，CSS，img 等文件）与后台应用分开部署，提高用户访问静态代码的速度，降低对后台应用访问\n</code></pre><p>这里我们将静态资源放到 Nginx 中，动态资源转发到 Tomcat 服务器中去。</p>\n<p>当然，因为现在七牛、阿里云等 CDN 服务已经很成熟，主流的做法，是把静态资源缓存到 CDN 服务中，从而提升访问速度。</p>\n<pre><code>    相比本地的 Nginx 来说，CDN 服务器由于在国内有更多的节点，可以实现用户的就近访问。并且，CDN 服务可以提供更大的带宽，不像我们自己的应用服务，提供的带宽是有限的。\n</code></pre><h5 id=\"什么叫-CDN-服务？\"><a href=\"#什么叫-CDN-服务？\" class=\"headerlink\" title=\"什么叫 CDN 服务？\"></a>什么叫 CDN 服务？</h5><hr>\n<p>CDN ，即内容分发网络。</p>\n<p>其目的是，通过在现有的 Internet 中 增加一层新的网络架构，将网站的内容发布到最接近用户的网络边缘，使用户可就近取得所需的内容，提高用户访问网站的速度。</p>\n<p>一般来说，因为现在 CDN 服务比较大众，所以基本所有公司都会使用 CDN 服务。</p>\n<h4 id=\"Nginx-怎么做的动静分离？\"><a href=\"#Nginx-怎么做的动静分离？\" class=\"headerlink\" title=\"Nginx 怎么做的动静分离？\"></a>Nginx 怎么做的动静分离？</h4><hr>\n<pre><code>    只需要指定路径对应的目录。location / 可以使用正则表达式匹配。并指定对应的硬盘中的目录。如下：（操作都是在 Linux 上）\n</code></pre>  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location /image/ &#123;</span><br><span class=\"line\">    root /usr/local/static/;</span><br><span class=\"line\">    autoindex on;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">步骤：</span><br><span class=\"line\"># 创建目录</span><br><span class=\"line\">mkdir /usr/local/static/image</span><br><span class=\"line\"> </span><br><span class=\"line\"># 进入目录</span><br><span class=\"line\">cd  /usr/local/static/image</span><br><span class=\"line\"> </span><br><span class=\"line\"># 上传照片</span><br><span class=\"line\">photo.jpg</span><br><span class=\"line\"> </span><br><span class=\"line\"># 重启nginx</span><br><span class=\"line\">sudo nginx -s reload</span><br></pre></td></tr></table></figure>\n<p>打开浏览器 输入 server_name/image/1.jpg 就可以访问该静态图片了</p>\n<h3 id=\"Nginx-负载均衡的算法怎么实现的-策略有哪些\"><a href=\"#Nginx-负载均衡的算法怎么实现的-策略有哪些\" class=\"headerlink\" title=\"Nginx 负载均衡的算法怎么实现的? 策略有哪些?\"></a>Nginx 负载均衡的算法怎么实现的? 策略有哪些?</h3><hr>\n<pre><code>    为了避免服务器崩溃，大家会通过负载均衡的方式来分担服务器压力。将对台服务器组成一个集群，当用户访问时，先访问到一个转发服务器，再由转发服务器将访问分发到压力更小的服务器。\n</code></pre><p>Nginx 负载均衡实现的策略有以下五种：</p>\n<p>1 . 轮询 (默认)<br>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某个服务器宕机，能自动剔除故障系统。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream backserver &#123;</span><br><span class=\"line\"> server 192.168.0.12;</span><br><span class=\"line\"> server 192.168.0.13;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>权重 weight<br>weight 的值越大，分配到的访问概率越高，主要用于后端每台服务器性能不均衡的情况下。其次是为在主从的情况下设置不同的权值，达到合理有效的地利用主机资源。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 权重越高，在被访问的概率越大，如上例，分别是20%，80%。</span><br><span class=\"line\">upstream backserver &#123;</span><br><span class=\"line\"> server 192.168.0.12 weight=2;</span><br><span class=\"line\"> server 192.168.0.13 weight=8;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>ip_hash(IP 绑定)<br>每个请求按访问 IP 的哈希结果分配，使来自同一个 IP 的访客固定访问一台后端服务器，并且可以有效解决动态网页存在的 session 共享问题</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream backserver &#123;</span><br><span class=\"line\"> ip_hash;</span><br><span class=\"line\"> server 192.168.0.12:88;</span><br><span class=\"line\"> server 192.168.0.13:80;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>fair(第三方插件)<br>必须安装 upstream_fair 模块。</li>\n</ol>\n<p>对比 weight、ip_hash 更加智能的负载均衡算法，fair 算法可以根据页面大小和加载时间长短智能地进行负载均衡，响应时间短的优先分配。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 哪个服务器的响应速度快，就将请求分配到那个服务器上。</span><br><span class=\"line\">upstream backserver &#123;</span><br><span class=\"line\"> server server1;</span><br><span class=\"line\"> server server2;</span><br><span class=\"line\"> fair;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>5.url_hash(第三方插件)</p>\n<p>必须安装 Nginx 的 hash 软件包</p>\n<p>按访问 url 的 hash 结果来分配请求，使每个 url 定向到同一个后端服务器，可以进一步提高后端缓存服务器的效率。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream backserver &#123;</span><br><span class=\"line\"> server squid1:3128;</span><br><span class=\"line\"> server squid2:3128;</span><br><span class=\"line\"> hash $request_uri;</span><br><span class=\"line\"> hash_method crc32;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"如何用-Nginx-解决前端跨域问题？\"><a href=\"#如何用-Nginx-解决前端跨域问题？\" class=\"headerlink\" title=\"如何用 Nginx 解决前端跨域问题？\"></a>如何用 Nginx 解决前端跨域问题？</h4><hr>\n<p>使用 Nginx 转发请求。把跨域的接口写成调本域的接口，然后将这些接口转发到真正的请求地址。</p>\n<h4 id=\"Nginx-虚拟主机怎么配置\"><a href=\"#Nginx-虚拟主机怎么配置\" class=\"headerlink\" title=\"Nginx 虚拟主机怎么配置?\"></a>Nginx 虚拟主机怎么配置?</h4><hr>\n<p>1、基于域名的虚拟主机，通过域名来区分虚拟主机——应用：外部网站</p>\n<p>2、基于端口的虚拟主机，通过端口来区分虚拟主机——应用：公司内部网站，外部网站的管理后台</p>\n<p>3、基于 ip 的虚拟主机。</p>\n<h5 id=\"基于虚拟主机配置域名\"><a href=\"#基于虚拟主机配置域名\" class=\"headerlink\" title=\"基于虚拟主机配置域名\"></a>基于虚拟主机配置域名</h5><p>需要建立 / data/www /data/bbs 目录，windows 本地 hosts 添加虚拟机 ip 地址对应的域名解析；对应域名网站目录下新增 index.html 文件；</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 当客户端访问www.lijie.com,监听端口号为80,直接跳转到data/www目录下文件</span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen       80;</span><br><span class=\"line\">    server_name  www.lijie.com;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        root   data/www;</span><br><span class=\"line\">        index  index.html index.htm;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"># 当客户端访问www.lijie.com,监听端口号为80,直接跳转到data/bbs目录下文件</span><br><span class=\"line\"> server &#123;</span><br><span class=\"line\">    listen       80;</span><br><span class=\"line\">    server_name  bbs.lijie.com;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        root   data/bbs;</span><br><span class=\"line\">        index  index.html index.htm;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"基于端口的虚拟主机\"><a href=\"#基于端口的虚拟主机\" class=\"headerlink\" title=\"基于端口的虚拟主机\"></a>基于端口的虚拟主机</h5><p>使用端口来区分，浏览器使用域名或 ip 地址: 端口号 访问</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 当客户端访问www.lijie.com,监听端口号为8080,直接跳转到data/www目录下文件</span><br><span class=\"line\"> server &#123;</span><br><span class=\"line\">    listen       8080;</span><br><span class=\"line\">    server_name  8080.lijie.com;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        root   data/www;</span><br><span class=\"line\">        index  index.html index.htm;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"># 当客户端访问www.lijie.com,监听端口号为80直接跳转到真实ip服务器地址 127.0.0.1:8080</span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen       80;</span><br><span class=\"line\">    server_name  www.lijie.com;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">         proxy_pass http://127.0.0.1:8080;</span><br><span class=\"line\">        index  index.html index.htm;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"location-的作用是什么？\"><a href=\"#location-的作用是什么？\" class=\"headerlink\" title=\"location 的作用是什么？\"></a>location 的作用是什么？</h4><hr>\n<p>location 指令的作用是根据用户请求的 URI 来执行不同的应用，也就是根据用户请求的网站 URL 进行匹配，匹配成功即进行相关的操作。</p>\n<p>location 的语法能说出来吗？</p>\n<pre><code>    注意：~ 代表自己输入的英文字母\n</code></pre><p>  <img src=\"/img/202301/20230221141815.png\" alt=\"erik.xyz\"></p>\n<p>Location 正则案例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 优先级1,精确匹配，根路径</span><br><span class=\"line\">location =/ &#123;</span><br><span class=\"line\">    return 400;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"># 优先级2,以某个字符串开头,以av开头的，优先匹配这里，区分大小写</span><br><span class=\"line\">location ^~ /av &#123;</span><br><span class=\"line\">   root /data/av/;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"># 优先级3，区分大小写的正则匹配，匹配/media*****路径</span><br><span class=\"line\">location ~ /media &#123;</span><br><span class=\"line\">      alias /data/static/;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"># 优先级4 ，不区分大小写的正则匹配，所有的****.jpg|gif|png 都走这里</span><br><span class=\"line\">location ~* .*\\.(jpg|gif|png|js|css)$ &#123;</span><br><span class=\"line\">   root  /data/av/;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"># 优先7，通用匹配</span><br><span class=\"line\">location / &#123;</span><br><span class=\"line\">    return 403;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"限流怎么做的？\"><a href=\"#限流怎么做的？\" class=\"headerlink\" title=\"限流怎么做的？\"></a>限流怎么做的？</h4><hr>\n<p>Nginx 限流就是限制用户请求速度，防止服务器受不了</p>\n<p>限流有 3 种</p>\n<ul>\n<li><p>正常限制访问频率（正常流量）</p>\n</li>\n<li><p>突发限制访问频率（突发流量）</p>\n</li>\n<li><p>限制并发连接数</p>\n</li>\n</ul>\n<p>Nginx 的限流都是基于漏桶流算法</p>\n<pre><code>实现三种限流算法\n</code></pre><p>1、正常限制访问频率（正常流量）：<br>限制一个用户发送的请求，我 Nginx 多久接收一个请求。</p>\n<p>Nginx 中使用 ngx_http_limit_req_module 模块来限制的访问频率，限制的原理实质是基于漏桶算法原理来实现的。在 nginx.conf 配置文件中可以使用 limit_req_zone 命令及 limit_req 命令限制单个 IP 的请求处理频率。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 定义限流维度，一个用户一分钟一个请求进来，多余的全部漏掉</span><br><span class=\"line\">limit_req_zone $binary_remote_addr zone=one:10m rate=1r/m;</span><br><span class=\"line\"></span><br><span class=\"line\"># 绑定限流维度</span><br><span class=\"line\">server&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    location/seckill.html&#123;</span><br><span class=\"line\">        limit_req zone=zone;</span><br><span class=\"line\">        proxy_pass http://lj_seckill;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>1r/s 代表 1 秒一个请求，1r/m 一分钟接收一个请求， 如果 Nginx 这时还有别人的请求没有处理完，Nginx 就会拒绝处理该用户请求。</p>\n<p>2、突发限制访问频率（突发流量）：<br>限制一个用户发送的请求，我 Nginx 多久接收一个。</p>\n<p>上面的配置一定程度可以限制访问频率，但是也存在着一个问题：如果突发流量超出请求被拒绝处理，无法处理活动时候的突发流量，这时候应该如何进一步处理呢？</p>\n<p>Nginx 提供 burst 参数结合 nodelay 参数可以解决流量突发的问题，可以设置能处理的超过设置的请求数外能额外处理的请求数。我们可以将之前的例子添加 burst 参数以及 nodelay 参数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># 定义限流维度，一个用户一分钟一个请求进来，多余的全部漏掉</span><br><span class=\"line\">limit_req_zone $binary_remote_addr zone=one:10m rate=1r/m;</span><br><span class=\"line\"></span><br><span class=\"line\"># 绑定限流维度</span><br><span class=\"line\">server&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    location/seckill.html&#123;</span><br><span class=\"line\">        limit_req zone=zone burst=5 nodelay;</span><br><span class=\"line\">        proxy_pass http://lj_seckill;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<pre><code>    为什么就多了一个 burst=5 nodelay; 呢，多了这个可以代表 Nginx 对于一个用户的请求会立即处理前五个，多余的就慢慢来落，没有其他用户的请求我就处理你的，有其他的请求的话我 Nginx 就漏掉不接受你的请求\n</code></pre><p>3、 限制并发连接数<br>Nginx 中的 ngx_http_limit_conn_module 模块提供了限制并发连接数的功能，可以使用 limit_conn_zone 指令以及 limit_conn 执行进行配置。接下来我们可以通过一个简单的例子来看下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http &#123;</span><br><span class=\"line\">    limit_conn_zone $binary_remote_addr zone=myip:10m;</span><br><span class=\"line\">    limit_conn_zone $server_name zone=myServerName:10m;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        limit_conn myip 10;</span><br><span class=\"line\">        limit_conn myServerName 100;</span><br><span class=\"line\">        rewrite / http://www.lijie.net permanent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面配置了单个 IP 同时并发连接数最多只能 10 个连接，并且设置了整个虚拟服务器同时最大并发数最多只能 100 个链接。当然，只有当请求的 header 被服务器处理后，虚拟服务器的连接数才会计数。刚才有提到过 Nginx 是基于漏桶算法原理实现的，实际上限流一般都是基于漏桶算法和令牌桶算法实现的。</p>\n<h3 id=\"漏桶流算法和令牌桶算法知道？\"><a href=\"#漏桶流算法和令牌桶算法知道？\" class=\"headerlink\" title=\"漏桶流算法和令牌桶算法知道？\"></a>漏桶流算法和令牌桶算法知道？</h3><hr>\n<p>漏桶算法<br>漏桶算法思路很简单，我们把水比作是请求，漏桶比作是系统处理能力极限，水先进入到漏桶里，漏桶里的水按一定速率流出，当流出的速率小于流入的速率时，由于漏桶容量有限，后续进入的水直接溢出（拒绝请求），以此实现限流。<br><img src=\"/img/202301/20230221142104.png\" alt=\"erik\"></p>\n<h5 id=\"令牌桶算法\"><a href=\"#令牌桶算法\" class=\"headerlink\" title=\"令牌桶算法\"></a>令牌桶算法</h5><p>令牌桶算法的原理也比较简单，我们可以理解成医院的挂号看病，只有拿到号以后才可以进行诊病。</p>\n<pre><code>        系统会维护一个令牌（token）桶，以一个恒定的速度往桶里放入令牌（token），这时如果有请求进来想要被处理，则需要先从桶里获取一个令牌（token），当桶里没有令牌（token）可取时，则该请求将被拒绝服务。令牌桶算法通过控制桶的容量、发放令牌的速率，来达到对请求的限制。\n</code></pre><p><img src=\"/img/202301/20230221142206.png\" alt=\"erik\"></p>\n<h4 id=\"Nginx-配置高可用性怎么配置？\"><a href=\"#Nginx-配置高可用性怎么配置？\" class=\"headerlink\" title=\"Nginx 配置高可用性怎么配置？\"></a>Nginx 配置高可用性怎么配置？</h4><hr>\n<pre><code>        当上游服务器 (真实访问服务器)，一旦出现故障或者是没有及时相应的话，应该直接轮训到下一台服务器，保证服务器的高可用\n</code></pre><p>Nginx 配置代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">        listen       80;</span><br><span class=\"line\">        server_name  www.lijie.com;</span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">            ### 指定上游服务器负载均衡服务器</span><br><span class=\"line\">            proxy_pass http://backServer;</span><br><span class=\"line\">            ###nginx与上游服务器(真实访问的服务器)超时时间 后端服务器连接的超时时间_发起握手等候响应超时时间</span><br><span class=\"line\">            proxy_connect_timeout 1s;</span><br><span class=\"line\">            ###nginx发送给上游服务器(真实访问的服务器)超时时间</span><br><span class=\"line\">            proxy_send_timeout 1s;</span><br><span class=\"line\">            ### nginx接受上游服务器(真实访问的服务器)超时时间</span><br><span class=\"line\">            proxy_read_timeout 1s;</span><br><span class=\"line\">            index  index.html index.htm;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Nginx-怎么判断别-IP-不可访问？\"><a href=\"#Nginx-怎么判断别-IP-不可访问？\" class=\"headerlink\" title=\"Nginx 怎么判断别 IP 不可访问？\"></a>Nginx 怎么判断别 IP 不可访问？</h4><hr>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 如果访问的ip地址为192.168.9.115,则返回403</span><br><span class=\"line\"> if  ($remote_addr = 192.168.9.115) &#123;</span><br><span class=\"line\">     return 403;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在-nginx-中，如何使用未定义的服务器名称来阻止处理请求？\"><a href=\"#在-nginx-中，如何使用未定义的服务器名称来阻止处理请求？\" class=\"headerlink\" title=\"在 nginx 中，如何使用未定义的服务器名称来阻止处理请求？\"></a>在 nginx 中，如何使用未定义的服务器名称来阻止处理请求？</h4><hr>\n<p>只需将请求删除的服务器就可以定义为：</p>\n<p>服务器名被保留一个空字符串，他在没有主机头字段的情况下匹配请求，而一个特殊的 nginx 的非标准代码被返回，从而终止连接。</p>\n<h4 id=\"怎么限制浏览器访问？\"><a href=\"#怎么限制浏览器访问？\" class=\"headerlink\" title=\"怎么限制浏览器访问？\"></a>怎么限制浏览器访问？</h4><hr>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## 不允许谷歌浏览器访问 如果是谷歌浏览器返回500</span><br><span class=\"line\">if ($http_user_agent ~ Chrome) &#123;</span><br><span class=\"line\">  return 500;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Rewrite全局变量是什么？</span><br><span class=\"line\">$remote_addr //获取客户端ip</span><br><span class=\"line\">$binary_remote_addr //客户端ip（二进制)</span><br><span class=\"line\">$remote_port //客户端port，如：50472</span><br><span class=\"line\">$remote_user //已经经过Auth Basic Module验证的用户名</span><br><span class=\"line\">$host //请求主机头字段，否则为服务器名称，如:blog.sakmon.com</span><br><span class=\"line\">$request //用户请求信息，如：GET ?a=1&amp;b=2 HTTP/1.1</span><br><span class=\"line\">$request_filename //当前请求的文件的路径名，由root或alias和URI request组合而成，如：/2013/81.html</span><br><span class=\"line\">$status //请求的响应状态码,如:200</span><br><span class=\"line\">$body_bytes_sent // 响应时送出的body字节数数量。即使连接中断，这个数据也是精确的,如：40</span><br><span class=\"line\">$content_length // 等于请求行的“Content_Length”的值</span><br><span class=\"line\">$content_type // 等于请求行的“Content_Type”的值</span><br><span class=\"line\">$http_referer // 引用地址</span><br><span class=\"line\">$http_user_agent // 客户端agent信息,如：Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.76 Safari/537.36</span><br><span class=\"line\">$args //与$query_string相同 等于当中URL的参数(GET)，如a=1&amp;b=2</span><br><span class=\"line\">$document_uri //与$uri相同 这个变量指当前的请求URI，不包括任何参数(见$args) 如:/2013/81.html</span><br><span class=\"line\">$document_root //针对当前请求的根路径设置值</span><br><span class=\"line\">$hostname //如：centos53.localdomain</span><br><span class=\"line\">$http_cookie //客户端cookie信息</span><br><span class=\"line\">$cookie_COOKIE //cookie COOKIE变量的值</span><br><span class=\"line\">$is_args //如果有$args参数，这个变量等于”?”，否则等于”&quot;，空值，如?</span><br><span class=\"line\">$limit_rate //这个变量可以限制连接速率，0表示不限速</span><br><span class=\"line\">$query_string // 与$args相同 等于当中URL的参数(GET)，如a=1&amp;b=2</span><br><span class=\"line\">$request_body // 记录POST过来的数据信息</span><br><span class=\"line\">$request_body_file //客户端请求主体信息的临时文件名</span><br><span class=\"line\">$request_method //客户端请求的动作，通常为GET或POST,如：GET</span><br><span class=\"line\">$request_uri //包含请求参数的原始URI，不包含主机名，如：/2013/81.html?a=1&amp;b=2</span><br><span class=\"line\">$scheme //HTTP方法（如http，https）,如：http</span><br><span class=\"line\">$uri //这个变量指当前的请求URI，不包括任何参数(见$args) 如:/2013/81.html</span><br><span class=\"line\">$request_completion //如果请求结束，设置为OK. 当请求未结束或如果该请求不是请求链串的最后一个时，为空(Empty)，如：OK</span><br><span class=\"line\">$server_protocol //请求使用的协议，通常是HTTP/1.0或HTTP/1.1，如：HTTP/1.1</span><br><span class=\"line\">$server_addr //服务器IP地址，在完成一次系统调用后可以确定这个值</span><br><span class=\"line\">$server_name //服务器名称，如：blog.sakmon.com</span><br><span class=\"line\">$server_port //请求到达服务器的端口号,如：80</span><br></pre></td></tr></table></figure>\n<h4 id=\"Nginx-如何实现后端服务的健康检查\"><a href=\"#Nginx-如何实现后端服务的健康检查\" class=\"headerlink\" title=\"Nginx 如何实现后端服务的健康检查?\"></a>Nginx 如何实现后端服务的健康检查?</h4><hr>\n<p>方式一，利用 nginx 自带模块 ngx_http_proxy_module 和 ngx_http_upstream_module 对后端节点做健康检查。</p>\n<p>方式二 (推荐)，利用 nginx_upstream_check_module 模块对后端节点做健康检查。</p>\n<h4 id=\"Nginx-如何开启压缩？\"><a href=\"#Nginx-如何开启压缩？\" class=\"headerlink\" title=\"Nginx 如何开启压缩？\"></a>Nginx 如何开启压缩？</h4><hr>\n<p>开启 nginx gzip 压缩后，网页、css、js 等静态资源的大小会大大的减少，从而可以节约大量的带宽，提高传输效率，给用户快的体验。虽然会消耗 cpu 资源，但是为了给用户更好的体验是值得的。</p>\n<p>开启的配置如下：</p>\n<p>将以上配置放到 nginx.conf 的 http{…} 节点中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http &#123;</span><br><span class=\"line\">  # 开启gzip</span><br><span class=\"line\">  gzip on;</span><br><span class=\"line\"> </span><br><span class=\"line\">  # 启用gzip压缩的最小文件；小于设置值的文件将不会被压缩</span><br><span class=\"line\">  gzip_min_length 1k;</span><br><span class=\"line\"> </span><br><span class=\"line\">  # gzip 压缩级别 1-10</span><br><span class=\"line\">  gzip_comp_level 2;</span><br><span class=\"line\"> </span><br><span class=\"line\">  # 进行压缩的文件类型。</span><br><span class=\"line\"> </span><br><span class=\"line\">  gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;</span><br><span class=\"line\"> </span><br><span class=\"line\">  # 是否在http header中添加Vary: Accept-Encoding，建议开启</span><br><span class=\"line\">  gzip_vary on;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>保存并重启 nginx，刷新页面（为了避免缓存，请强制刷新）就能看到效果了。以谷歌浏览器为例，通过 F12 看请求的响应头部：</p>\n<p>我们可以先来对比下，如果我们没有开启 zip 压缩之前，我们的对应的文件大小，如下所示：</p>\n<p><img src=\"/img/202301/20230221142507.png\" alt=\"erik\"><br>现在我们开启了 gzip 进行压缩后的文件的大小，可以看到如下所示：</p>\n<p><img src=\"/img/202301/20230221142538.png\" alt=\"erik\"><br>并且我们查看响应头会看到 gzip 这样的压缩，如下所示</p>\n<p><img src=\"/img/202301/20230221142558.png\" alt=\"erik\"><br>gzip 压缩前后效果对比：jquery 原大小 90kb，压缩后只有 30kb。</p>\n<p>gzip 虽然好用，但是以下类型的资源不建议启用。</p>\n<p>1、图片类型</p>\n<pre><code>    原因：图片如 jpg、png 本身就会有压缩，所以就算开启 gzip 后，压缩前和压缩后大小没有多大区别，所以开启了反而会白白的浪费资源。（Tips：可以试试将一张 jpg 图片压缩为 zip，观察大小并没有多大的变化。虽然 zip 和 gzip 算法不一样，但是可以看出压缩图片的价值并不大）\n</code></pre><p>2、大文件<br>原因：会消耗大量的 cpu 资源，且不一定有明显的效果。</p>\n<h4 id=\"ngx-http-upstream-module-的作用是什么\"><a href=\"#ngx-http-upstream-module-的作用是什么\" class=\"headerlink\" title=\"ngx_http_upstream_module 的作用是什么?\"></a>ngx_http_upstream_module 的作用是什么?</h4><hr>\n<pre><code>    ngx_http_upstream_module 用于定义可通过 fastcgi 传递、proxy 传递、uwsgi 传递、memcached 传递和 scgi 传递指令来引用的服务器组。\n</code></pre><h4 id=\"什么是-C10K-问题\"><a href=\"#什么是-C10K-问题\" class=\"headerlink\" title=\"什么是 C10K 问题?\"></a>什么是 C10K 问题?</h4><hr>\n<p>C10K 问题是指无法同时处理大量客户端 (10,000) 的网络套接字。</p>\n<h4 id=\"Nginx-是否支持将请求压缩到上游\"><a href=\"#Nginx-是否支持将请求压缩到上游\" class=\"headerlink\" title=\"Nginx 是否支持将请求压缩到上游?\"></a>Nginx 是否支持将请求压缩到上游?</h4><hr>\n<pre><code>    您可以使用 Nginx 模块 gunzip 将请求压缩到上游。gunzip 模块是一个过滤器，它可以对不支持 “gzip” 编码方法的客户机或服务器使用 “内容编码: gzip” 来解压缩响应。\n</code></pre><h4 id=\"如何在-Nginx-中获得当前的时间\"><a href=\"#如何在-Nginx-中获得当前的时间\" class=\"headerlink\" title=\"如何在 Nginx 中获得当前的时间?\"></a>如何在 Nginx 中获得当前的时间?</h4><hr>\n<p>要获得 Nginx 的当前时间，必须使用 SSI 模块、和 date_local 的变量。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Proxy_set_header THE-TIME $date_gmt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"用-Nginx-服务器解释-s-的目的是什么\"><a href=\"#用-Nginx-服务器解释-s-的目的是什么\" class=\"headerlink\" title=\"用 Nginx 服务器解释 - s 的目的是什么?\"></a>用 Nginx 服务器解释 - s 的目的是什么?</h4><hr>\n<p>用于运行 Nginx -s 参数的可执行文件。</p>\n<h4 id=\"如何在-Nginx-服务器上添加模块\"><a href=\"#如何在-Nginx-服务器上添加模块\" class=\"headerlink\" title=\"如何在 Nginx 服务器上添加模块?\"></a>如何在 Nginx 服务器上添加模块?</h4><hr>\n<p>在编译过程中，必须选择 Nginx 模块，因为 Nginx 不支持模块的运行时间选择。</p>\n<h4 id=\"生产中如何设置-worker-进程的数量呢？\"><a href=\"#生产中如何设置-worker-进程的数量呢？\" class=\"headerlink\" title=\"生产中如何设置 worker 进程的数量呢？\"></a>生产中如何设置 worker 进程的数量呢？</h4><hr>\n<pre><code>    在有多个 cpu 的情况下，可以设置多个 worker，worker 进程的数量可以设置到和 cpu 的核心数一样多，如果在单个 cpu 上起多个 worker 进程，那么操作系统会在多个 worker 之间进行调度，这种情况会降低系统性能，如果只有一个 cpu，那么只启动一个 worker 进程就可以了。\n</code></pre><h4 id=\"nginx-状态码\"><a href=\"#nginx-状态码\" class=\"headerlink\" title=\"nginx 状态码\"></a>nginx 状态码</h4><hr>\n<p>499：</p>\n<pre><code>    服务端处理时间过长，客户端主动关闭了连接。\n</code></pre><p>502：</p>\n<p>(1).FastCGI 进程是否已经启动</p>\n<p>(2).FastCGI worker 进程数是否不够</p>\n<p>(3).FastCGI 执行时间过长</p>\n<ul>\n<li>fastcgi_connect_timeout 300;</li>\n<li>fastcgi_send_timeout 300;</li>\n<li>fastcgi_read_timeout 300;</li>\n</ul>\n<p>(4).FastCGI Buffer 不够，nginx 和 apache 一样，有前端缓冲限制，可以调整缓冲参数</p>\n<ul>\n<li>fastcgi_buffer_size 32k;</li>\n<li>fastcgi_buffers 8 32k;</li>\n</ul>\n<p>(5). Proxy Buffer 不够，如果你用了 Proxying，调整</p>\n<ul>\n<li>proxy_buffer_size 16k;</li>\n<li><p>proxy_buffers 4 16k;<br>(6).php 脚本执行时间过长</p>\n</li>\n<li><p>将 php-fpm.conf 的 0s 的 0s 改成一个时间</p>\n</li>\n</ul>\n<p>原文来源：blog.csdn.net/wuzhiwei549/article/details/122758937</p>\n",
            "tags": [
                "nginx"
            ]
        },
        {
            "id": "https://erik.xyz/2020/03/26/openresty-desc/",
            "url": "https://erik.xyz/2020/03/26/openresty-desc/",
            "title": "openresty的介绍",
            "date_published": "2020-03-25T17:56:00.000Z",
            "content_html": "<p>今天给一家公司投简历，问我用过openresty没，确实没用过，回答后没结果了。这就查了查。</p>\n<p>官方介绍如下：</p>\n<pre><code>        OpenResty® 是一个基于 Nginx 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。\n\nOpenResty® 通过汇聚各种设计精良的 Nginx 模块（主要由 OpenResty 团队自主开发），从而将 Nginx 有效地变成一个强大的通用 Web 应用平台。这样，Web 开发人员和系统工程师可以使用 Lua 脚本语言调动 Nginx 支持的各种 C 以及 Lua 模块，快速构造出足以胜任 10K 乃至 1000K 以上单机并发连接的高性能 Web 应用系统。\n\nOpenResty® 的目标是让你的Web服务直接跑在 Nginx 服务内部，充分利用 Nginx 的非阻塞 I/O 模型，不仅仅对 HTTP 客户端请求,甚至于对远程后端诸如 MySQL、PostgreSQL、Memcached 以及 Redis 等都进行一致的高性能响应。\n</code></pre>  <span id=\"more\"></span>\n<p>  另外还有一篇博客专门介绍了一下<a href=\"https://blog.openresty.com.cn/cn/how-or-alloc-mem\">OpenResty 和 Nginx 如何分配和管理内存</a></p>\n<p>  因为我用的是kali在官方提供的方法里安装源不支持，只能用包编译安装。</p>\n<p>  这里是下载不同系统和不同版本的页面 <a href=\"https://openresty.org/cn/download.html\">openresty</a><br>  <img src=\"https://erik.xyz/img/202003/2020-03-26_020859.jpg\" alt=\"版本图片\"></p>\n<p>  源配置教程 <a href=\"https://openresty.org/en/linux-packages.html\">openresty</a></p>\n<p>  <img src=\"https://erik.xyz/img/202003/yum.jpg\" alt=\"源图片\"></p>\n<p>  我<a href=\"https://openresty.org/download/openresty-1.15.8.3.tar.gz\">下载</a>的编译包</p>\n<p>  解压，后进入目录,执行如下命令（参数根据自己需要来添加）</p>\n<pre><code>      ./configure --prefix=/opt/openresty --with-pcre-jit --with-ipv6 --without-http_redis2_module --with-http_iconv_module --with-http_postgres_module -j8 --with-luajit\n</code></pre><p>然后执行</p>\n<ul>\n<li><p>如果电脑支持多核 make 工作的特性就用</p>\n<pre><code>   make j2\n</code></pre></li>\n<li><p>否则用</p>\n<pre><code>   make\n</code></pre></li>\n</ul>\n<p>以上执行完毕后，执行</p>\n<pre><code>sudo make install\n</code></pre><p>然后测试是否安装成功</p>\n<p>在任意目录创建work文件</p>\n<p>我是在/home/project/下创建文件work，并在work文件中创建conf和logs文件</p>\n<p>然后，在conf目录创建nginx.conf，并放入一下代码</p>\n<pre><code>  worker_processes  1;\n  error_log logs/error.log;\n  events &#123;\n      worker_connections 1024;\n  &#125;\n  http &#123;\n      server &#123;\n          listen 8080;\n          location / &#123;\n              default_type text/html;\n              content_by_lua_block &#123;\n                  ngx.say(&quot;&lt;p&gt;https://erik.xyz&lt;/p&gt;&quot;)\n              &#125;\n          &#125;\n      &#125;\n  &#125;\n</code></pre><p>根据我的安装在work目录下，执行：/opt/openresty/nginx/sbin/nginx -p `pwd`/ -c conf/nginx.conf</p>\n<p>启动nginx，然后浏览器或者用curl命令访问本地8080端口，就可以看到定义好输出的网址。</p>\n",
            "tags": [
                "服务器",
                "openresty"
            ]
        }
    ]
}