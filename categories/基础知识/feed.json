{
    "version": "https://jsonfeed.org/version/1",
    "title": "艾瑞可erik • All posts by \"基础知识\" categories",
    "description": "一只PHP开发的程序猿，偶尔做做运维、Goland、Python、Java、摄影、画画、写作、顺便睡觉，反正整站都搞过。",
    "home_page_url": "https://erik.xyz",
    "items": [
        {
            "id": "https://erik.xyz/2020/02/11/data-lookup-algorithm/",
            "url": "https://erik.xyz/2020/02/11/data-lookup-algorithm/",
            "title": "查找与排序",
            "date_published": "2020-02-11T04:18:00.000Z",
            "content_html": "<h3 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h3><p>1.顺序查找</p>\n<ul>\n<li>思路：从线性表的第一个元素开始，逐个将线性表中的元素与被查元素进行比较，如果相等，则查找成功，停止查找；若整个线性表扫描完毕，仍未找到与被查元素相等的元素，则表示线性表中没有要查找的元素，查找失败。</li>\n<li>最好情况下，第一个元素就是要查找的元素，则比较次数为1次</li>\n<li>最坏情况下，最后一个元素才是要找的元素，或者在线性表中，没有要查找的元素，则需要与线性表中所有的元素比较，比较次数为n次</li>\n<li>平均情况下，大约需要比较n/2次<span id=\"more\"></span></li>\n<li>唯一选择：<ul>\n<li>线性表为无序表，则不管是顺序存储结构，还是链式存储结构，都只能用顺序查找</li>\n<li>即使线性表是有序的，如果采用链式存储结构，也只能用顺序查找<br>2.二分查找</li>\n</ul>\n</li>\n<li>满足条件<ul>\n<li>用顺序存储结构</li>\n<li>线性表是有序的，有序是指元素按非递减排列，即从小到大排列，且允许相邻元素相等</li>\n</ul>\n</li>\n<li>对于长度为n的有序线性表，利用二分查找元素X的过程<ul>\n<li>如果X的值与中间项的值相等，则查找成功，结束查找</li>\n<li>如果X小于中间项的值，则在线性表的前半部分以二分法继续查找</li>\n<li>如果X大于中间项的值，则在线性表的后半部分以二分法继续查找</li>\n</ul>\n</li>\n<li>顺序查找法每一次比较，只将查找范围减少1，而二分法查找，每比较一次，可将查找范围减少为原来的一半，效率大大提高。对于长度为n的有序线性表，在最坏情况下，二分法查找只需比较$log_{2}n$次</li>\n</ul>\n<h3 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h3><p>1.交换类排序</p>\n<ul>\n<li>冒泡排序<ul>\n<li>冒泡排序就是通过两两相邻数据元素之间的比较和交换，不断地消去逆序，直到所有数据元素有序为止</li>\n<li>最坏情况下，长度为n的线性表排序，冒泡排序需要比较的次数为n(n-1)/2</li>\n</ul>\n</li>\n<li>快速排序<ul>\n<li>快速排序就是在待排序的n个元素中取一个元素K,以元素K作为分割标准，把所有小于K元素的数据元素都移到K前面，把所有大于K元素的数据元素都移到K后面。这样，以K为分界线，把线性表分割为两个子表，这称为一趟排序。然后，对K前后的两个子表分别重复上述过程。继续下去，直到分割的子表的长度为1为止。</li>\n<li>快速排序最坏的情况需要进行n(n-1)/2次比较，实际效率比冒泡排序高</li>\n</ul>\n</li>\n</ul>\n<p>2.插入类排序</p>\n<ul>\n<li>插入排序是每次将一个待排序元素，按其元素值的大小插入到前面已经排好序的子表中的适当位置，直到全部元素插入完成为止</li>\n<li>简单插入排序<ul>\n<li>把n个待排序的元素看成是一个有序表和一个无序表，开始时，有序表只包含一个元素，而无序表包含另外n-1个元素，每次取无序表中的第一个元素插入到有序表中的正确位置，使之成为增加一个元素的新的有序表。插入元素时，插入位置及其后的记录依次向后移动。最后有序表的长度为n，而无序表为空，此时排序完成</li>\n<li>最坏情况，简单插入排序需要n(n-1)/2次比较</li>\n</ul>\n</li>\n<li>希尔排序<ul>\n<li>先取一个整数$d<em>{1} &lt; n$，把全部数据元素分成$d</em>{1}$个组，所有距离为$d<em>{1}$倍数的元素放在一组中，组成了一个子序列，对每个子序列分别进行简单插入排序。然后取$d</em>{2} &lt; d<em>{1}$重复上述分组和排序工作，直到$d</em>{i} = 1$，即所有记录在一组中为止</li>\n<li>希尔排序的效率与所选取的增量序列有关，最坏情况下，希尔排序需要比较的次数是$n ^{r}(1&lt;r&lt;2)$</li>\n</ul>\n</li>\n</ul>\n<p>3.选择类排序</p>\n<ul>\n<li>通过每一趟从待排序序列中选出值最小的元素，顺序放在已安排好序的有序子表的后面，直到全部序列满足排序要求为止</li>\n<li>简单选择排序<ul>\n<li>先从所有n个待排序的数据元素中选择最小的元素，将该元素与第1个元素交换，再从剩下的n-1个元素中选出最小的元素与第2个元素交换。重复这样的操作直到所有的元素有序为止</li>\n<li>简单选择排序法在最坏的情况下需要比较n(n-1)/2次</li>\n</ul>\n</li>\n<li>堆排序<ul>\n<li>若有n个元素的序列$(h<em>{1},h</em>{2},\\cdots h<em>{n})$，将元素按顺序组成一棵完全二叉树，当且仅当满足下列条件时称为堆。$ \\begin{cases} h</em>{i} \\geq h<em>{2i} \\newline h</em>{i} \\geq h<em>{2i+1} \\end{cases}$ 或者$ \\begin{cases} h</em>{i} \\leq h<em>{2i} \\newline h</em>{i} \\leq h_{2i+1} \\end{cases}$ 其中，$ i=1,2,3,\\cdots,n/2 $</li>\n<li>第一种情况称为大根堆，所有节点的值大于或等于左右子节点的值。第二种情况称为小根堆，所有节点的值小于或等于左右子节点的值</li>\n<li>堆排序最坏情况需要$ nlog_{2}n$次比较</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "查找",
                "排序",
                "快速排序",
                "冒泡排序",
                "二分查找"
            ]
        },
        {
            "id": "https://erik.xyz/2020/02/01/tree-binary-tree/",
            "url": "https://erik.xyz/2020/02/01/tree-binary-tree/",
            "title": "树与二叉树",
            "date_published": "2020-02-01T13:07:00.000Z",
            "content_html": "<h3 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h3><p>树，不是我们常见的长在土里的树木，而是计算机语言中的一种结构。</p>\n<ul>\n<li><p>树是一种简单的非线性结构</p>\n<ul>\n<li>父节点<ul>\n<li>树结构中，每一个节点只有一个前件，称为该节点的父节点；没有前件的节点只有一个，称为树的根节点，简称树的根</li>\n</ul>\n</li>\n<li>子节点和叶子节点<ul>\n<li>树结构中，每一个节点可以有多个后件，称为该节点的子节点。没有后件的节点称为叶子节点<span id=\"more\"></span></li>\n</ul>\n</li>\n<li>度<ul>\n<li>树结构中，每一个节点所拥有的后件个数称为该节点的度，所有节点中最大的度称为树的度</li>\n</ul>\n</li>\n<li>深度<ul>\n<li>定义一棵树的根节点所在的层次为1，其他节点所在的层次等于它的父节点所在的层次加1。树的最大层次称为树的深度</li>\n</ul>\n</li>\n<li>子树<ul>\n<li>在树中，以某节点的一个子节点为根构成的树称为该节点的一棵子树</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>在树中，树中的节点数等于树中所有节点的度之和再加1</p>\n</li>\n</ul>\n<h3 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h3><p>1.特点</p>\n<ul>\n<li>二叉树可以为空，空的二叉树没有节点，非空二叉树有且只有一个根节点</li>\n<li>每个节点最多有两棵子树，即二叉树中不存在度大于2的节点</li>\n<li>二叉树的子树有左右之分，其次序不能任意颠倒</li>\n</ul>\n<p>2.性质</p>\n<ul>\n<li>在二叉树的第k层上，最多有$ 2 ^{k-1}(k \\geq 1)$个节点</li>\n<li>深度为m的二叉树中，最多有$ 2 ^{m}-1$个节点</li>\n<li>对任何一棵二叉树，度为0的节点（即叶节点）总是比度为2的节点多一个</li>\n<li>具有n个节点的二叉树，其深度至少为$[log<em>{2}n]+1$,其中$[log</em>{2}n]$表示取$log_{2}n$的整数部分</li>\n<li>具有n个节点的完全二叉树的深度为$[log_{2}n]+1$</li>\n</ul>\n<p>3.满二叉树和完全二叉树</p>\n<ul>\n<li>满二叉树<ul>\n<li>满二叉树是指除最后一层外，每一层上的所有节点都有两个子节点的二叉树</li>\n</ul>\n</li>\n<li>完全二叉树<ul>\n<li>完全二叉树是指除最后一层外，每一层上的节点数均达到最大值，在最后一层上只缺少右边的若干节点的二叉树</li>\n<li>满二叉树一定是完全二叉树，完全二叉树一般不是满二叉树</li>\n<li>完全二叉树特点</li>\n<li>叶子节点只可能在最后两层出现</li>\n<li>对于任一节点，若其右子树的深度为m，则该节点左子树的深度为m或为m+1</li>\n<li>二叉树采用链式存储结构。用于存储二叉树中元素的存储节点由数据域和指针域两部分构成</li>\n<li>二叉树的存储结构中每一个存储节点有两个指针域，因此，二叉树的链式存储结构也称为二叉链表。对于满二叉树与完全二叉树可以按层次进行顺序存储</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二叉树的遍历\"><a href=\"#二叉树的遍历\" class=\"headerlink\" title=\"二叉树的遍历\"></a>二叉树的遍历</h3><p>1.前序遍历</p>\n<ul>\n<li>首先访问根节点，然后遍历左子树，最后遍历右子树；并且在遍历左子树和右子树时，仍然先访问根节点，然后遍历左子树，最后遍历右子树</li>\n</ul>\n<p>2.中序遍历</p>\n<ul>\n<li>首先遍历左子树，然后访问根节点，最后遍历右子树。并且在遍历左子树和右子树时，仍然首先遍历左子树，然后访问根节点，最后遍历右子树</li>\n</ul>\n<p>3.后序遍历</p>\n<ul>\n<li>首先遍历左子树，然后遍历右子树，最后访问根节点；并且在遍历左子树和右子树时，仍然首先遍历左子树，然后遍历右子树，最后访问根节点<ul>\n<li>如果已知一棵二叉树的前序遍历序列和中序遍历序列，可以唯一确定这棵二叉树；已知一棵二叉树的后序遍历序列和中序遍历序列，也可以唯一确定这棵二叉树。但是，已知一棵二叉树的前序列遍历序列和后序遍历序列，不能唯一确定这棵二叉树</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "树",
                "二叉树"
            ]
        },
        {
            "id": "https://erik.xyz/2020/01/29/review-points/",
            "url": "https://erik.xyz/2020/01/29/review-points/",
            "title": "算法、数据结构、线性结构、栈、队列",
            "date_published": "2020-01-29T14:46:00.000Z",
            "content_html": "<h3 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h3><p>1.算法的基本特征</p>\n<ul>\n<li>可行性<ul>\n<li>步骤实现，执行结果达到预期<ul>\n<li>确定性</li>\n</ul>\n</li>\n<li>步骤明确<ul>\n<li>有穷性</li>\n</ul>\n</li>\n<li>有限的时间完成<ul>\n<li>拥有足够的情报</li>\n</ul>\n</li>\n<li>拥有足够的输入信息和初始化信息<span id=\"more\"></span>\n</li>\n</ul>\n</li>\n</ul>\n<p>2.算法的复杂度</p>\n<ul>\n<li>时间复杂度<ul>\n<li>执行算法所需要的计算工作量</li>\n</ul>\n</li>\n<li>空间复杂度<ul>\n<li>执行算法所需要的内存空间</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><ol>\n<li>定义：有关联的数据元素的集合就是数据结构。</li>\n</ol>\n<ul>\n<li>数据结构的概念<ul>\n<li>根节点<ul>\n<li>没有前件的节点</li>\n</ul>\n</li>\n<li>终端节点<ul>\n<li>没有后件的节点</li>\n</ul>\n</li>\n<li>内部节点<ul>\n<li>除了根节点和终端节点以外的节点</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"线性结构与非线性结构\"><a href=\"#线性结构与非线性结构\" class=\"headerlink\" title=\"线性结构与非线性结构\"></a>线性结构与非线性结构</h3><p>1.线性结构</p>\n<ul>\n<li>有且只有一个根节点</li>\n<li>每个节点最多只有一个前件，也最多只有一个后件</li>\n</ul>\n<p>2.非线性结构：不满足线性结构的两个条件就是非线性结构</p>\n<ul>\n<li>树形结构</li>\n<li>网状结构</li>\n</ul>\n<h3 id=\"线性表\"><a href=\"#线性表\" class=\"headerlink\" title=\"线性表\"></a>线性表</h3><p>1.线性结构也被称为线性表</p>\n<p>2.非空线性表</p>\n<ul>\n<li>只有一个根节点</li>\n<li>有且只有一个终端节点</li>\n<li>除根节点与终端节点外，其他所有节点有且只有一个前件，也有且只有一个后件</li>\n</ul>\n<h3 id=\"线性表的顺序存储\"><a href=\"#线性表的顺序存储\" class=\"headerlink\" title=\"线性表的顺序存储\"></a>线性表的顺序存储</h3><p>1.定义：线性表的顺序存储是将线性表中的元素一个接一个地存储在一片相邻的存储区域中，这种线性表也叫顺序表</p>\n<p>2.顺序表特征</p>\n<ul>\n<li>线性表中所有元素所占的存储空间是连续的</li>\n<li>线性表中各数据元素在存储空间中是按逻辑顺序依次存放的</li>\n</ul>\n<h3 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h3><p>1.定义：栈是一种特殊的线性表，它所有的插入与删除都限定在表的同一端进行，允许插入与删除的一端称为栈顶，不允许插入与删除的另一端称为栈底。当栈中没有元素时，称为空栈。</p>\n<p>2.栈的修改原则是后进先出或先进后出</p>\n<p>3.栈的基本运算： 入栈、退栈、读栈顶元素</p>\n<h3 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h3><p>1.定义：允许在一端进行插入，而在另一端进行删除的线性表</p>\n<p>2.允许进行删除运算的一端称为队头，允许进行插入运算的一端称为队尾</p>\n<h3 id=\"顺序表和链表的对比\"><a href=\"#顺序表和链表的对比\" class=\"headerlink\" title=\"顺序表和链表的对比\"></a>顺序表和链表的对比</h3><p>1.顺序表</p>\n<ul>\n<li>优点<ul>\n<li>可随机存取表中的任意节点</li>\n<li>无需为表示节点间的逻辑关系额外增加存储空间</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>顺序表的插入和删除运算效率很低</li>\n<li>顺序表的存储空间不便扩充</li>\n<li>顺序表不便于对存储空间的动态分配</li>\n</ul>\n</li>\n</ul>\n<p>2.链表</p>\n<ul>\n<li>优点<ul>\n<li>在进行插入和删除运算时，只需要改变指针即可，不需要移动元素</li>\n<li>链表的存储空间易于扩充并且方便空间的动态分配</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li>需要额外的空间来表示数据元素之间的逻辑关系，存储密度比顺序表低</li>\n</ul>\n</li>\n<li><p>链表类型</p>\n<ul>\n<li>单向链表<ul>\n<li>链表的链接方向是单向的，对链表的访问要通过顺序读取从头部开始，链表是使用指针进行构造的列表；又称为结点列表</li>\n<li>单个结点创建非常方便，普通的线性内存通常在创建的时候就需要设定数据的大小</li>\n<li>结点的删除非常方便，不需要像线性结构那样移动剩下的数据</li>\n<li>结点的访问方便，可以通过循环或者递归的方法访问到任意数据，但是平均的访问效率低于线性表</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>双向链表</p>\n<ul>\n<li>每个数据结点中都有两个指针，分别指向直接后继和直接前驱。双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点</li>\n</ul>\n</li>\n<li><p>环形链表</p>\n<ul>\n<li>最后一个结点指向头结点，形成一个环。从循环链表中的任何一个结点出发都能找到任何其他结点</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "算法",
                "队列",
                "栈",
                "顺序表",
                "链表",
                "数据结构",
                "线性结构"
            ]
        }
    ]
}