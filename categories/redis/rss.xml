<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>艾瑞可erik • Posts by &#34;redis&#34; categories</title>
        <link>https://erik.xyz</link>
        <description>一只PHP开发的程序猿，偶尔做做运维、Goland、Python、Java、摄影、画画、写作、顺便睡觉，反正整站都搞过。</description>
        <language>zh-CN</language>
        <pubDate>Mon, 15 Nov 2021 21:43:00 +0800</pubDate>
        <lastBuildDate>Mon, 15 Nov 2021 21:43:00 +0800</lastBuildDate>
        <category>日志</category>
        <category>工具</category>
        <category>php扩展</category>
        <category>php技巧</category>
        <category>php类库</category>
        <category>php资源</category>
        <category>jquery</category>
        <category>jquery插件</category>
        <category>js</category>
        <category>css</category>
        <category>php</category>
        <category>web</category>
        <category>代码</category>
        <category>压缩</category>
        <category>说说</category>
        <category>趣闻</category>
        <category>php服务器</category>
        <category>随笔</category>
        <category>php实例</category>
        <category>nginx</category>
        <category>转载</category>
        <category>php库</category>
        <category>互联</category>
        <category>项目实战</category>
        <category>javascript</category>
        <category>漏洞</category>
        <category>php应用</category>
        <category>浮点</category>
        <category>http</category>
        <category>http服务器</category>
        <category>负载均衡</category>
        <category>kali</category>
        <category>kali安装</category>
        <category>农业系统</category>
        <category>系统设计</category>
        <category>克莱姆法则</category>
        <category>行列式</category>
        <category>n阶行列式</category>
        <category>支付系统</category>
        <category>支付</category>
        <category>centos</category>
        <category>linux</category>
        <category>apache优化</category>
        <category>apache隐藏index</category>
        <category>nginx优化</category>
        <category>nginx隐藏index</category>
        <category>日常</category>
        <category>seo</category>
        <category>优化</category>
        <category>摘要</category>
        <category>文章</category>
        <category>游记</category>
        <category>ca证书</category>
        <category>证书生成</category>
        <category>二战</category>
        <category>二战熊</category>
        <category>西伯利亚熊</category>
        <category>centos软件</category>
        <category>yum仓库</category>
        <category>软件</category>
        <category>centos安装chromium报错</category>
        <category>chromium安装报错</category>
        <category>svn</category>
        <category>代码提交</category>
        <category>deb</category>
        <category>deb/rpm互转</category>
        <category>deb转rpm</category>
        <category>rpm互转</category>
        <category>centos7安装steam</category>
        <category>centos安装steam</category>
        <category>centos安装吃鸡steam</category>
        <category>linux安装steam</category>
        <category>steam安装</category>
        <category>centos软件安装</category>
        <category>centos6.5</category>
        <category>linux系统</category>
        <category>centos7安装Redis Desktop Manager</category>
        <category>centos7安装redis桌面</category>
        <category>centos安装redis桌面</category>
        <category>linux安装centos7安装Redis Desktop Manager</category>
        <category>Redis Desktop Manager</category>
        <category>redis桌面</category>
        <category>centos7</category>
        <category>centos7-wine</category>
        <category>wine</category>
        <category>wine安装</category>
        <category>root密码</category>
        <category>root密码重置</category>
        <category>忘记root密码</category>
        <category>memcache</category>
        <category>memcached</category>
        <category>生活手记</category>
        <category>艾瑞可erik</category>
        <category>程序员</category>
        <category>开源云</category>
        <category>容器</category>
        <category>cncf</category>
        <category>监控</category>
        <category>composer</category>
        <category>composer部署</category>
        <category>内网部署composer</category>
        <category>cphalcon</category>
        <category>cphalcon报错</category>
        <category>css中的em</category>
        <category>响应式字体</category>
        <category>响应式布局样式</category>
        <category>proxy代理搭建</category>
        <category>代理服务器搭建</category>
        <category>proxy服务器</category>
        <category>查找</category>
        <category>排序</category>
        <category>快速排序</category>
        <category>冒泡排序</category>
        <category>二分查找</category>
        <category>datahub</category>
        <category>datahub安装</category>
        <category>deepin</category>
        <category>emergency</category>
        <category>emergency mode</category>
        <category>deepin黑屏</category>
        <category>清理系统</category>
        <category>清理c盘</category>
        <category>dns</category>
        <category>域名监测</category>
        <category>网站监测</category>
        <category>docker</category>
        <category>php安装</category>
        <category>杂谈</category>
        <category>ecshop</category>
        <category>框架</category>
        <category>beego数据分页</category>
        <category>分页</category>
        <category>elasticsearch</category>
        <category>elasticsearch搭建</category>
        <category>elasticsearch集群</category>
        <category>系统</category>
        <category>emm</category>
        <category>mdm</category>
        <category>phone</category>
        <category>手机</category>
        <category>新闻</category>
        <category>免费</category>
        <category>jenkis</category>
        <category>jenkis教程</category>
        <category>随笔吐槽</category>
        <category>算法</category>
        <category>ping</category>
        <category>ping服务器</category>
        <category>各大网站ping</category>
        <category>搜引擎ping服务器</category>
        <category>go获取ip</category>
        <category>im</category>
        <category>go中pdf生成</category>
        <category>go中限流</category>
        <category>go对接快递签名</category>
        <category>go时间获取</category>
        <category>go类型转换</category>
        <category>微服务</category>
        <category>go-zero</category>
        <category>rpc</category>
        <category>go加密</category>
        <category>go解密</category>
        <category>归</category>
        <category>吐槽</category>
        <category>php大全</category>
        <category>php资料</category>
        <category>hadoop</category>
        <category>hadoop2.8.0</category>
        <category>hadoop安装教程</category>
        <category>hadoop安装详细教程</category>
        <category>hadoop教程</category>
        <category>hadoop部署</category>
        <category>hadoop3</category>
        <category>hadoop配置</category>
        <category>log4j2</category>
        <category>数据库</category>
        <category>hbase安装教程</category>
        <category>hbase</category>
        <category>http1.1</category>
        <category>http2.0</category>
        <category>会话</category>
        <category>会话原理</category>
        <category>hyperf</category>
        <category>杂录</category>
        <category>新冠肺炎</category>
        <category>springboot</category>
        <category>springboot内网部署</category>
        <category>linux恢复</category>
        <category>linux误删</category>
        <category>linux命令</category>
        <category>linux命令汇总</category>
        <category>jenkins</category>
        <category>jetbtrains</category>
        <category>phpstorm</category>
        <category>搜索引擎</category>
        <category>图片</category>
        <category>素材</category>
        <category>jq</category>
        <category>jq侧边导航</category>
        <category>侧边导航</category>
        <category>js判断浏览器</category>
        <category>js判断浏览器版本</category>
        <category>判断浏览器</category>
        <category>浏览器版本判断</category>
        <category>获取浏览器信息</category>
        <category>kali右键汉化</category>
        <category>kali桌面右键汉化</category>
        <category>kali右键创建文件</category>
        <category>区块链</category>
        <category>lanmp</category>
        <category>php环境独立配置</category>
        <category>服务器</category>
        <category>劳动纠纷</category>
        <category>追缴工资</category>
        <category>申请仲裁</category>
        <category>flash</category>
        <category>表单</category>
        <category>linux报错</category>
        <category>linux中update-command-not-found</category>
        <category>linux运行命令报错</category>
        <category>web前端</category>
        <category>web优化</category>
        <category>撮合算法</category>
        <category>撮合</category>
        <category>php撮合算法</category>
        <category>maven搭建库</category>
        <category>maven</category>
        <category>maven内网库</category>
        <category>高级缓存配置</category>
        <category>mongodb</category>
        <category>mongodb权限</category>
        <category>可穿戴设备</category>
        <category>mysql</category>
        <category>分库分表</category>
        <category>mysql应对千万级</category>
        <category>mysql瓶颈</category>
        <category>mysql瓶颈解决办法</category>
        <category>redis</category>
        <category>数据一致性</category>
        <category>mysql消息</category>
        <category>mysql队列</category>
        <category>mysql高并发</category>
        <category>mysql存储</category>
        <category>mysql引擎</category>
        <category>mysql数据表设计选择</category>
        <category>mysql监控</category>
        <category>mysql性能</category>
        <category>内网支付</category>
        <category>内网穿透</category>
        <category>支付接口本地化开发</category>
        <category>本地挂网</category>
        <category>穿透</category>
        <category>go</category>
        <category>new和make的区别</category>
        <category>红包算法</category>
        <category>深圳劳动法服务部门</category>
        <category>非关系型数据库</category>
        <category>onethink</category>
        <category>oop</category>
        <category>php管理系统</category>
        <category>开放接口开发</category>
        <category>开源工具</category>
        <category>桌面共享工具</category>
        <category>openresty</category>
        <category>openvas</category>
        <category>openvas安装</category>
        <category>php变量</category>
        <category>php超级全局变量</category>
        <category>php超级变量</category>
        <category>php基本类型</category>
        <category>php数据类型</category>
        <category>php设计模式</category>
        <category>php对接微信支付</category>
        <category>微信支付</category>
        <category>微信支付回调</category>
        <category>游戏</category>
        <category>php函数</category>
        <category>php随机数</category>
        <category>php获取闰年</category>
        <category>闰年.php时间</category>
        <category>php环境</category>
        <category>php集成环境</category>
        <category>服务器集成环境</category>
        <category>数组函数</category>
        <category>数组排序函数</category>
        <category>php数学函数</category>
        <category>php面试题</category>
        <category>php面向对象</category>
        <category>面向对象</category>
        <category>php-zookeeper</category>
        <category>zookeeper3.5.5</category>
        <category>php-zookeeper扩展</category>
        <category>php串口开发</category>
        <category>php倒计时</category>
        <category>php时间</category>
        <category>倒计时</category>
        <category>计算时间</category>
        <category>PHP数组</category>
        <category>字符串函数</category>
        <category>排序函数</category>
        <category>php的SPL</category>
        <category>SPL手册</category>
        <category>PHP算法</category>
        <category>php递归</category>
        <category>递归</category>
        <category>phpunit</category>
        <category>phpunit安装</category>
        <category>php过滤</category>
        <category>过滤</category>
        <category>foreach</category>
        <category>foreach报错</category>
        <category>php中foreach报错</category>
        <category>php中if</category>
        <category>php中if判断</category>
        <category>php的if</category>
        <category>php字符串</category>
        <category>php7中sphinx</category>
        <category>php7中sphinx扩展</category>
        <category>sphinx扩展</category>
        <category>python</category>
        <category>python库</category>
        <category>a标签</category>
        <category>a标签虚线</category>
        <category>虚线框</category>
        <category>R语言</category>
        <category>数据随机化</category>
        <category>redis总结</category>
        <category>redis命令</category>
        <category>redis监控</category>
        <category>redis锁</category>
        <category>redis分布式锁</category>
        <category>任意金额输入</category>
        <category>10元、5元、2元</category>
        <category>队列</category>
        <category>栈</category>
        <category>顺序表</category>
        <category>链表</category>
        <category>数据结构</category>
        <category>线性结构</category>
        <category>浏览器禁止操作视频</category>
        <category>禁止视频</category>
        <category>响应慢</category>
        <category>页面优化</category>
        <category>js编辑</category>
        <category>runjs</category>
        <category>在线编辑</category>
        <category>rust</category>
        <category>rust配置</category>
        <category>seajs</category>
        <category>session</category>
        <category>路由器烧录</category>
        <category>烧录</category>
        <category>极路由2烧录</category>
        <category>砖头烧录</category>
        <category>免费服务器</category>
        <category>空间</category>
        <category>资源</category>
        <category>深圳政府电话</category>
        <category>深圳电话</category>
        <category>特区电话</category>
        <category>居住证</category>
        <category>居住证签注</category>
        <category>深圳新居住证</category>
        <category>国庆骑行</category>
        <category>深圳珠海骑行</category>
        <category>骑行</category>
        <category>世界那么大</category>
        <category>css3</category>
        <category>css在线生成工具</category>
        <category>css工具</category>
        <category>php正则</category>
        <category>正则</category>
        <category>shodan</category>
        <category>黑谷歌</category>
        <category>黒帽搜素</category>
        <category>shopex</category>
        <category>可视化数据</category>
        <category>数据</category>
        <category>数据表</category>
        <category>socket通信</category>
        <category>socket多进程</category>
        <category>socket</category>
        <category>json</category>
        <category>json数组</category>
        <category>json解析</category>
        <category>sql</category>
        <category>sql优化</category>
        <category>css3兼容360浏览器兼容模式</category>
        <category>css圆角</category>
        <category>结构体转map</category>
        <category>config</category>
        <category>thinkphp</category>
        <category>配置文件</category>
        <category>树</category>
        <category>二叉树</category>
        <category>js插件</category>
        <category>web自适应</category>
        <category>响应式布局</category>
        <category>响应式所有分辨率</category>
        <category>自适应布局</category>
        <category>自适应所有分辨率</category>
        <category>webman</category>
        <category>mysql设置超时，超时</category>
        <category>markdown</category>
        <category>wget</category>
        <category>wget抓取</category>
        <category>网站抓取</category>
        <category>我在</category>
        <category>wordpress</category>
        <category>wordpress标签</category>
        <category>域名合并</category>
        <category>wpscan</category>
        <category>usbrip</category>
        <category>无限极分类</category>
        <category>php无限极</category>
        <category>分类tree</category>
        <category>无限极分类树型</category>
        <category>xhprof</category>
        <category>laravel</category>
        <category>composer插件</category>
        <category>html</category>
        <category>响应式分辨率</category>
        <category>响应式调试</category>
        <category>自适应屏幕</category>
        <category>携程</category>
        <category>携程攻击</category>
        <category>携程网站瘫痪</category>
        <category>物理删除</category>
        <category>3D</category>
        <category>动画</category>
        <category>平台</category>
        <category>虚幻4引擎编辑</category>
        <category>生成唯一id</category>
        <category>生成id</category>
        <category>发邮件</category>
        <category>邮件函数</category>
        <category>储蓄卡免年费</category>
        <category>银行卡</category>
        <category>银行卡免年费</category>
        <category>composer安装</category>
        <category>composer配置</category>
        <category>项目创建composer</category>
        <category>mysql优化</category>
        <category>mysql读写优化</category>
        <category>数据库优化，mysql语句优化</category>
        <category>php加密</category>
        <category>php技术</category>
        <category>夕阳</category>
        <category>mysql函数</category>
        <category>php中mysql函数</category>
        <category>互联网时代</category>
        <category>开源技术</category>
        <category>web框架</category>
        <category>php抓取图片</category>
        <category>php批量抓取页面图片</category>
        <category>邮箱服务器</category>
        <category>正则表达式</category>
        <category>翻墙</category>
        <category>谷歌</category>
        <category>谷歌搜索</category>
        <category>php架构</category>
        <category>php服务</category>
        <category>php服务设计</category>
        <item>
            <guid isPermalink="true">https://erik.xyz/2021/11/15/reids-info-lock/</guid>
            <title>细说Redis分布式锁</title>
            <link>https://erik.xyz/2021/11/15/reids-info-lock/</link>
            <category>redis</category>
            <category>redis锁</category>
            <category>redis分布式锁</category>
            <pubDate>Mon, 15 Nov 2021 21:43:00 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;谈起Redis锁，下面三个，算是出现最多的高频词汇：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Setnx&lt;/li&gt;
&lt;li&gt;Redlock&lt;/li&gt;
&lt;li&gt;Redisson&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Setnx&lt;/p&gt;
&lt;p&gt;其实目前通常所说的Setnx命令，并非单指Redis的setnx key value这条命令。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;p&gt;一般代指Redis中对set命令加上nx参数进行使用，set这个命令，目前已经支持这么多参数可选：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SET key value [EX seconds|PX milliseconds] [NX|XX] [KEEPTTL]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当然了，就不在文章中默写API了，基础参数还有不清晰的，可以蹦到官网：&lt;a href=&#34;https://redis.io/commands/set&#34;&gt;https://redis.io/commands/set&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2021/11/20211115214422.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;上图是笔者画的Setnx大致原理，主要依托了它的key不存在才能set成功的特性，进程A拿到锁，在没有删除锁的Key时，进程B自然获取锁就失败了。&lt;/p&gt;
&lt;p&gt;那么为什么要使用PX 30000去设置一个超时时间？&lt;/p&gt;
&lt;p&gt;是怕进程A不讲道理啊，锁没等释放呢，万一崩了，直接原地把锁带走了，导致系统中谁也拿不到锁。&lt;/p&gt;
&lt;p&gt;就算这样，还是不能保证万无一失。&lt;/p&gt;
&lt;p&gt;如果进程A又不讲道理，操作锁内资源超过笔者设置的超时时间，那么就会导致其他进程拿到锁，等进程A回来了，回手就是把其他进程的锁删了，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2021/11/20211115214716.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;还是刚才那张图，将T5时刻改成了锁超时，被Redis释放。&lt;/p&gt;
&lt;p&gt;进程B在T6开开心心拿到锁不到一会，进程A操作完成，回手一个del，就把锁释放了。&lt;/p&gt;
&lt;p&gt;当进程B操作完成，去释放锁的时候（图中T8时刻）：&lt;/p&gt;
&lt;p&gt;找不到锁其实还算好的，万一T7时刻有个进程C过来加锁成功，那么进程B就把进程C的锁释放了。&lt;/p&gt;
&lt;p&gt;以此类推，进程C可能释放进程D的锁，进程D……（禁止套娃），具体什么后果就不得而知了。&lt;/p&gt;
&lt;p&gt;所以在用Setnx的时候，key虽然是主要作用，但是value也不能闲着，可以设置一个唯一的客户端ID，或者用UUID这种随机数。&lt;/p&gt;
&lt;p&gt;当解锁的时候，先获取value判断是否是当前进程加的锁，再去删除。伪代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String uuid = xxxx;
// 伪代码，具体实现看项目中用的连接工具
// 有的提供的方法名为set，有的叫setIfAbsent
set Test uuid NX PX 3000
try&amp;#123;
// biz handle....
&amp;#125; finally &amp;#123;
    // unlock
    if(uuid.equals(redisTool.get(&amp;#39;Test&amp;#39;))&amp;#123;
        redisTool.del(&amp;#39;Test&amp;#39;);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这回看起来是不是稳了。&lt;/p&gt;
&lt;p&gt;相反，这回的问题更明显了，在finally代码块中，get和del并非原子操作，还是有进程安全问题。&lt;/p&gt;
&lt;p&gt;为什么有问题还说这么多呢？&lt;/p&gt;
&lt;p&gt;第一，搞清劣势所在，才能更好的完善。&lt;/p&gt;
&lt;p&gt;第二点，其实上文中最后这段代码，还是有很多公司在用的。&lt;/p&gt;
&lt;p&gt;大小项目悖论：大公司实现规范，但是小司小项目虽然存在不严谨，可并发倒也不高，出问题的概率和大公司一样低。——鲁迅&lt;/p&gt;
&lt;p&gt;那么删除锁的正确姿势之一，就是可以使用Lua脚本，通过Redis的eval/evalsha命令来运行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-- Lua删除锁：
-- KEYS和ARGV分别是以集合方式传入的参数，对应上文的Test和uuid。
-- 如果对应的value等于传入的uuid。
if redis.call(&amp;#39;get&amp;#39;, KEYS[1]) == ARGV[1] 
    then 
 -- 执行删除操作
        return redis.call(&amp;#39;del&amp;#39;, KEYS[1]) 
    else 
 -- 不成功，返回0
        return 0 
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过Lua脚本能保证原子性的原因说的通俗一点：&lt;/p&gt;
&lt;p&gt;就算你在Lua里写出花，执行也是一个命令（eval/evalsha）去执行的，一条命令没执行完，其他客户端是看不到的。&lt;/p&gt;
&lt;p&gt;那么既然这么麻烦，有没有比较好的工具呢？就要说到Redisson了。&lt;/p&gt;
&lt;p&gt;介绍Redisson之前，笔者简单解释一下为什么现在的Setnx默认是指set命令带上nx参数，而不是直接说是Setnx这个命令。&lt;/p&gt;
&lt;p&gt;因为Redis版本在2.6.12之前，set是不支持nx参数的，如果想要完成一个锁，那么需要两条命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. setnx Test uuid
2. expire Test 30
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;即放入Key和设置有效期，是分开的两步，理论上会出现1刚执行完，程序挂掉，无法保证原子性。&lt;/p&gt;
&lt;p&gt;但是早在2013年，也就是7年前，Redis就发布了2.6.12版本，并且官网（set命令页[1]），也早早就说明了“SETNX，SETEX，PSETEX可能在未来的版本中，会弃用并永久删除”。&lt;/p&gt;
&lt;p&gt;笔者曾阅读过一位大佬的文章，其中就有一句指导入门者的面试小套路，具体文字忘记了，大概意思如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;说到Redis锁的时候，可以先从Setnx讲起，最后慢慢引出set命令的可以加参数，可以体现出自己的知识面。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果有缘你也阅读过这篇文章，并且学到了这个套路，作为本文的笔者我要加一句提醒：&lt;/p&gt;
&lt;p&gt;请注意你的工作年限！首先回答官网表明即将废弃的命令，再引出set命令七年前的“新特性”，如果是刚毕业不久的人这么说，面试官会以为自己穿越了。&lt;/p&gt;
&lt;p&gt;你套路面试官，面试官也会套路你。——vt・沃兹基硕德&lt;/p&gt;
&lt;p&gt;Redisson&lt;/p&gt;
&lt;p&gt;Redisson是Java的Redis客户端之一，提供了一些API方便操作Redis。&lt;/p&gt;
&lt;p&gt;但是Redisson这个客户端可有点厉害，笔者在官网截了仅仅是一部分的图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2021/11/20211115214952.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;这个特性列表可以说是太多了，是不是还看到了一些JUC包下面的类名，Redisson帮我们搞了分布式的版本，比如AtomicLong，直接用RedissonAtomicLong就行了，连类名都不用去新记，很人性化了。&lt;/p&gt;
&lt;p&gt;锁只是它的冰山一角，并且从它的wiki[2]页面看到，对主从，哨兵，集群等模式都支持，当然了，单节点模式肯定是支持的。&lt;/p&gt;
&lt;p&gt;本文还是以锁为主，其他的不过多介绍。&lt;/p&gt;
&lt;p&gt;Redisson普通的锁实现源码主要是RedissonLock这个类，还没有看过它源码的盆友，不妨去瞧一瞧。&lt;/p&gt;
&lt;p&gt;源码中加锁/释放锁操作都是用Lua脚本完成的，封装的非常完善，开箱即用。&lt;/p&gt;
&lt;p&gt;这里有个小细节，加锁使用Setnx就能实现，也采用Lua脚本是不是多此一举？笔者也非常严谨的思考了一下：这么厉害的东西哪能写废代码？&lt;/p&gt;
&lt;p&gt;其实笔者仔细看了一下，加锁解锁的Lua脚本考虑的非常全面，其中就包括锁的重入性，这点可以说是考虑非常周全，我也随手写了代码测试一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2021/11/20211115215028.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;的确用起来像JDK的ReentrantLock一样丝滑，那么Redisson实现的已经这么完善，RedLock又是什么？&lt;/p&gt;
&lt;p&gt;RedLock&lt;/p&gt;
&lt;p&gt;RedLock的中文是直译过来的，就叫红锁。&lt;/p&gt;
&lt;p&gt;红锁并非是一个工具，而是Redis官方提出的一种分布式锁的算法。&lt;/p&gt;
&lt;p&gt;就在刚刚介绍完的Redisson中，就实现了redLock版本的锁。也就是说除了getLock方法，还有getRedLock方法。&lt;/p&gt;
&lt;p&gt;笔者大概画了一下对红锁的理解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2021/11/20211115215116.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果你不熟悉Redis高可用部署，那么没关系。RedLock算法虽然是需要多个实例，但是这些实例都是独自部署的，没有主从关系。&lt;/p&gt;
&lt;p&gt;RedLock作者指出，之所以要用独立的，是避免了redis异步复制造成的锁丢失，比如：主节点没来的及把刚刚set进来这条数据给从节点，就挂了。&lt;/p&gt;
&lt;p&gt;有些人是不是觉得大佬们都是杠精啊，天天就想着极端情况。其实高可用嘛，拼的就是99.999……%中小数点后面的位数。&lt;/p&gt;
&lt;p&gt;回到上面那张简陋的图片，红锁算法认为，只要(N/2) + 1个节点加锁成功，那么就认为获取了锁， 解锁时将所有实例解锁。流程为：&lt;/p&gt;
&lt;p&gt;  1.顺序向五个节点请求加锁&lt;/p&gt;
&lt;p&gt;  2.根据一定的超时时间来推断是不是跳过该节点&lt;/p&gt;
&lt;p&gt;  3.三个节点加锁成功并且花费时间小于锁的有效期&lt;/p&gt;
&lt;p&gt;  4.认定加锁成功&lt;/p&gt;
&lt;p&gt;也就是说，假设锁30秒过期，三个节点加锁花了31秒，自然是加锁失败了。&lt;/p&gt;
&lt;p&gt;这只是举个例子，实际上并不应该等每个节点那么长时间，就像官网所说的那样，假设有效期是10秒，那么单个Redis实例操作超时时间，应该在5到50毫秒（注意时间单位）。&lt;/p&gt;
&lt;p&gt;还是假设我们设置有效期是30秒，图中超时了两个Redis节点。那么加锁成功的节点总共花费了3秒，所以锁的实际有效期是小于27秒的。&lt;/p&gt;
&lt;p&gt;即扣除加锁成功三个实例的3秒，还要扣除等待超时Redis实例的总共时间。&lt;/p&gt;
&lt;p&gt;看到这，你有可能对这个算法有一些疑问，那么你不是一个人。&lt;/p&gt;
&lt;p&gt;回头看看Redis官网关于红锁的描述[3]。&lt;/p&gt;
&lt;p&gt;就在这篇描述页面的最下面，你能看到著名的关于红锁的神仙打架事件。&lt;/p&gt;
&lt;p&gt;即Martin Kleppmann和Antirez的RedLock辩论。一个是很有资历的分布式架构师，一个是Redis之父。&lt;/p&gt;
&lt;p&gt;官方挂人，最为致命。&lt;/p&gt;
&lt;p&gt;开个玩笑，要是质疑能被官方挂到官网，说明肯定是有价值的。&lt;/p&gt;
&lt;p&gt;所以说如果项目里要使用红锁，除了红锁的介绍，不妨要多看两篇文章，即：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Martin Kleppmann的质疑贴：&lt;a href=&#34;http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html&#34;&gt;http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Antirez的反击贴：&lt;a href=&#34;http://antirez.com/news/101&#34;&gt;http://antirez.com/news/101&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结&lt;/p&gt;
&lt;p&gt;看了这么多，是不是发现如何实现，都不能保证100%的稳定。&lt;/p&gt;
&lt;p&gt;程序就是这样，没有绝对的稳定，所以做好人工补偿环节也是重要的一环，毕竟：技术不够，人工来凑～&lt;/p&gt;
&lt;p&gt;相关链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://redis.io/commands/set&#34;&gt;https://redis.io/commands/set&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/redisson/redisson/wiki/Table-of-Content&#34;&gt;https://github.com/redisson/redisson/wiki/Table-of-Content&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://redis.io/topics/distlock&#34;&gt;https://redis.io/topics/distlock&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原文链接：&lt;a href=&#34;https://juejin.cn/post/6844904082860146695&#34;&gt;https://juejin.cn/post/6844904082860146695&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://erik.xyz/2021/04/07/redis-about-all/</guid>
            <title>关于redis的总结</title>
            <link>https://erik.xyz/2021/04/07/redis-about-all/</link>
            <category>redis</category>
            <category>redis总结</category>
            <category>redis命令</category>
            <pubDate>Wed, 07 Apr 2021 16:09:00 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;基础数据结构&#34;&gt;&lt;a href=&#34;#基础数据结构&#34; class=&#34;headerlink&#34; title=&#34;基础数据结构&#34;&gt;&lt;/a&gt;基础数据结构&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&#34;字符串（string）&#34;&gt;&lt;a href=&#34;#字符串（string）&#34; class=&#34;headerlink&#34; title=&#34;字符串（string）&#34;&gt;&lt;/a&gt;字符串（string）&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;字符串、整数、浮点数&lt;/li&gt;
&lt;li&gt;对整个字符串或者字符串的其中一部分执行操作，对整数和浮点数执行自增或自减操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&#34;哈希列表（hash）&#34;&gt;&lt;a href=&#34;#哈希列表（hash）&#34; class=&#34;headerlink&#34; title=&#34;哈希列表（hash）&#34;&gt;&lt;/a&gt;哈希列表（hash）&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;包含键值对的无序散列表&lt;/li&gt;
&lt;li&gt;添加、获取、移除单个键值对，获取所有键值对，检查某个键是否存在&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&#34;列表（list）&#34;&gt;&lt;a href=&#34;#列表（list）&#34; class=&#34;headerlink&#34; title=&#34;列表（list）&#34;&gt;&lt;/a&gt;列表（list）&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;链表&lt;/li&gt;
&lt;li&gt;从两端压入或者弹出元素，读取单个或者多个元素进行修剪，只保留一个范围内的元素&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&#34;集合（set）&#34;&gt;&lt;a href=&#34;#集合（set）&#34; class=&#34;headerlink&#34; title=&#34;集合（set）&#34;&gt;&lt;/a&gt;集合（set）&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;无序集合&lt;/li&gt;
&lt;li&gt;添加、获取、移除单个元素，检查一个元素是否存在与集合中，计算交集、并集、差集，从集合里面随机获取元素&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&#34;有序集合（sort-set）&#34;&gt;&lt;a href=&#34;#有序集合（sort-set）&#34; class=&#34;headerlink&#34; title=&#34;有序集合（sort set）&#34;&gt;&lt;/a&gt;有序集合（sort set）&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;有序集合&lt;/li&gt;
&lt;li&gt;添加、获取、删除元素，根据分值范围或者成员来获取元素，计算一个键的排名&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;复杂的数据结构&#34;&gt;&lt;a href=&#34;#复杂的数据结构&#34; class=&#34;headerlink&#34; title=&#34;复杂的数据结构&#34;&gt;&lt;/a&gt;复杂的数据结构&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&#34;位图（bitmaps）&#34;&gt;&lt;a href=&#34;#位图（bitmaps）&#34; class=&#34;headerlink&#34; title=&#34;位图（bitmaps）&#34;&gt;&lt;/a&gt;位图（bitmaps）&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Bitmap 在 Redis 中不是一种实际的数据类型，而是一种将 String 作为 Bitmap 使用的方法。可以理解为将 String 转换为 bit 数组。使用 Bitmap 来存储 true/false 类型的简单数据极为节省空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&#34;算法数据结构（hyperloglogs）&#34;&gt;&lt;a href=&#34;#算法数据结构（hyperloglogs）&#34; class=&#34;headerlink&#34; title=&#34;算法数据结构（hyperloglogs）&#34;&gt;&lt;/a&gt;算法数据结构（hyperloglogs）&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;HyperLogLogs 是一种主要用于数量统计的数据结构，它和 Set 类似，维护一个不可重复的 String 集合，但是 HyperLogLogs 并不维护具体的 member 内容，只维护 member 的个数。也就是说，HyperLogLogs 只能用于计算一个集合中不重复的元素数量，所以它比 Set 要节省很多内存空间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&#34;地理空间（geo）&#34;&gt;&lt;a href=&#34;#地理空间（geo）&#34; class=&#34;headerlink&#34; title=&#34;地理空间（geo）&#34;&gt;&lt;/a&gt;地理空间（geo）&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;地理空间索引半径查询&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;布隆过滤（bloomfilter）&#34;&gt;&lt;a href=&#34;#布隆过滤（bloomfilter）&#34; class=&#34;headerlink&#34; title=&#34;布隆过滤（bloomfilter）&#34;&gt;&lt;/a&gt;布隆过滤（bloomfilter）&lt;/h3&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;非分布式场景下Redis应用的备份与容灾&#34;&gt;&lt;a href=&#34;#非分布式场景下Redis应用的备份与容灾&#34; class=&#34;headerlink&#34; title=&#34;非分布式场景下Redis应用的备份与容灾&#34;&gt;&lt;/a&gt;非分布式场景下Redis应用的备份与容灾&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&#34;方案一&#34;&gt;&lt;a href=&#34;#方案一&#34; class=&#34;headerlink&#34; title=&#34;方案一&#34;&gt;&lt;/a&gt;方案一&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;一个Master节点，两个Slave节点。客户端写数据的时候是写Master节点，读的时候，是读取两个Slave，这样实现读的扩展，减轻了Master节点读负载。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;方案二&#34;&gt;&lt;a href=&#34;#方案二&#34; class=&#34;headerlink&#34; title=&#34;方案二&#34;&gt;&lt;/a&gt;方案二&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Master和Slave1使用keepalived进行VIP转移。Client连接Master的时候是通过VIP进行连接的。避免了方案一IP更改的情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&#34;Redis-Sentinel架构&#34;&gt;&lt;a href=&#34;#Redis-Sentinel架构&#34; class=&#34;headerlink&#34; title=&#34;Redis Sentinel架构&#34;&gt;&lt;/a&gt;Redis Sentinel架构&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Sentinel集群对自身和Redis主从复制进行监控。当发现Master节点出现故障时，会经过如下步骤：&lt;ul&gt;
&lt;li&gt;Sentinel之间进行选举，选举出一个leader，由选举出的leader进行failover&lt;/li&gt;
&lt;li&gt;Sentinel leader选取slave节点中的一个slave作为新的Master节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;客户端工具&#34;&gt;&lt;a href=&#34;#客户端工具&#34; class=&#34;headerlink&#34; title=&#34;客户端工具&#34;&gt;&lt;/a&gt;客户端工具&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&#34;使用socket连接redis服务器&#34;&gt;&lt;a href=&#34;#使用socket连接redis服务器&#34; class=&#34;headerlink&#34; title=&#34;使用socket连接redis服务器&#34;&gt;&lt;/a&gt;使用socket连接redis服务器&lt;/h3&gt;&lt;pre&gt;&lt;code&gt; redis-cli -s /tmp/redis.sock
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&#34;不使用socket连接redis服务器&#34;&gt;&lt;a href=&#34;#不使用socket连接redis服务器&#34; class=&#34;headerlink&#34; title=&#34;不使用socket连接redis服务器&#34;&gt;&lt;/a&gt;不使用socket连接redis服务器&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;redis-cli
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;性能测试工具&#34;&gt;&lt;a href=&#34;#性能测试工具&#34; class=&#34;headerlink&#34; title=&#34;性能测试工具&#34;&gt;&lt;/a&gt;性能测试工具&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&#34;使用默认参数测试&#34;&gt;&lt;a href=&#34;#使用默认参数测试&#34; class=&#34;headerlink&#34; title=&#34;使用默认参数测试&#34;&gt;&lt;/a&gt;使用默认参数测试&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;redis-benchmark
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;自定义参数测试&#34;&gt;&lt;a href=&#34;#自定义参数测试&#34; class=&#34;headerlink&#34; title=&#34;自定义参数测试&#34;&gt;&lt;/a&gt;自定义参数测试&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;redis-benchmark -n 1000000 --csv
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;雪球-rdr：&#34;&gt;&lt;a href=&#34;#雪球-rdr：&#34; class=&#34;headerlink&#34; title=&#34;雪球 rdr：&#34;&gt;&lt;/a&gt;雪球 rdr：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;  https://github.com/xueqiu/rdr
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;redis-rdb-tools：&#34;&gt;&lt;a href=&#34;#redis-rdb-tools：&#34; class=&#34;headerlink&#34; title=&#34;redis-rdb-tools：&#34;&gt;&lt;/a&gt;redis-rdb-tools：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;https://github.com/sripathikrishnan/redis-rdb-tools
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;工具命令&#34;&gt;&lt;a href=&#34;#工具命令&#34; class=&#34;headerlink&#34; title=&#34;工具命令&#34;&gt;&lt;/a&gt;工具命令&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&#34;指定配置文件启动服务&#34;&gt;&lt;a href=&#34;#指定配置文件启动服务&#34; class=&#34;headerlink&#34; title=&#34;指定配置文件启动服务&#34;&gt;&lt;/a&gt;指定配置文件启动服务&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;redis-server redis.conf
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;指定端口启动服务&#34;&gt;&lt;a href=&#34;#指定端口启动服务&#34; class=&#34;headerlink&#34; title=&#34;指定端口启动服务&#34;&gt;&lt;/a&gt;指定端口启动服务&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;redis-server --port 6379
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;检查修复本地数据文件工具&#34;&gt;&lt;a href=&#34;#检查修复本地数据文件工具&#34; class=&#34;headerlink&#34; title=&#34;检查修复本地数据文件工具&#34;&gt;&lt;/a&gt;检查修复本地数据文件工具&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;redis-check-dump dump.rdb
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;检查修复AOF日志文件工具&#34;&gt;&lt;a href=&#34;#检查修复AOF日志文件工具&#34; class=&#34;headerlink&#34; title=&#34;检查修复AOF日志文件工具&#34;&gt;&lt;/a&gt;检查修复AOF日志文件工具&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;redis-check-aof appendonly.aof
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;基础命令&#34;&gt;&lt;a href=&#34;#基础命令&#34; class=&#34;headerlink&#34; title=&#34;基础命令&#34;&gt;&lt;/a&gt;基础命令&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;keys&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;列出Redis所有的key&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;del&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除一个或多个key，多个key之间用空格分隔，其返回值为整数，表示成功删除了多少个存在的key，因此，如果只删除一个key，则可以从返回值中判断是否成功，如果删除多个key，则只能得到删除成功的数量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;exists&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;exists命令用于判断一个或多个key是否存在，判断多个key时，key之间用空格分隔,exists的返回值为整数，表示当前判断有多少个key是存在的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;expire/pexpire&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;expire设置key在多少秒之后过期，pexpire设置key在多少毫秒之后过期,成功返回1，失败返回0。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ttl/pttl&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ttl和pttl命令用于获取key的过期时间，其返回值为整型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;当key不存在或过期时间，返回-2。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当key存在且永久有效时，返回-1。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当key有设置过期时间时，返回为剩下的秒数(pttl为毫秒数)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;expireat/pexpireat&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置key在某个时间戳过期,expreat参数时间戳用秒表示，而pexpireat则用毫秒表示，与expire和pexpire功能类似，返回1表示成功，0表示失败。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;persist&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;移除key的过期时间，将key设置为永久有效，当key设置了过期时间，使用persist命令移除后返回1，如果key不存在或本身就是永久有效的，则返回0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;type&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判断key是什么类型的数据结构,返回值为string,list,set,hash,zset,分别表示我们前面介绍的Redis的5种基础数据结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;geo,hyperloglog,bitmaps等复杂的数据结构，都是在这五种基础数据结构上实现，比如geo是zset类型，hyperloglog和bitmaps都为string。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;auth &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Redis认证命令，执行其他命令前，必须先进行认证&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ping&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测试客户端和服务器之间的联通，返回值为PONG,表示联通&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;config get * &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获取所有配置参数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;config set config_name config_value&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置配置参数值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;info&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;返回服务器信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;select &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;切换数据库，redis默认的数据库是0-15，共16个数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;move&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将当前库的键移动到其他数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;dbsize&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获取当前库中所有键的数量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;flushdb&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除当前库中的所有key&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;flushall&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除所有库中的所有key&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;save&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建当前库的备份&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;bgsave&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同save,但是是后台备份，不阻塞主进程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;eval&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行lua脚本&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;string&#34;&gt;&lt;a href=&#34;#string&#34; class=&#34;headerlink&#34; title=&#34;string&#34;&gt;&lt;/a&gt;string&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;set&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为一个 key 设置 value，可以配合 EX/PX 参数指定 key 的有效期&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;get&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获取某个 key 对应的 value&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;getset&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为一个 key 设置 value，并返回该 key 的原 value&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;incr/decr &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自增/自减(前提是键值是整型)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;incrby/decrby &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指定步长增加减少(q前提是键值是整型)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;mset&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为多个 key 设置 value&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;msetnx&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同 MSET，如果指定的 key 中有任意一个已存在，则不进行任何操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;mget&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获取多个 key 对应的 value&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;strlen &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获取键的长度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;append &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;向指定键追加值，返回字符串长度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;setnx &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判断键是否存在，存在返回0，否则返回1，不会覆盖原来值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;getrange &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据指定下标获取键的值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;list&#34;&gt;&lt;a href=&#34;#list&#34; class=&#34;headerlink&#34; title=&#34;list&#34;&gt;&lt;/a&gt;list&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;lpush&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;向指定 List 的左侧（即头部）插入 1 个或多个元素，返回插入后的 List 长度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;rpush&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同 lpush，向指定 List 的右侧（即尾部）插入 1 或多个元素&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;lpushx/rpushx&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;与 lpush/rpush类似，区别在于，lpushx/rpushx操作的 key 如果不存在，则不会进行任何操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;lrange&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;返回指定 List 中指定范围的元素（双端包含，即 lrange key 0 10 会返回 11 个元素），时间复杂度 O(N)。应尽可能控制一次获取的元素数量，一次获取过大范围的 List 元素会导致延迟，同时对长度不可预知的 List，避免使用 lrange key 0 -1 这样的完整遍历操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;lindex&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;返回指定 List 指定 index 上的元素，如果 index 越界，返回 nil。index 数值是回环的，即 - 1 代表 List 最后一个位置，-2 代表 List 倒数第二个位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;linsert&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;向指定 List 中指定元素之前 / 之后插入一个新元素，并返回操作后的 List 长度。如果指定的元素不存在，返回 - 1。如果指定 key 不存在，不会进行任何操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;lset&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;将指定 List 指定 index 上的元素设置为 value&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 index 越界则返回错误，时间复杂度 O(N)，&lt;/li&gt;
&lt;li&gt;如果操作的是头 / 尾部的元素，则时间复杂度为 O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;lpop&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从指定 List 的左侧（即头部）移除一个元素并返回&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;rpop&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同 lpop，从指定 List 的右侧（即尾部）移除 1 个元素并返回&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;llen&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;返回指定 List 的长度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;hash&#34;&gt;&lt;a href=&#34;#hash&#34; class=&#34;headerlink&#34; title=&#34;hash&#34;&gt;&lt;/a&gt;hash&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;hset&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将 key 对应的 Hash 中的 field 设置为 value。如果该 Hash 不存在，会自动创建一个。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;hget&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;返回指定 Hash 中 field 字段的值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;hsetnx&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同 HSET，但如 field 已经存在，HSETNX 不会进行任何操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;hexists&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判断指定 Hash 中 field 是否存在，存在返回 1，不存在返回 0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;hincrby&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同 incrby命令，对指定 Hash 中的一个 field 进行 incrby&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;hmset/hmget&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同 HSET 和 HGET，可以批量操作同一个 key 下的多个 field&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;hdel&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除指定 Hash 中的 field（1 个或多个）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;hgetall&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;返回指定 Hash 中所有的 field-value 对。返回结果为数组，数组中 field 和 value 交替出现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;hkeys/hvals&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;返回指定 Hash 中所有的 field/value&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;hlen &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;返回指定hash 表中field中的数量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;set&#34;&gt;&lt;a href=&#34;#set&#34; class=&#34;headerlink&#34; title=&#34;set&#34;&gt;&lt;/a&gt;set&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;scard&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;返回指定 Set 中的 member 个数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;sismember&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判断指定的 value 是否存在于指定 Set 中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;smove&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将指定 member 从一个 Set 移至另一个 Set&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;sadd&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;向指定 Set 中添加 1 个或多个 member，如果指定 Set 不存在，会自动创建一个。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;srem&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从指定 Set 中移除 1 个或多个 member&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;srandmember&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从指定 Set 中随机返回 1 个或多个 member&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;spop&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从指定 Set 中随机移除并返回 count 个 member&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;smembers&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;返回指定 Hash 中所有的 member&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;sunion/sunionstore&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计算多个 Set 的并集并返回 / 存储至另一个 Set 中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;sinter/sinterstore&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计算多个 Set 的交集并返回 / 存储至另一个 Set 中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;sdiff/sinterstore&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计算 1 个 Set 与 1 或多个 Set 的差集并返回 / 存储至另一个 Set 中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;zset&#34;&gt;&lt;a href=&#34;#zset&#34; class=&#34;headerlink&#34; title=&#34;zset&#34;&gt;&lt;/a&gt;zset&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;zadd&lt;/li&gt;
&lt;li&gt;zrem&lt;/li&gt;
&lt;li&gt;zcard&lt;/li&gt;
&lt;li&gt;zcount&lt;/li&gt;
&lt;li&gt;zscore&lt;/li&gt;
&lt;li&gt;zrank/zrevrank&lt;/li&gt;
&lt;li&gt;zincrby&lt;/li&gt;
&lt;li&gt;zrange/zrevrange&lt;/li&gt;
&lt;li&gt;zrangebyscore/zrevragebyscore&lt;/li&gt;
&lt;li&gt;zremrangebyrank/zremrangebyscore&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;事物&#34;&gt;&lt;a href=&#34;#事物&#34; class=&#34;headerlink&#34; title=&#34;事物&#34;&gt;&lt;/a&gt;事物&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;multi &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开启一个事务&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;exec &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行事务&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;discard &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;撤销事务&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;watch &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;监视数据库键，若发生改变，返回空&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;复制&#34;&gt;&lt;a href=&#34;#复制&#34; class=&#34;headerlink&#34; title=&#34;复制&#34;&gt;&lt;/a&gt;复制&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;info replication&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获取复制信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;slaveof&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;建立复制关系&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;sync &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;订阅发布&#34;&gt;&lt;a href=&#34;#订阅发布&#34; class=&#34;headerlink&#34; title=&#34;订阅发布&#34;&gt;&lt;/a&gt;订阅发布&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;subscribe&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;订阅一个或多个频道&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;publish &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;向某一频道发送信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;性能调优&#34;&gt;&lt;a href=&#34;#性能调优&#34; class=&#34;headerlink&#34; title=&#34;性能调优&#34;&gt;&lt;/a&gt;性能调优&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&#34;避免存储-bigkey&#34;&gt;&lt;a href=&#34;#避免存储-bigkey&#34; class=&#34;headerlink&#34; title=&#34;避免存储 bigkey&#34;&gt;&lt;/a&gt;避免存储 bigkey&lt;/h3&gt;&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;使用-pipelining-将连续执行的命令组合执行&#34;&gt;&lt;a href=&#34;#使用-pipelining-将连续执行的命令组合执行&#34; class=&#34;headerlink&#34; title=&#34;使用 pipelining 将连续执行的命令组合执行&#34;&gt;&lt;/a&gt;使用 pipelining 将连续执行的命令组合执行&lt;/h3&gt;&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;操作系统的-Transparent-huge-pages-功能必须关闭&#34;&gt;&lt;a href=&#34;#操作系统的-Transparent-huge-pages-功能必须关闭&#34; class=&#34;headerlink&#34; title=&#34;操作系统的 Transparent huge pages 功能必须关闭&#34;&gt;&lt;/a&gt;操作系统的 Transparent huge pages 功能必须关闭&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;  echo never &amp;gt; /sys/kernel/mm/transparent_hugepage/enabled
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;使用物理机部署-Redis&#34;&gt;&lt;a href=&#34;#使用物理机部署-Redis&#34; class=&#34;headerlink&#34; title=&#34;使用物理机部署 Redis&#34;&gt;&lt;/a&gt;使用物理机部署 Redis&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Redis 在做数据持久化时，采用创建子进程的方式进行。&lt;br&gt;而创建子进程会调用操作系统的 fork 系统调用，这个系统调用的执行耗时，与系统环境有关。&lt;br&gt;虚拟机环境执行 fork 的耗时，要比物理机慢得多，所以你的 Redis 应该尽可能部署在物理机上&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;检查数据持久化策略&#34;&gt;&lt;a href=&#34;#检查数据持久化策略&#34; class=&#34;headerlink&#34; title=&#34;检查数据持久化策略&#34;&gt;&lt;/a&gt;检查数据持久化策略&lt;/h3&gt;&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;考虑引入读写分离机制&#34;&gt;&lt;a href=&#34;#考虑引入读写分离机制&#34; class=&#34;headerlink&#34; title=&#34;考虑引入读写分离机制&#34;&gt;&lt;/a&gt;考虑引入读写分离机制&lt;/h3&gt;&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;开启-lazy-free-机制&#34;&gt;&lt;a href=&#34;#开启-lazy-free-机制&#34; class=&#34;headerlink&#34; title=&#34;开启 lazy-free 机制&#34;&gt;&lt;/a&gt;开启 lazy-free 机制&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;如果你无法避免存储 bigkey，那么我建议你开启 Redis 的 lazy-free 机制。（4.0+版本支持）&lt;br&gt;当开启这个机制后，Redis 在删除一个 bigkey 时，释放内存的耗时操作，将会放到后台线程中去执行，这样可以在最大程度上，避免对主线程的影响&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;不使用复杂度过高的命令&#34;&gt;&lt;a href=&#34;#不使用复杂度过高的命令&#34; class=&#34;headerlink&#34; title=&#34;不使用复杂度过高的命令&#34;&gt;&lt;/a&gt;不使用复杂度过高的命令&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;避免执行例如 SORT、SINTER、SINTERSTORE、ZUNIONSTORE、ZINTERSTORE 等聚合类命令。&lt;br&gt;对于这种聚合类操作，我建议你把它放到客户端来执行，不要让 Redis 承担太多的计算工作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;执行-O-N-命令时，关注-N-的大&#34;&gt;&lt;a href=&#34;#执行-O-N-命令时，关注-N-的大&#34; class=&#34;headerlink&#34; title=&#34;执行 O(N) 命令时，关注 N 的大&#34;&gt;&lt;/a&gt;执行 O(N) 命令时，关注 N 的大&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;查询数据时，遵循原则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先查询数据元素的数量（LLEN/HLEN/SCARD/ZCARD）&lt;/li&gt;
&lt;li&gt;元素数量较少，可一次性查询全量数据&lt;/li&gt;
&lt;li&gt;元素数量非常多，分批查询数据（LRANGE/HASCAN/SSCAN/ZSCAN）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;关注-DEL-时间复杂度&#34;&gt;&lt;a href=&#34;#关注-DEL-时间复杂度&#34; class=&#34;headerlink&#34; title=&#34;关注 DEL 时间复杂度&#34;&gt;&lt;/a&gt;关注 DEL 时间复杂度&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;删除一个 key，其元素数量越多，执行 DEL 也就越慢&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;List类型：执行多次 LPOP/RPOP，直到所有元素都删除完成&lt;/li&gt;
&lt;li&gt;Hash/Set/ZSet类型：先执行 HSCAN/SSCAN/SCAN 查询元素，再执行 HDEL/SREM/ZREM 依次删除每个元素&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;批量命令代替单个命令&#34;&gt;&lt;a href=&#34;#批量命令代替单个命令&#34; class=&#34;headerlink&#34; title=&#34;批量命令代替单个命令&#34;&gt;&lt;/a&gt;批量命令代替单个命令&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;批量操作相比于多次单个操作的优势在于，可以显著减少客户端、服务端的来回网络 IO 次数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;String / Hash 使用 MGET/MSET 替代 GET/SET，HMGET/HMSET 替代 HGET/HSET&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;其它数据类型使用 Pipeline，打包一次性发送多个命令到服务端执行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;避免集中过期-key&#34;&gt;&lt;a href=&#34;#避免集中过期-key&#34; class=&#34;headerlink&#34; title=&#34;避免集中过期 key&#34;&gt;&lt;/a&gt;避免集中过期 key&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果你的业务存在大量 key 集中过期的情况，那么 Redis 在清理过期 key 时，也会有阻塞主线程的风险&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在设置过期时间时，增加一个随机时间，把这些 key 的过期时间打散，从而降低集中过期对主线程的影响&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;使用长连接操作-Redis，合理配置连接池&#34;&gt;&lt;a href=&#34;#使用长连接操作-Redis，合理配置连接池&#34; class=&#34;headerlink&#34; title=&#34;使用长连接操作 Redis，合理配置连接池&#34;&gt;&lt;/a&gt;使用长连接操作 Redis，合理配置连接池&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;你的业务应该使用长连接操作 Redis，避免短连接&lt;/li&gt;
&lt;li&gt;当使用短连接操作 Redis 时，每次都需要经过 TCP 三次握手、四次挥手，这个过程也会增加操作耗时&lt;/li&gt;
&lt;li&gt;同时，你的客户端应该使用连接池的方式访问 Redis，并设置合理的参数，长时间不操作 Redis 时，需及时释放连接资源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;只使用-db0&#34;&gt;&lt;a href=&#34;#只使用-db0&#34; class=&#34;headerlink&#34; title=&#34;只使用 db0&#34;&gt;&lt;/a&gt;只使用 db0&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在一个连接上操作多个 db 数据时，每次都需要先执行 SELECT，这会给 Redis 带来额外的压力&lt;/li&gt;
&lt;li&gt;使用多个 db 的目的是，按不同业务线存储数据，那为何不拆分多个实例存储呢？拆分多个实例部署，多个业务线不会互相影响，还能提高 Redis 的访问性能&lt;/li&gt;
&lt;li&gt;Redis Cluster 只支持 db0，如果后期你想要迁移到 Redis Cluster，迁移成本高&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;使用读写分离-分片集群&#34;&gt;&lt;a href=&#34;#使用读写分离-分片集群&#34; class=&#34;headerlink&#34; title=&#34;使用读写分离 + 分片集群&#34;&gt;&lt;/a&gt;使用读写分离 + 分片集群&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;如果你的业务读请求量很大，那么可以采用部署多个从库的方式，实现读写分离，让 Redis 的从库分担读压力，进而提升性能&lt;/li&gt;
&lt;li&gt;如果你的业务写请求量很大，单个 Redis 实例已无法支撑这么大的写流量，那么此时你需要使用分片集群，分担写压力&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&#34;不开启-AOF-或-AOF-配置为每秒刷盘&#34;&gt;&lt;a href=&#34;#不开启-AOF-或-AOF-配置为每秒刷盘&#34; class=&#34;headerlink&#34; title=&#34;不开启 AOF 或 AOF 配置为每秒刷盘&#34;&gt;&lt;/a&gt;不开启 AOF 或 AOF 配置为每秒刷盘&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;如果对于丢失数据不敏感的业务，我建议你不开启 AOF，避免 AOF 写磁盘拖慢 Redis 的性能&lt;/li&gt;
&lt;li&gt;如果确实需要开启 AOF，那么我建议你配置为 appendfsync everysec，把数据持久化的刷盘操作，放到后台线程中去执行，尽量降低 Redis 写磁盘对性能的影响&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;长耗时命令&#34;&gt;&lt;a href=&#34;#长耗时命令&#34; class=&#34;headerlink&#34; title=&#34;长耗时命令&#34;&gt;&lt;/a&gt;长耗时命令&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&#34;避免在使用这些-O-N-命令&#34;&gt;&lt;a href=&#34;#避免在使用这些-O-N-命令&#34; class=&#34;headerlink&#34; title=&#34;避免在使用这些 O(N) 命令&#34;&gt;&lt;/a&gt;避免在使用这些 O(N) 命令&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;不要把 List 当做列表使用，仅当做队列来使用&lt;/li&gt;
&lt;li&gt;通过机制严格控制 Hash、Set、Sorted Set 的大小&lt;/li&gt;
&lt;li&gt;可能的话，将排序、并集、交集等操作放在客户端执行&lt;/li&gt;
&lt;li&gt;绝对禁止使用 keys 命令&lt;/li&gt;
&lt;li&gt;避免一次性遍历集合类型的所有成员，而应使用 scan 类的命令进行分批的，游标式的遍历&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&#34;Slow-Log-功能，自动记录耗时较长的命令&#34;&gt;&lt;a href=&#34;#Slow-Log-功能，自动记录耗时较长的命令&#34; class=&#34;headerlink&#34; title=&#34;Slow Log 功能，自动记录耗时较长的命令&#34;&gt;&lt;/a&gt;Slow Log 功能，自动记录耗时较长的命令&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;slowlog-log-slower-than xxxms  #执行时间慢于xxx毫秒的命令计入  。                              Slow Logslowlog-max-len xxx  #Slow Log的长度，即最大纪录多少条Slow Log&lt;/li&gt;
&lt;li&gt;使用 slowlog get [number] 命令，可以输出最近进入 Slow Log 的 number 条命令。&lt;br&gt;使用 slowlog reset 命令，可以重置 Slow Log&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;网络引发的延迟&#34;&gt;&lt;a href=&#34;#网络引发的延迟&#34; class=&#34;headerlink&#34; title=&#34;网络引发的延迟&#34;&gt;&lt;/a&gt;网络引发的延迟&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;尽可能使用长连接或连接池，避免频繁创建销毁连接&lt;/li&gt;
&lt;li&gt;客户端进行的批量数据操作，应使用 Pipeline 特性在一次交互中完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;数据持久化引发的延迟&#34;&gt;&lt;a href=&#34;#数据持久化引发的延迟&#34; class=&#34;headerlink&#34; title=&#34;数据持久化引发的延迟&#34;&gt;&lt;/a&gt;数据持久化引发的延迟&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;要根据数据的安全级别和性能要求制定合理的持久化策略&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AOF + fsync always 的设置虽然能够绝对确保数据安全，但每个操作都会触发一次 fsync，会对 Redis 的性能有比较明显的影响&lt;/li&gt;
&lt;li&gt;AOF + fsync every second 是比较好的折中方案，每秒 fsync 一次&lt;/li&gt;
&lt;li&gt;AOF + fsync never 会提供 AOF 持久化方案下的最优性能&lt;br&gt;使用 RDB 持久化通常会提供比使用 AOF 更高的性能，但需要注意 RDB 的策略配置&lt;/li&gt;
&lt;li&gt;每一次 RDB 快照和 AOF Rewrite 都需要 Redis 主进程进行 fork 操作。fork 操作本身可能会产生较高的耗时，与 CPU 和 Redis 占用的内存大小有关。根据具体的情况合理配置 RDB 快照和 AOF Rewrite 时机，避免过于频繁的 fork 带来的延迟&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;Swap-引发的延迟&#34;&gt;&lt;a href=&#34;#Swap-引发的延迟&#34; class=&#34;headerlink&#34; title=&#34;Swap 引发的延迟&#34;&gt;&lt;/a&gt;Swap 引发的延迟&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;当 Linux 将 Redis 所用的内存分页移至 swap 空间时，将会阻塞 Redis 进程，导致 Redis 出现不正常的延迟。Swap 通常在物理内存不足或一些进程在进行大量 I/O 操作时发生，应尽可能避免上述两种情况的出现。&lt;br&gt;/proc//smaps 文件中会保存进程的 swap 记录，通过查看这个文件，能够判断 Redis 的延迟是否由 Swap 产生。如果这个文件中记录了较大的 Swap size，则说明延迟很有可能是 Swap 造成的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数据淘汰引发的延迟&lt;br&gt;当同一秒内有大量 key 过期时，也会引发 Redis 的延迟。在使用时应尽量将 key 的失效时间错开。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;主从复制与集群分片&#34;&gt;&lt;a href=&#34;#主从复制与集群分片&#34; class=&#34;headerlink&#34; title=&#34;主从复制与集群分片&#34;&gt;&lt;/a&gt;主从复制与集群分片&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&#34;主从复制&#34;&gt;&lt;a href=&#34;#主从复制&#34; class=&#34;headerlink&#34; title=&#34;主从复制&#34;&gt;&lt;/a&gt;主从复制&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Redis 支持一主多从的主从复制架构。一个 Master 实例负责处理所有的写请求，Master 将写操作同步至所有 Slave。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;借助 Redis 的主从复制，可以实现读写分离和高可用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实时性要求不是特别高的读请求，可以在 Slave 上完成，提升效率。特别是一些周期性执行的统计任务，这些任务可能需要执行一些长耗时的 Redis 命令，可以专门规划出 1 个或几个 Slave 用于服务这些统计任务&lt;/li&gt;
&lt;li&gt;借助 Redis Sentinel 可以实现高可用，当 Master crash 后，Redis Sentinel 能够自动将一个 Slave 晋升为 Master，继续提供服务&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Sentinel 做自动 failover&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Redis 的主从复制功能本身只是做数据同步，并不提供监控和自动 failover 能力，要通过主从复制功能来实现 Redis 的高可用，还需要引入一个组件：Redis Sentinel&lt;br&gt;Redis Sentinel 是 Redis 官方开发的监控组件，可以监控 Redis 实例的状态，通过 Master 节点自动发现 Slave 节点，并在监测到 Master 节点失效时选举出一个新的 Master，并向所有 Redis 实例推送新的主从配置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sentinel monitor mymaster 127.0.0.1 6379 2  #Master实例的IP、端口，以及选举需要的赞成票数&lt;/li&gt;
&lt;li&gt;sentinel down-after-milliseconds mymaster 60000  #多长时间没有响应视为Master失效&lt;/li&gt;
&lt;li&gt;sentinel failover-timeout mymaster 180000  #两次failover尝试间的间隔时长&lt;/li&gt;
&lt;li&gt;sentinel parallel-syncs mymaster 1  #如果有多个Slave，可以通过此配置指定同时从新Master进行数据同步的Slave数，避免所有Slave同时进行数据同步导致查询服务也不可用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;集群分片&#34;&gt;&lt;a href=&#34;#集群分片&#34; class=&#34;headerlink&#34; title=&#34;集群分片&#34;&gt;&lt;/a&gt;集群分片&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Redis 中存储的数据量大，一台主机的物理内存已经无法容纳&lt;/li&gt;
&lt;li&gt;Redis 的写请求并发量大，一个 Redis 实例以无法承载&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;缺点&#34;&gt;&lt;a href=&#34;#缺点&#34; class=&#34;headerlink&#34; title=&#34;缺点&#34;&gt;&lt;/a&gt;缺点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&#34;缓存和数据库双写一致性问题&#34;&gt;&lt;a href=&#34;#缓存和数据库双写一致性问题&#34; class=&#34;headerlink&#34; title=&#34;缓存和数据库双写一致性问题&#34;&gt;&lt;/a&gt;缓存和数据库双写一致性问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;降低不一致发生的概率，无法完全避免&lt;/li&gt;
&lt;li&gt;只能保证最终一致性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先，采取正确更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&#34;缓存雪崩问题&#34;&gt;&lt;a href=&#34;#缓存雪崩问题&#34; class=&#34;headerlink&#34; title=&#34;缓存雪崩问题&#34;&gt;&lt;/a&gt;缓存雪崩问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;缓存雪崩，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&#34;缓存穿透&#34;&gt;&lt;a href=&#34;#缓存穿透&#34; class=&#34;headerlink&#34; title=&#34;缓存穿透&#34;&gt;&lt;/a&gt;缓存穿透&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;缓存穿透，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;缓存击穿问题&#34;&gt;&lt;a href=&#34;#缓存击穿问题&#34; class=&#34;headerlink&#34; title=&#34;缓存击穿问题&#34;&gt;&lt;/a&gt;缓存击穿问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在第一个查询数据的请求上使用一个互斥锁来锁住它。其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;优点&#34;&gt;&lt;a href=&#34;#优点&#34; class=&#34;headerlink&#34; title=&#34;优点&#34;&gt;&lt;/a&gt;优点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&#34;纯内存操作&#34;&gt;&lt;a href=&#34;#纯内存操作&#34; class=&#34;headerlink&#34; title=&#34;纯内存操作&#34;&gt;&lt;/a&gt;纯内存操作&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Redis将所有数据放在内存中，非数据同步正常工作中，是不需要从磁盘读取数据的，0次IO。内存响应时间大约为100纳秒&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;单线程操作，避免了频繁的上下文切换&#34;&gt;&lt;a href=&#34;#单线程操作，避免了频繁的上下文切换&#34; class=&#34;headerlink&#34; title=&#34;单线程操作，避免了频繁的上下文切换&#34;&gt;&lt;/a&gt;单线程操作，避免了频繁的上下文切换&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;第一，单线程简化算法的实现，并发的数据结构实现不但困难且测试也麻烦。第二，单线程避免了线程切换以及加锁释放锁带来的消耗，对于服务端开发来说，锁和线程切换通常是性能杀手。当然了，单线程也会有它的缺点，也是Redis的噩梦：阻塞。如果执行一个命令过长，那么会造成其他命令的阻塞，对于Redis是十分致命的，所以Redis是面向快速执行场景的数据库。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;采用了非阻塞I-O多路复用机制&#34;&gt;&lt;a href=&#34;#采用了非阻塞I-O多路复用机制&#34; class=&#34;headerlink&#34; title=&#34;采用了非阻塞I/O多路复用机制&#34;&gt;&lt;/a&gt;采用了非阻塞I/O多路复用机制&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;当使用read或者write对某一文件描述符（File Descriptor FD）进行读写的时候，如果数据没有收到，那么该线程会被挂起，直到收到数据&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I/O多路复用实际上是指多个连接的管理可以在同一进程。多路是指网络连接，复用只是同一个线程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Redis使用epoll作为I/O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll的read、write、close等都转换成事件，不在网络I/O上浪费过多的时间。实现对多个FD读写的监控，提高性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;策略以及内存淘汰机制&#34;&gt;&lt;a href=&#34;#策略以及内存淘汰机制&#34; class=&#34;headerlink&#34; title=&#34;策略以及内存淘汰机制&#34;&gt;&lt;/a&gt;策略以及内存淘汰机制&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&#34;删除机制&#34;&gt;&lt;a href=&#34;#删除机制&#34; class=&#34;headerlink&#34; title=&#34;删除机制&#34;&gt;&lt;/a&gt;删除机制&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;定期删除&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;惰性删除策略&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所谓惰性策略就是在客户端访问这个 key 的时候，redis 对 key 的过期时间进行检查，如果过期了就立即删除，不会给你返回任何东西。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;内存淘汰策略&#34;&gt;&lt;a href=&#34;#内存淘汰策略&#34; class=&#34;headerlink&#34; title=&#34;内存淘汰策略&#34;&gt;&lt;/a&gt;内存淘汰策略&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;noeviction&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当内存不足以容纳新写入数据时，新写入操作会报错&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;allkeys-lru&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;allkeys-random&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当内存不足以容纳新写入数据时，在键空间中，随机移除某个key&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;volatile-lru&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。不推荐&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;volatile-random&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。不推荐&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;volatile-ttl&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。不推荐&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;持久化策略&#34;&gt;&lt;a href=&#34;#持久化策略&#34; class=&#34;headerlink&#34; title=&#34;持久化策略&#34;&gt;&lt;/a&gt;持久化策略&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;快照（RDB）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;快照是内存数据的二进制序列化形式，在存储上非常紧凑&lt;/li&gt;
&lt;li&gt;RDB是通过Redis主进程fork子进程，让子进程执行磁盘 IO 操作来进行 RDB 持久化。RDB记录的是数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;日志追加（AOF）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AOF 日志是连续的增量备份，在长期的运行过程中会变的无比庞大，数据库重启时需要加载 AOF 日志进行指令重放，这个时间就会无比漫长&lt;/li&gt;
&lt;li&gt;AOF 日志存储的是 Redis 服务器的顺序指令序列，AOF 日志只记录对内存进行修改的指令记录。AOF记录的是指令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;节省内存&#34;&gt;&lt;a href=&#34;#节省内存&#34; class=&#34;headerlink&#34; title=&#34;节省内存&#34;&gt;&lt;/a&gt;节省内存&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&#34;控制-key-的长度&#34;&gt;&lt;a href=&#34;#控制-key-的长度&#34; class=&#34;headerlink&#34; title=&#34;控制 key 的长度&#34;&gt;&lt;/a&gt;控制 key 的长度&lt;/h3&gt;&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;避免存储-bigkey-1&#34;&gt;&lt;a href=&#34;#避免存储-bigkey-1&#34; class=&#34;headerlink&#34; title=&#34;避免存储 bigkey&#34;&gt;&lt;/a&gt;避免存储 bigkey&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;String：大小控制在 10KB 以下&lt;/li&gt;
&lt;li&gt;List/Hash/Set/ZSet：元素数量控制在 1 万以下&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&#34;选择合适的数据类型&#34;&gt;&lt;a href=&#34;#选择合适的数据类型&#34; class=&#34;headerlink&#34; title=&#34;选择合适的数据类型&#34;&gt;&lt;/a&gt;选择合适的数据类型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;String、Set：尽可能存储 int 类型数据&lt;/li&gt;
&lt;li&gt;Hash、ZSet：存储的元素数量控制在转换阈值之下，以压缩列表存储，节约内存&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&#34;把-Redis-当作缓存使用&#34;&gt;&lt;a href=&#34;#把-Redis-当作缓存使用&#34; class=&#34;headerlink&#34; title=&#34;把 Redis 当作缓存使用&#34;&gt;&lt;/a&gt;把 Redis 当作缓存使用&lt;/h3&gt;&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;实例设置-maxmemory-淘汰策略&#34;&gt;&lt;a href=&#34;#实例设置-maxmemory-淘汰策略&#34; class=&#34;headerlink&#34; title=&#34;实例设置 maxmemory + 淘汰策略&#34;&gt;&lt;/a&gt;实例设置 maxmemory + 淘汰策略&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;volatile-lru / allkeys-lru：优先保留最近访问过的数据&lt;/li&gt;
&lt;li&gt;volatile-lfu / allkeys-lfu：优先保留访问次数最频繁的数据（4.0+版本支持）&lt;/li&gt;
&lt;li&gt;volatile-ttl ：优先淘汰即将过期的数据&lt;/li&gt;
&lt;li&gt;volatile-random / allkeys-random：随机淘汰数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&#34;数据压缩后写入-Redis&#34;&gt;&lt;a href=&#34;#数据压缩后写入-Redis&#34; class=&#34;headerlink&#34; title=&#34;数据压缩后写入 Redis&#34;&gt;&lt;/a&gt;数据压缩后写入 Redis&lt;/h3&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;可靠性&#34;&gt;&lt;a href=&#34;#可靠性&#34; class=&#34;headerlink&#34; title=&#34;可靠性&#34;&gt;&lt;/a&gt;可靠性&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&#34;按业务线部署实例&#34;&gt;&lt;a href=&#34;#按业务线部署实例&#34; class=&#34;headerlink&#34; title=&#34;按业务线部署实例&#34;&gt;&lt;/a&gt;按业务线部署实例&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;提升可靠性的第一步，就是「资源隔离」。&lt;br&gt;你最好按不同的业务线来部署 Redis 实例，这样当其中一个实例发生故障时，不会影响到其它业务。&lt;br&gt;这种资源隔离的方案，实施成本是最低的，但成效却是非常大的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;部署主从集群&#34;&gt;&lt;a href=&#34;#部署主从集群&#34; class=&#34;headerlink&#34; title=&#34;部署主从集群&#34;&gt;&lt;/a&gt;部署主从集群&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;如果你只使用单机版 Redis，那么就会存在机器宕机服务不可用的风险。&lt;br&gt;所以，你需要部署「多副本」实例，即主从集群，这样当主库宕机后，依旧有从库可以使用，避免了数据丢失的风险，也降低了服务不可用的时间。&lt;br&gt;在部署主从集群时，你还需要注意，主从库需要分布在不同机器上，避免交叉部署。&lt;br&gt;这么做的原因在于，通常情况下，Redis 的主库会承担所有的读写流量，所以我们一定要优先保证主库的稳定性，即使从库机器异常，也不要对主库造成影响。&lt;br&gt;而且，有时我们需要对 Redis 做日常维护，例如数据定时备份等操作，这时你就可以只在从库上进行，这只会消耗从库机器的资源，也避免了对主库的影响&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;合理配置主从复制参数&#34;&gt;&lt;a href=&#34;#合理配置主从复制参数&#34; class=&#34;headerlink&#34; title=&#34;合理配置主从复制参数&#34;&gt;&lt;/a&gt;合理配置主从复制参数&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;不合理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主从复制中断&lt;/li&gt;
&lt;li&gt;从库发起全量复制，主库性能受到影响&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;合理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置合理的 repl-backlog 参数：过小的 repl-backlog 在写流量比较大的场景下，主从复制中断会引发全量复制数据的风险&lt;/li&gt;
&lt;li&gt;设置合理的 slave client-output-buffer-limit：当从库复制发生问题时，过小的 buffer 会导致从库缓冲区溢出，从而导致复制中断&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&#34;部署哨兵集群，实现故障自动切换&#34;&gt;&lt;a href=&#34;#部署哨兵集群，实现故障自动切换&#34; class=&#34;headerlink&#34; title=&#34;部署哨兵集群，实现故障自动切换&#34;&gt;&lt;/a&gt;部署哨兵集群，实现故障自动切换&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;只部署了主从节点，但故障发生时是无法自动切换的，所以，你还需要部署哨兵集群，实现故障的「自动切换」。&lt;br&gt;而且，多个哨兵节点需要分布在不同机器上，实例为奇数个，防止哨兵选举失败，影响切换时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;日常运维&#34;&gt;&lt;a href=&#34;#日常运维&#34; class=&#34;headerlink&#34; title=&#34;日常运维&#34;&gt;&lt;/a&gt;日常运维&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&#34;禁止使用-KEYS-FLUSHALL-FLUSHDB-命令&#34;&gt;&lt;a href=&#34;#禁止使用-KEYS-FLUSHALL-FLUSHDB-命令&#34; class=&#34;headerlink&#34; title=&#34;禁止使用 KEYS/FLUSHALL/FLUSHDB 命令&#34;&gt;&lt;/a&gt;禁止使用 KEYS/FLUSHALL/FLUSHDB 命令&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;执行这些命令，会长时间阻塞 Redis 主线程，危害极大&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SCAN 替换 KEYS&lt;/li&gt;
&lt;li&gt;4.0+版本可使用 FLUSHALL/FLUSHDB ASYNC，清空数据的操作放在后台线程执行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;扫描线上实例时，设置休眠时间&#34;&gt;&lt;a href=&#34;#扫描线上实例时，设置休眠时间&#34; class=&#34;headerlink&#34; title=&#34;扫描线上实例时，设置休眠时间&#34;&gt;&lt;/a&gt;扫描线上实例时，设置休眠时间&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;不管你是使用 SCAN 扫描线上实例，还是对实例做 bigkey 统计分析，我建议你在扫描时一定记得设置休眠时间。&lt;br&gt;防止在扫描过程中，实例 OPS 过高对 Redis 产生性能抖动&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;慎用-MONITOR-命令&#34;&gt;&lt;a href=&#34;#慎用-MONITOR-命令&#34; class=&#34;headerlink&#34; title=&#34;慎用 MONITOR 命令&#34;&gt;&lt;/a&gt;慎用 MONITOR 命令&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;有时在排查 Redis 问题时，你会使用 MONITOR 查看 Redis 正在执行的命令。&lt;br&gt;但如果你的 Redis OPS 比较高，那么在执行 MONITOR 会导致 Redis 输出缓冲区的内存持续增长，这会严重消耗 Redis 的内存资源，甚至会导致实例内存超过 maxmemory，引发数据淘汰，这种情况你需要格外注意&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&#34;从库必须设置为-slave-read-only&#34;&gt;&lt;a href=&#34;#从库必须设置为-slave-read-only&#34; class=&#34;headerlink&#34; title=&#34;从库必须设置为 slave-read-only&#34;&gt;&lt;/a&gt;从库必须设置为 slave-read-only&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;你的从库必须设置为 slave-read-only 状态，避免从库写入数据，导致主从数据不一致。&lt;br&gt;除此之外，从库如果是非 read-only 状态，如果你使用的是 4.0 以下的 Redis，它存在这样的 Bug：&lt;br&gt;从库写入了有过期时间的数据，不会做定时清理和释放内存。&lt;br&gt;这会造成从库的内存泄露！这个问题直到 4.0 版本才修复，你在配置从库时需要格外注意&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;合理配置-timeout-和-tcp-keepalive-参数&#34;&gt;&lt;a href=&#34;#合理配置-timeout-和-tcp-keepalive-参数&#34; class=&#34;headerlink&#34; title=&#34;合理配置 timeout 和 tcp-keepalive 参数&#34;&gt;&lt;/a&gt;合理配置 timeout 和 tcp-keepalive 参数&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;如果因为网络原因，导致你的大量客户端连接与 Redis 意外中断，恰好你的 Redis 配置的 maxclients 参数比较小，此时有可能导致客户端无法与服务端建立新的连接（服务端认为超过了 maxclients）。&lt;br&gt;造成这个问题原因在于，客户端与服务端每建立一个连接，Redis 都会给这个客户端分配了一个 client fd。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当客户端与服务端网络发生问题时，服务端并不会立即释放这个 client fd。&lt;/p&gt;
&lt;p&gt;什么时候释放呢？&lt;/p&gt;
&lt;p&gt;Redis 内部有一个定时任务，会定时检测所有 client 的空闲时间是否超过配置的 timeout 值。&lt;br&gt;如果 Redis 没有开启 tcp-keepalive 的话，服务端直到配置的 timeout 时间后，才会清理释放这个 client fd。&lt;/p&gt;
&lt;p&gt;在没有清理之前，如果还有大量新连接进来，就有可能导致 Redis 服务端内部持有的 client fd 超过了 maxclients，这时新连接就会被拒绝。&lt;/p&gt;
&lt;p&gt;针对这种情况，我给你的优化建议是：&lt;br&gt;不要配置过高的 timeout：让服务端尽快把无效的 client fd 清理掉&lt;br&gt;Redis 开启 tcp-keepalive：这样服务端会定时给客户端发送 TCP 心跳包，检测连接连通性，当网络异常时，可以尽快清理僵尸 client fd&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;调整-maxmemory-时，注意主从库的调整顺序&#34;&gt;&lt;a href=&#34;#调整-maxmemory-时，注意主从库的调整顺序&#34; class=&#34;headerlink&#34; title=&#34;调整 maxmemory 时，注意主从库的调整顺序&#34;&gt;&lt;/a&gt;调整 maxmemory 时，注意主从库的调整顺序&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;从库内存如果超过了 maxmemory，也会触发数据淘汰。&lt;br&gt;在某些场景下，从库是可能优先主库达到 maxmemory 的（例如在从库执行 MONITOR 命令，输出缓冲区占用大量内存），那么此时从库开始淘汰数据，主从库就会产生不一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要想避免此问题，在调整 maxmemory 时，一定要注意主从库的修改顺序：&lt;/p&gt;
&lt;p&gt;调大 maxmemory：先修改从库，再修改主库&lt;/p&gt;
&lt;p&gt;调小 maxmemory：先修改主库，再修改从库&lt;/p&gt;
&lt;p&gt;直到 Redis 5.0，Redis 才增加了一个配置 replica-ignore-maxmemory，默认从库超过 maxmemory 不会淘汰数据，才解决了此问题&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;预防-Redis-问题&#34;&gt;&lt;a href=&#34;#预防-Redis-问题&#34; class=&#34;headerlink&#34; title=&#34;预防 Redis 问题&#34;&gt;&lt;/a&gt;预防 Redis 问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&#34;合理的资源规划&#34;&gt;&lt;a href=&#34;#合理的资源规划&#34; class=&#34;headerlink&#34; title=&#34;合理的资源规划&#34;&gt;&lt;/a&gt;合理的资源规划&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;保证机器有足够的 CPU、内存、带宽、磁盘资源&lt;/li&gt;
&lt;li&gt;提前做好容量规划，主库机器预留一半内存资源，防止主从机器网络故障，引发大面积全量同步，导致主库机器内存不足的问题&lt;/li&gt;
&lt;li&gt;单个实例内存建议控制在 10G 以下，大实例在主从全量同步、RDB 备份时有阻塞风险&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&#34;完善的监控预警&#34;&gt;&lt;a href=&#34;#完善的监控预警&#34; class=&#34;headerlink&#34; title=&#34;完善的监控预警&#34;&gt;&lt;/a&gt;完善的监控预警&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;做好机器 CPU、内存、带宽、磁盘监控，资源不足时及时报警，任意资源不足都会影响 Redis 性能&lt;/li&gt;
&lt;li&gt;设置合理的 slowlog 阈值，并对其进行监控，slowlog 过多及时报警&lt;/li&gt;
&lt;li&gt;监控组件采集 Redis INFO 信息时，采用长连接，避免频繁的短连接&lt;/li&gt;
&lt;li&gt;做好实例运行时监控，重点关注 expired_keys、evicted_keys、latest_fork_usec 指标，这些指标短时突增可能会有阻塞风险&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上命令，应尽量避免传递 [0 -1] 或 [-inf +inf] 这样的参数，来对 Sorted Set 做一次性的完整遍历，特别是在 Sorted Set 的尺寸不可预知的情况下。可以通过 ZSCAN 命令来进行游标式的遍历，或通过 LIMIT 参数来限制返回 member 的数量（适用于 ZRANGEBYSCORE 和 ZREVRANGEBYSCORE 命令），以实现游标式的遍历&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 时间复杂度为O(N)，N随着redis中key的数量增加而增加，因此redis有大量的key,keys命令会执行很长时间，而由于Redis是单线程，某个命令耗费过长时间，则会导致后面的的所有请求无法得到响应&lt;/p&gt;
&lt;p&gt; &lt;img src=&#34;/img/202104/redis.svg&#34; alt=&#34;reids总结图&#34;&gt;&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>