{
    "version": "https://jsonfeed.org/version/1",
    "title": "艾瑞可erik • All posts by \"web\" categories",
    "description": "一只PHP开发的程序猿，偶尔做做运维、Goland、Python、Java、摄影、画画、写作、顺便睡觉，反正整站都搞过。",
    "home_page_url": "https://erik.xyz",
    "items": [
        {
            "id": "https://erik.xyz/2024/06/12/loading-zero-copy/",
            "url": "https://erik.xyz/2024/06/12/loading-zero-copy/",
            "title": "使用懒加载 + 零拷贝后，程序的秒开率提升至99.99%",
            "date_published": "2024-06-12T02:00:56.000Z",
            "content_html": "<h4 id=\"一、5秒钟加载一个页面的真相\"><a href=\"#一、5秒钟加载一个页面的真相\" class=\"headerlink\" title=\"一、5秒钟加载一个页面的真相\"></a>一、5秒钟加载一个页面的真相</h4><p>今天在修改前端页面的时候，发现程序中有一个页面的加载速度很慢，差不多需要5秒，这其实是难以接受的，我也不知道为什么上线这么长时间了，没人提过这个事儿。</p>\n<p>我记得有一个词儿，叫秒开率。<br><span id=\"more\"></span><br>秒开率是指能够在1秒内完成页面的加载。<br><img src=\"/img/2024/20240501.webp\" alt=\"erik.xyz\"></p>\n<p>查询的时候，会访问后台数据库，查询前20条数据，按道理来说，这应该很快才对。追踪代码，看看啥问题，最后发现问题有三：</p>\n<p>1.表中有一个BLOB大字段，存储着一个PDF模板，也就是上图中的运费模板；</p>\n<p>2.查询后会将这个PDF模板存储到本地磁盘点</p>\n<p>3.击线上显示，会读取本地的PDF模板，通过socket传到服务器。</p>\n<h5 id=\"大字段批量查询、批量文件落地、读取大文件并进行网络传输，不慢才怪，这一顿骚操作，5秒能加载完毕，已经烧高香了。\"><a href=\"#大字段批量查询、批量文件落地、读取大文件并进行网络传输，不慢才怪，这一顿骚操作，5秒能加载完毕，已经烧高香了。\" class=\"headerlink\" title=\"大字段批量查询、批量文件落地、读取大文件并进行网络传输，不慢才怪，这一顿骚操作，5秒能加载完毕，已经烧高香了。\"></a>大字段批量查询、批量文件落地、读取大文件并进行网络传输，不慢才怪，这一顿骚操作，5秒能加载完毕，已经烧高香了。</h5><p><img src=\"/img/2024/20240502.webp\" alt=\"erik.xyz\"></p>\n<h4 id=\"二、优化四步走\"><a href=\"#二、优化四步走\" class=\"headerlink\" title=\"二、优化四步走\"></a>二、优化四步走</h4><h5 id=\"1、“懒加载”\"><a href=\"#1、“懒加载”\" class=\"headerlink\" title=\"1、“懒加载”\"></a>1、“懒加载”</h5><p>经过调查发现，这个PDF模板只有在点击运费模板按钮时才会使用。</p>\n<ul>\n<li>优化1： 在点查询按钮时，不查询PDF模板；</li>\n<li>优化2： 点击运费模板时，根据uuid去查询，这样既能触发索引，也不用按时间排序，只是查询单条，速度快了很多很多，我愿称你为“懒加载”。</li>\n<li>优化3： 通过异步，将文件保存到磁盘中。</li>\n</ul>\n<p><img src=\"/img/2024/20240503.webp\" alt=\"erik.xyz\"></p>\n<p><strong>2、线上显示 = 就读取一个文件，为什么会慢呢？</strong></p>\n<p>打开代码一看，居然是通过FileReader读取的，我了个乖乖~这有什么问题吗？</p>\n<p>都是从百度拷贝过来的，百度还会有错吗？而且也测试了，没问题啊。</p>\n<p>嗯，对，是没问题，是可以实现需求，可是，为什么用这个？不知道。更别说效率问题了~</p>\n<p>优化4：通过缓冲流读取文件</p>\n<p><img src=\"/img/2024/20240504.webp\" alt=\"erik.xyz\"></p>\n<h4 id=\"三、先从上帝视角，了解一下啥子是IO流\"><a href=\"#三、先从上帝视角，了解一下啥子是IO流\" class=\"headerlink\" title=\"三、先从上帝视角，了解一下啥子是IO流\"></a>三、先从上帝视角，了解一下啥子是IO流</h4><p>Java I/O (Input/Output) 是对传统 I/O 操作的封装，它是以流的形式来操作数据的。</p>\n<p>1.InputStream代表一个输入流，它是一个抽象类，不能被实例化。InputStream定义了一些通用方法，如read()和skip()等，用于从输入流中读取数据；</p>\n<p>2.OutputStream代表一个输出流，它也是一个抽象类，不能被实例化。OutputStream定义了一些通用方法，如write()和flush()等，用于向输出流中写入数据；</p>\n<p>3.除了字节流，Java还提供字符流，字符流类似于字节流，不同之处在于字符流是按字符读写数据，而不是按字节。Java中最基本的字符流是Reader和Writer，它们是基于InputStream和OutputStream的转换类，用于完成字节流与字符流之间的转换。</p>\n<p>4.BufferedInputStream和BufferedOutputStream是I/O包中提供的缓冲输入输出流。它们可以提高I/O操作的效率，具有较好的缓存机制，能够减少磁盘操作，缩短文件传输时间。使用BufferedInputStream和 BufferedOutputStream进行读取和写入时，Java会自动调整缓冲区的大小，使其能够适应不同的数据传输速度。</p>\n<p>5.可以读取或写入 Java对象的流，比较典型的对象流包括ObjectInputStream 和ObjectOutputStream，将Java对象转换为字节流进行传输或存储；<br><img src=\"/img/2024/20240505.webp\" alt=\"erik.xyz\"></p>\n<p>在上一篇<a href=\"2024/05/06/index-asynchrony-landing/\">《增加索引+异步+不落地后，从12h优化到15min》</a>中，提到了4种优化方式，数据库优化、复用优化、并行优化、算法优化。</p>\n<p><strong>其中Buffered缓冲流就属于复用优化的一种，这个页面的查询完全可以通过复用优化优化一下。</strong></p>\n<h4 id=\"四、写个栗子，测试一下\"><a href=\"#四、写个栗子，测试一下\" class=\"headerlink\" title=\"四、写个栗子，测试一下\"></a>四、写个栗子，测试一下</h4><p><strong>1、通过字符输入流FileReader读取</strong></p>\n<p>FileReader连readLine()方法都没有，我也是醉了~</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static int readFileByReader(String filePath) &#123;</span><br><span class=\"line\">    int result = 0;</span><br><span class=\"line\">    try (Reader reader = new FileReader(filePath)) &#123;</span><br><span class=\"line\">        int value;</span><br><span class=\"line\">        while ((value = reader.read()) != -1) &#123;</span><br><span class=\"line\">            result += value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; catch (Exception e) &#123;</span><br><span class=\"line\">        System.out.println(&quot;readFileByReader异常：&quot; + e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>2、通过缓冲流BufferedReader读取</strong><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static String readFileByBuffer(String filePath) &#123;</span><br><span class=\"line\">    StringBuilder builder = new StringBuilder();</span><br><span class=\"line\">    try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) &#123;</span><br><span class=\"line\">        String data = null;</span><br><span class=\"line\">        while ((data = reader.readLine())!= null)&#123;</span><br><span class=\"line\">            builder.append(data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;catch (Exception e) &#123;</span><br><span class=\"line\">        System.out.println(&quot;readFileByReader异常：&quot; + e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return builder+&quot;&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>通过循环模拟了150000个文件进行测试，FileReader耗时8136毫秒，BufferedReader耗时6718毫秒，差不多相差1秒半的时间，差距还是相当大的，俗话说得好，水滴石穿。</p>\n<p>同样是read方法，只不过是包了一层，有啥不同呢？</p>\n<p>BufferedReader 是一个缓冲字符输入流，可以对 FileRead 进行包装，提供了一个缓存数组，将数据按照一定规则读取到缓存区中，输入流每次读取文件数据时都需要将数据进行字符编码，而 BufferedReader 的出现，降低了输入流访问数据源的次数，将一定大小的数据一次读取到缓存区并进行字符编码，从而提高 IO 的效率。</p>\n<p>如果没有缓冲，每次调用 read() 或 readLine() 都可能导致从文件中读取字节，转换为字符，然后返回，这可能非常低效。</p>\n<p><strong>就像取快递一样，在取快递的时候，肯定是想一次性的取完，避免再来一趟。</strong></p>\n<ul>\n<li><p>FileReader就相当于一件一件的取，乐此不疲；</p>\n</li>\n<li><p>BufferedReader就相当于，你尽可能多的拿你的快递，可是这也有个极限，比如你一次只能拿5件快递，这个 5 就相当于缓冲区，效率上，提升数倍。</p>\n</li>\n</ul>\n<p>对 FileRead 进行包装变成了BufferedReader缓冲字符输入流，其实，Java IO流就是最典型的装饰器模式，装饰器模式通过组合替代继承的方式在不改变原始类的情况下添加增强功能，主要解决继承关系过于复杂的问题，之前整理过一篇装饰器模式，这里就不论述了。</p>\n<p><strong>3、再点进源码瞧瞧。</strong></p>\n<p><strong>（1）FileReader.read()源码很简单，就是直接读取</strong><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public int read(char cbuf[], int off, int len) throws IOException &#123;</span><br><span class=\"line\">   return in.read(cbuf, off, len);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>（2）BufferedReader.read()的源码就较为复杂了，看一下它的核心方法</strong><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fill()private void fill() throws IOException &#123;</span><br><span class=\"line\">   int dst;</span><br><span class=\"line\">    if (markedChar &lt;= UNMARKED) &#123;</span><br><span class=\"line\">        /* No mark */</span><br><span class=\"line\">        dst = 0;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        /* Marked */</span><br><span class=\"line\">        int delta = nextChar - markedChar;</span><br><span class=\"line\">        if (delta &gt;= readAheadLimit) &#123;</span><br><span class=\"line\">            /* Gone past read-ahead limit: Invalidate mark */</span><br><span class=\"line\">            markedChar = INVALIDATED;</span><br><span class=\"line\">            readAheadLimit = 0;</span><br><span class=\"line\">            dst = 0;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            if (readAheadLimit &lt;= cb.length) &#123;</span><br><span class=\"line\">                /* Shuffle in the current buffer */</span><br><span class=\"line\">                System.arraycopy(cb, markedChar, cb, 0, delta);</span><br><span class=\"line\">                markedChar = 0;</span><br><span class=\"line\">                dst = delta;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                /* Reallocate buffer to accommodate read-ahead limit */</span><br><span class=\"line\">                char ncb[] = new char[readAheadLimit];</span><br><span class=\"line\">                System.arraycopy(cb, markedChar, ncb, 0, delta);</span><br><span class=\"line\">                cb = ncb;</span><br><span class=\"line\">                markedChar = 0;</span><br><span class=\"line\">                dst = delta;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            nextChar = nChars = delta;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    int n;</span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\">        n = in.read(cb, dst, cb.length - dst);</span><br><span class=\"line\">    &#125; while (n == 0);</span><br><span class=\"line\">    if (n &gt; 0) &#123;</span><br><span class=\"line\">        nChars = dst + n;</span><br><span class=\"line\">        nextChar = dst;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><strong>核心方法fill()：</strong></p>\n<p>1.字符缓冲输入流，底层有一个8192个元素的缓冲字符数组，当缓冲区的内容读完时，将使用 fill() 方法从硬盘中读取数据填充缓冲数组；</p>\n<p>2.字符缓冲输出流，底层有一个8192个元素的缓冲字符数组，使用flush方法将缓冲数组中的内容写入到硬盘当中；</p>\n<p>3.使用缓冲数组之后，程序在运行的大部分时间内都是内存和内存直接的数据交互过程。内存直接的操作效率是比较高的。并且降低了CPU通过内存操作硬盘的次数；</p>\n<p>4.关闭字符缓冲流，都会首先释放对应的缓冲数组空间，并且关闭创建对应的字符输入流和字符输出流。</p>\n<p>既然缓冲这么好用，为啥jdk将缓冲字符数组设置的这么小，才8192个字节？这是一个比较折中的方案，如果缓冲区太大的话，就会增加单次读写的时间，同样内存的大小也是有限制的，不可能都让你来干这个一件事。</p>\n<p>很多小伙伴也肯定用过它的read(char[] cbuf)，它内部维护了一个char数组，每次写/读数据时，操作的是数组，这样可以减少IO次数。<br><img src=\"/img/2024/20240506.webp\" alt=\"erik.xyz\"></p>\n<p><strong>（3）buffer四大属性</strong></p>\n<p>1.mark：标记</p>\n<p>2.position：位置，下一个要被读或写的元素的索引， 每次读写缓冲区数据时都会改变改值， 为下次读写作准备</p>\n<p>3.limit：表示缓冲区的当前终点，不能对缓冲区 超过极限的位置进行读写操作。且极限 是可以修改的</p>\n<p>4.capacity：容量，即可以容纳的最大数据量；在缓 冲区创建时被设定并且不能改变。</p>\n<p><strong>4、缓冲流：4次上下文切换+4次拷贝</strong></p>\n<p>传统IO执行的话需要4次上下文切换（用户态-&gt;内核态-&gt;用户态-&gt;内核态-&gt;用户态）和4次拷贝。</p>\n<p>1.磁盘文件DMA拷贝到内核缓冲区</p>\n<p>2.内核缓冲区CPU拷贝到用户缓冲区</p>\n<p>3.用户缓冲区CPU拷贝到Socket缓冲区</p>\n<p>4.Socket缓冲区DMA拷贝到协议引擎。<br><img src=\"/img/2024/20240508.webp\" alt=\"erik.xyz\"></p>\n<h4 id=\"五、NIO之FileChannel\"><a href=\"#五、NIO之FileChannel\" class=\"headerlink\" title=\"五、NIO之FileChannel\"></a>五、NIO之FileChannel</h4><p>NIO中比较常用的是FileChannel，主要用来对本地文件进行 IO 操作。</p>\n<p><strong>1、FileChannel 常见的方法有</strong></p>\n<p>1.read，从通道读取数据并放到缓冲区中；</p>\n<p>2.write，把缓冲区的数据写到通道中；</p>\n<p>3.transferFrom，从目标通道 中复制数据到当前通道；</p>\n<p>4,transferTo，把数据从当 前通道复制给目标通道。</p>\n<p><strong>2、关于Buffer 和 Channel的注意事项和细节</strong></p>\n<p>1.ByteBuffer支持类型化的put和get, put放入的是什么数据类型，get就应该使用 相应的数据类型来取出，否则可能有 BufferUnderflowException 异常；</p>\n<p>2.可以将一个普通Buffer 转成只读Buffer；</p>\n<p>3.NIO 还提供了 MappedByteBuffer， 可以让文件直接在内存（堆外的内存）中进 行修改， 而如何同步到文件由NIO 来完成；</p>\n<p>4.NIO 还支持 通过多个 Buffer (即 Buffer 数组) 完成读写操作，即 Scattering 和 Gathering。</p>\n<p><strong>3、Selector(选择器)</strong></p>\n<p>1.Java的NIO，用非阻塞的IO方式。可以用一个线程，处理多个的客户端连 接，就会使用到Selector(选择器)；</p>\n<p>2.Selector 能够检测多个注册的通道上是否有事件发生，如果有事件发生，便获取事件然 后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个 通道，也就是管理多个连接和请求。</p>\n<p>3.只有在 连接/通道 真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程。</p>\n<p>4,避免了多线程之间的上下文切换导致的开销。</p>\n<p><strong>4、selector的相关方法</strong></p>\n<p>1.open();//得到一个选择器对象</p>\n<p>2.select(long timeout);//监控所有注册的通道，当其中有IO操作可以进行时，将 对应的SelectionKey加入到内部集合中并返回，参数用来设置超时时间</p>\n<p>3.selectedKeys();//从内部集合中得到所有的SelectionKey。</p>\n<h4 id=\"六、内存映射技术mmap\"><a href=\"#六、内存映射技术mmap\" class=\"headerlink\" title=\"六、内存映射技术mmap\"></a>六、内存映射技术mmap</h4><p><strong>1、文件映射</strong></p>\n<p>传统的文件I/O操作可能会变得很慢，这时候mmap就闪亮登场了。</p>\n<p><strong>mmap（Memory-mapped files）是一种在内存中创建映射文件的机制，它可以使我们像访问内存一样访问文件，从而避免频繁的文件I/O操作。</strong></p>\n<p>使用mmap的方式是在内存中创建一个虚拟地址，然后将文件映射到这个虚拟地址上，这个映射的过程是由操作系统完成的。</p>\n<p>实现映射后，进程就可以采用指针的方式读写操作这一段内存，系统会自动回写到对应的文件磁盘上，这样就完成了对文件的读取操作，而不用调用 read、write 等系统函数。</p>\n<p>内核空间对这段区域的修改也会直接反映用户空间，从而可以实现不同进程间的文件共享。<br><img src=\"/img/2024/20240509.webp\" alt=\"erik.xyz\"></p>\n<p><strong>2、Java中使用mmap</strong></p>\n<p>在Java中，mmap技术主要使用了JavaNIO（New IO）库中的FileChannel 类，它提供了一种将文件映射到内存的方法，称为MappedByteBuffer。MappedByteBuffe是ByteBuffer的一个子类，它扩展了ByteBuffer的功能，可以直接将文件映射到内存中。</p>\n<p>根据文件地址创建了一层缓存当作索引，放在虚拟内存中，使用时会根据的地址，直接找到磁盘中文件的位置，把数据分段load到系统内存(pagecache)中。<br><img src=\"/img/2024/20240510.webp\" alt=\"erik.xyz\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static String readFileByMmap(String filePath) &#123;</span><br><span class=\"line\">    File file = new File(filePath);</span><br><span class=\"line\">    String ret = &quot;&quot;;</span><br><span class=\"line\">    StringBuilder builder = new StringBuilder();</span><br><span class=\"line\">    try (FileChannel channel = new RandomAccessFile(file, &quot;r&quot;).getChannel()) &#123;</span><br><span class=\"line\">        long size = channel.size();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建一个与文件大小相同的字节数组</span><br><span class=\"line\">        ByteBuffer buffer = ByteBuffer.allocate((int) size);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 将通道上的所有数据都读入到buffer中</span><br><span class=\"line\">        while (channel.read(buffer) != -1) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 切换为只读模式</span><br><span class=\"line\">        buffer.flip();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 从buffer中获取数据并处理</span><br><span class=\"line\">        byte[] data = new byte[buffer.remaining()];</span><br><span class=\"line\">        buffer.get(data);</span><br><span class=\"line\"></span><br><span class=\"line\">        ret = new String(data);</span><br><span class=\"line\">    &#125; catch (IOException e) &#123;</span><br><span class=\"line\">        System.out.println(&quot;readFileByMmap异常：&quot; + e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>3、内存映射技术mmap：4次上下文切换+3次拷贝</strong></p>\n<p><strong>mmap是一种内存映射技术，mmap相比于传统的缓冲流来说，其实就是少了1次CPU 拷贝，变成了数据共享。</strong></p>\n<p>虽然减少了一次拷贝，但是上下文切换的次数还是没变。</p>\n<p>因为存在一次CPU拷贝，因此mmap并不是严格意义上的零拷贝。</p>\n<p>RocketMQ 中就是使用的 mmap 来提升磁盘文件的读写性能。<br><img src=\"/img/2024/20240511.webp\" alt=\"erik.xyz\"></p>\n<h4 id=\"七、sendFile零拷贝\"><a href=\"#七、sendFile零拷贝\" class=\"headerlink\" title=\"七、sendFile零拷贝\"></a>七、sendFile零拷贝</h4><p>零拷贝将上下文切换和拷贝的次数压缩到了极致。</p>\n<p><strong>1、传统IO流</strong></p>\n<p>1.将磁盘中的文件拷贝到内核空间内存；</p>\n<p>2.将内核空间的内容拷贝到用户空间内存；</p>\n<p>3.用户空间将内容写入到内核空间内存；</p>\n<p>4.socket读取内核空间内存，将内容发送给第三方服务器。<br><img src=\"/img/2024/20240512.webp\" alt=\"erik.xyz\"></p>\n<p><strong>2、sendFile零拷贝</strong></p>\n<p>在内核的支持下，零拷贝少了一个步骤，那就是内核缓存向用户空间的拷贝，这样既节省了内存，也节省了 CPU 的调度时间，让效率更高。<br><img src=\"/img/2024/20240513.webp\" alt=\"erik.xyz\"></p>\n<p><strong>3、sendFile零拷贝：2 次上下文切换 + 2次拷贝</strong></p>\n<p><strong>直接将用户缓冲区干掉，而且没有CPU拷贝，故得名零拷贝。</strong><br><img src=\"/img/2024/20240514.webp\" alt=\"erik.xyz\"></p>\n<p><strong>重置优化4：通过零拷贝读取文件</strong><br><img src=\"/img/2024/20240515.webp\" alt=\"erik.xyz\"></p>\n<h4 id=\"八、总结经过\"><a href=\"#八、总结经过\" class=\"headerlink\" title=\"八、总结经过\"></a>八、总结经过</h4><p><strong>4次优化，将页面的加载时间控制在了1秒以内，实打实的提升了程序的秒开率。</strong></p>\n<p>1.批量查询时，不查询BLOB大字段；</p>\n<p>2.点击运费查询时，单独查询+触发索引，实现“懒加载”；</p>\n<p>3.异步存储文件</p>\n<p>4.通过缓冲流-&gt;内存映射技术mmap-&gt; sendFile零拷贝读取本地文件；</p>\n<p><strong>通过一次页面优化，收获颇丰：</strong></p>\n<p>1.通过业务优化，将BLOB大字段进行“懒加载”；</p>\n<p>2.异步存储文件；</p>\n<p>3.系统的学习了Java IO流，输入输出流、字符流、字符流、转换流；</p>\n<p>4.通过NIO的FileChannel读取文件时，较于缓冲流性能上显著提升；</p>\n<p>5.内存映射技术mmap 相比于传统的 缓冲流 来说，其实就是少了1次内核缓冲区到用户缓冲区的CPU拷贝，将其变成了数据共享；</p>\n<p>6.sendFile零拷贝，舍弃了用户空间内存，舍弃了CUP拷贝，完美的零拷贝方案。</p>\n<p>7.通过代码实例，横向对比了FileReader、BufferedReader、NIO之FileChannel、内存映射技术mmap、sendFile零拷贝之间的性能差距；</p>\n<p>转载自：<a href=\"https://mp.weixin.qq.com/s/kaogMK5qz5vkfs9-BYu0Mg\">哪吒编程</a></p>\n",
            "tags": [
                "web",
                "web前端",
                "web优化"
            ]
        },
        {
            "id": "https://erik.xyz/2024/05/06/index-asynchrony-landing/",
            "url": "https://erik.xyz/2024/05/06/index-asynchrony-landing/",
            "title": "增加索引 + 异步 + 不落地后，从 12h 优化到 15 min",
            "date_published": "2024-05-06T03:44:00.000Z",
            "content_html": "<p>在开发中，我们经常会遇到这样的需求，将数据库中的图片导出到本地，再传给别人。</p>\n<h4 id=\"一、一般我会这样做：\"><a href=\"#一、一般我会这样做：\" class=\"headerlink\" title=\"一、一般我会这样做：\"></a>一、一般我会这样做：</h4><p>1.通过接口或者定时任务的形式</p>\n<p>2.读取Oracle或者MySQL数据库</p>\n<p>3.通过FileOutputStream将Base64解密后的byte[]存储到本地</p>\n<p>4.遍历本地文件夹，将图片通过FTP上传到第三方服务器<br><span id=\"more\"></span><br><img src=\"/img/2024/202405100.webp\" alt=\"erik.xyz\"></p>\n<p>现场炸锅了！</p>\n<p>实际的数据量非常大，据统计差不多有400G的图片需要导出。</p>\n<p><strong>现场人员的反馈是，已经跑了12个小时了，还在继续，不知道啥时候能导完。</strong></p>\n<p>停下来呢？之前的白导了，不停呢？不知道要等到啥时候才能导完。</p>\n<p>这不行啊，速度太慢了，一个简单的任务，不能被这东西耗死吧？<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Value(&quot;$&#123;months&#125;&quot;)</span><br><span class=\"line\">private String months;</span><br><span class=\"line\"></span><br><span class=\"line\">@Value(&quot;$&#123;imgDir&#125;&quot;)</span><br><span class=\"line\">private String imgDir;</span><br><span class=\"line\"></span><br><span class=\"line\">@Resource</span><br><span class=\"line\">private UserDao userDao;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">public void getUserInfoImg() &#123;</span><br><span class=\"line\"> try &#123;</span><br><span class=\"line\">  // 获取需要导出的月表</span><br><span class=\"line\">  String[] monthArr = months.split(&quot;,&quot;);</span><br><span class=\"line\">  for (int i = 0; i &lt; monthArr.length; i++) &#123;</span><br><span class=\"line\">   // 获取月表中的图片</span><br><span class=\"line\">   Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class=\"line\">   String tableName = &quot;USER_INFO_&quot; + monthArr[i];</span><br><span class=\"line\">   map.put(&quot;tableName&quot;, tableName);</span><br><span class=\"line\">   map.put(&quot;status&quot;, 1);</span><br><span class=\"line\">   </span><br><span class=\"line\">   List&lt;UserInfo&gt; userInfoList = userDao.getUserInfoImg(map);</span><br><span class=\"line\">   if (userInfoList == null || userInfoList.size() == 0) &#123;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   for (int j = 0; j &lt; userInfoList.size(); j++) &#123;</span><br><span class=\"line\">    UserInfo user = userInfoList.get(j);</span><br><span class=\"line\">    String userId = user.getUserId();</span><br><span class=\"line\">    String userName = user.getUserName();</span><br><span class=\"line\">    byte[] content = user.getImgContent;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 下载图片到本地</span><br><span class=\"line\">    FileUtil.dowmloadImage(imgDir + userId+&quot;-&quot;+userName+&quot;.png&quot;, content);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 将下载好的图片，通过FTP上传给第三方</span><br><span class=\"line\">    FileUtil.uploadByFtp(imgDir);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125; catch (Exception e) &#123;</span><br><span class=\"line\">  serviceLogger.error(&quot;获取图片异常：&quot;, e);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"二、谁写的？赶紧加班优化，会追责吗？\"><a href=\"#二、谁写的？赶紧加班优化，会追责吗？\" class=\"headerlink\" title=\"二、谁写的？赶紧加班优化，会追责吗？\"></a>二、谁写的？赶紧加班优化，会追责吗？</h4><p>经过1小时的深思熟虑，慢的原因可能有以下几点：</p>\n<p>1.查询数据库</p>\n<p>2.程序串行</p>\n<p>3.base64解密</p>\n<p>4.图片落地</p>\n<p>5.FTP上传到服务器</p>\n<p>优化1：数据库中添加对应的索引，提高查询速度</p>\n<p>优化2：采用增加索引+异步+多线程的方式进行导出</p>\n<p><img src=\"/img/2024/202405101.webp\" alt=\"erik.xyz\"></p>\n<p>优化3：不解密+图片不落地，直接通过FTP传给第三方</p>\n<p><img src=\"/img/2024/202405102.webp\" alt=\"erik.xyz\"></p>\n<p><strong>使用索引+异步+不解密+不落地 后，40G图片的导出上传，从12+小时 优化到15 分钟，你敢信？</strong></p>\n<p>差不多的代码，效率差距竟如此之大。</p>\n<p>下面贴出导出图片不落地的关键代码。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Resource</span><br><span class=\"line\">private UserAsyncService userAsyncService;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">public void getUserInfoImg() &#123;</span><br><span class=\"line\"> try &#123;</span><br><span class=\"line\">  // 获取需要导出的月表</span><br><span class=\"line\">  String[] monthArr = months.split(&quot;,&quot;);</span><br><span class=\"line\">  for (int i = 0; i &lt; monthArr.length; i++) &#123;</span><br><span class=\"line\">   userAsyncService.getUserInfoImgAsync(monthArr[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125; catch (Exception e) &#123;</span><br><span class=\"line\">  serviceLogger.error(&quot;获取图片异常：&quot;, e);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Value(&quot;$&#123;months&#125;&quot;)</span><br><span class=\"line\">private String months;</span><br><span class=\"line\"></span><br><span class=\"line\">@Resource</span><br><span class=\"line\">private UserDao userDao;</span><br><span class=\"line\"></span><br><span class=\"line\">@Async(&quot;async-executor&quot;)</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public void getUserInfoImgAsync(String month) &#123;</span><br><span class=\"line\"> try &#123;</span><br><span class=\"line\">  // 获取月表中的图片</span><br><span class=\"line\">  Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class=\"line\">  String tableName = &quot;USER_INFO_&quot; + month;</span><br><span class=\"line\">  map.put(&quot;tableName&quot;, tableName);</span><br><span class=\"line\">  map.put(&quot;status&quot;, 1);</span><br><span class=\"line\">  </span><br><span class=\"line\">  List&lt;UserInfo&gt; userInfoList = userDao.getUserInfoImg(map);</span><br><span class=\"line\">  if (userInfoList == null || userInfoList.size() == 0) &#123;</span><br><span class=\"line\">   return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  for (int i = 0; i &lt; userInfoList.size(); i++) &#123;</span><br><span class=\"line\">   UserInfo user = userInfoList.get(i);</span><br><span class=\"line\">   String userId = user.getUserId();</span><br><span class=\"line\">   String userName = user.getUserName();</span><br><span class=\"line\">   byte[] content = user.getImgContent;</span><br><span class=\"line\">   </span><br><span class=\"line\">   // 不落地，直接通过FTP上传给第三方</span><br><span class=\"line\">   FileUtil.uploadByFtp(content);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125; catch (Exception e) &#123;</span><br><span class=\"line\">  serviceLogger.error(&quot;获取图片异常：&quot;, e);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><strong>4、异步线程池工具类</strong></p>\n<p><strong>@Async的作用就是异步处理任务。</strong></p>\n<p>1.在方法上添加@Async，表示此方法是异步方法；</p>\n<p>2.在类上添加@Async，表示类中的所有方法都是异步方法；</p>\n<p>3.使用此注解的类，必须是Spring管理的类；</p>\n<p>4.需要在启动类或配置类中加入@EnableAsync注解，@Async才会生效；</p>\n<p>在使用@Async时，如果不指定线程池的名称，也就是不自定义线程池，@Async是有默认线程池的，使用的是Spring默认的线程池SimpleAsyncTaskExecutor。</p>\n<p>默认线程池的默认配置如下：</p>\n<p>1.默认核心线程数：8；</p>\n<p>2.最大线程数：Integet.MAX_VALUE；</p>\n<p>3.队列使用LinkedBlockingQueue；</p>\n<p>4.容量是：Integet.MAX_VALUE；</p>\n<p>5.空闲线程保留时间：60s；</p>\n<p>6.线程池拒绝策略：AbortPolicy；</p>\n<p>从最大线程数可以看出，在并发情况下，会无限制的创建线程，我勒个吗啊。</p>\n<p><strong>也可以通过yml重新配置：</strong><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring:</span><br><span class=\"line\">  task:</span><br><span class=\"line\">    execution:</span><br><span class=\"line\">      pool:</span><br><span class=\"line\">        max-size: 10</span><br><span class=\"line\">        core-size: 5</span><br><span class=\"line\">        keep-alive: 3s</span><br><span class=\"line\">        queue-capacity: 1000</span><br><span class=\"line\">        thread-name-prefix: my-executor</span><br></pre></td></tr></table></figure></p>\n<p>也可以自定义线程池，下面通过简单的代码来实现以下@Async自定义线程池。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@EnableAsync// 支持异步操作</span><br><span class=\"line\">@Configuration</span><br><span class=\"line\">public class AsyncTaskConfig &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * com.google.guava中的线程池</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Bean(&quot;my-executor&quot;)</span><br><span class=\"line\">    public Executor firstExecutor() &#123;</span><br><span class=\"line\">        ThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat(&quot;my-executor&quot;).build();</span><br><span class=\"line\">        // 获取CPU的处理器数量</span><br><span class=\"line\">        int curSystemThreads = Runtime.getRuntime().availableProcessors() * 2;</span><br><span class=\"line\">        ThreadPoolExecutor threadPool = new ThreadPoolExecutor(curSystemThreads, 100,</span><br><span class=\"line\">                200, TimeUnit.SECONDS,</span><br><span class=\"line\">                new LinkedBlockingQueue&lt;&gt;(), threadFactory);</span><br><span class=\"line\">        threadPool.allowsCoreThreadTimeOut();</span><br><span class=\"line\">        return threadPool;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Spring线程池</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Bean(&quot;async-executor&quot;)</span><br><span class=\"line\">    public Executor asyncExecutor() &#123;</span><br><span class=\"line\">        ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor();</span><br><span class=\"line\">        // 核心线程数</span><br><span class=\"line\">        taskExecutor.setCorePoolSize(24);</span><br><span class=\"line\">        // 线程池维护线程的最大数量，只有在缓冲队列满了之后才会申请超过核心线程数的线程</span><br><span class=\"line\">        taskExecutor.setMaxPoolSize(200);</span><br><span class=\"line\">        // 缓存队列</span><br><span class=\"line\">        taskExecutor.setQueueCapacity(50);</span><br><span class=\"line\">        // 空闲时间，当超过了核心线程数之外的线程在空闲时间到达之后会被销毁</span><br><span class=\"line\">        taskExecutor.setKeepAliveSeconds(200);</span><br><span class=\"line\">        // 异步方法内部线程名称</span><br><span class=\"line\">        taskExecutor.setThreadNamePrefix(&quot;async-executor-&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略</span><br><span class=\"line\">         * 通常有以下四种策略：</span><br><span class=\"line\">         * ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。</span><br><span class=\"line\">         * ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。</span><br><span class=\"line\">         * ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span><br><span class=\"line\">         * ThreadPoolExecutor.CallerRunsPolicy：重试添加当前的任务，自动重复调用 execute() 方法，直到成功</span><br><span class=\"line\">         */</span><br><span class=\"line\">        taskExecutor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class=\"line\">        taskExecutor.initialize();</span><br><span class=\"line\">        return taskExecutor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"三、告别劣质代码，优化从何入手？\"><a href=\"#三、告别劣质代码，优化从何入手？\" class=\"headerlink\" title=\"三、告别劣质代码，优化从何入手？\"></a>三、告别劣质代码，优化从何入手？</h4><p>我觉得优化有两个大方向：</p>\n<p>1.业务优化</p>\n<p>2.代码优化</p>\n<p><strong>1、业务优化业</strong></p>\n<p>务优化的影响力非常大，但它一般属于产品和项目经理的范畴，CRUD程序员很少能接触到。</p>\n<p>比如上面说的图片导出上传需求，经过产品经理和项目经理的不懈努力，这个需求不做了，这优化力度，史无前例啊。</p>\n<p><strong>2、代码优化</strong></p>\n<p>1.数据库优化</p>\n<p>2.复用优化</p>\n<p>3.并行优化</p>\n<p>4.算法优化<br><img src=\"/img/2024/202405103.webp\" alt=\"erik.xyz\"></p>\n<h4 id=\"四、数据库优化\"><a href=\"#四、数据库优化\" class=\"headerlink\" title=\"四、数据库优化\"></a>四、数据库优化</h4><p>1.inner join 、left join、right join，优先使用inner join</p>\n<p>2.表连接不宜太多，索引不宜太多，一般5个以内</p>\n<p>3.复合索引最左特性</p>\n<p>4.操作delete或者update语句，加个limit或者循环分批次删除</p>\n<p>5.使用explain分析你SQL执行计划</p>\n<p>SQL性能优化的47个小技巧，果断收藏！</p>\n<h4 id=\"五、复用优化\"><a href=\"#五、复用优化\" class=\"headerlink\" title=\"五、复用优化\"></a>五、复用优化</h4><p>写代码的时候，大家一般都会将重复性的代码提取出来，写成工具方法，在下次用的时候，就不用重新编码，直接调用就可以了。</p>\n<p>这个就是复用。</p>\n<p>数据库连接池、线程池、长连接也都是复用手段，这些对象的创建和销毁成本过高，复用之后，效率提升显著。</p>\n<p><strong>1、连接池</strong></p>\n<p>连接池是一种常见的优化网络连接复用性的方法。连接池管理着一定数量的网络连接，并且在需要时将这些连接分配给客户端，客户端使用完后将连接归还给连接池。这样可以避免每次通信都建立新的连接，减少了连接的建立和销毁过程，提高了系统的性能和效率。</p>\n<p>在Java开发中，常用的连接池技术有Apache Commons Pool、Druid等。使用连接池时，需要合理设置连接池的大小，并根据实际情况进行调优。连接池的大小过小会导致连接不够用，而过大则会占用过多的系统资源。</p>\n<p><strong>2、长连接</strong></p>\n<p>长连接是另一种优化网络连接复用性的方法。长连接指的是在一次通信后，保持网络连接不关闭，以便后续的通信继续复用该连接。与短连接相比，长连接在一定程度上减少了连接的建立和销毁过程，提高了网络连接的复用性和效率。</p>\n<p>在Java开发中，可以通过使用Socket编程实现长连接。客户端在建立连接后，通过设置Socket的Keep-Alive选项，使得连接保持活跃状态。这样可以避免频繁地建立新的连接，提高网络连接的复用性和效率。</p>\n<p><strong>3、缓存</strong></p>\n<p>缓存也是比较常用的复用，属于数据复用。</p>\n<p>缓存一般是将数据库中的数据缓存到内存或者Redis中，也就是缓存到相对高速的区域，下次查询时，直接访问缓存，就不用查询数据库了，缓存主要针对的是读操作。</p>\n<p><strong>4、缓冲</strong></p>\n<p>缓冲常见于对数据的暂存，然后批量传输或者写入。多使用顺序方式，用来缓解不同设备之间频繁地、缓慢地随机写，缓冲主要针对的是写操作。</p>\n<h4 id=\"六、并行优化\"><a href=\"#六、并行优化\" class=\"headerlink\" title=\"六、并行优化\"></a>六、并行优化</h4><p><strong>1、异步编程</strong></p>\n<p>上面的优化方式就是异步优化，充分利用多核处理器的性能，将串行的程序改为并行，大大提高了程序的执行效率。</p>\n<p>异步编程是一种编程模型，其中任务的执行不会阻塞当前线程的执行。通过将任务提交给其他线程或线程池来处理，当前线程可以继续执行其他操作，而不必等待任务完成。</p>\n<p><strong>2、异步编程的特点</strong></p>\n<p>1.非阻塞：异步任务的执行不会导致调用线程的阻塞，允许线程继续执行其他任务；</p>\n<p>2.回调机制：异步任务通常会注册回调函数，当任务完成时，会调用相应的回调函数进行后续处理；</p>\n<p>3.提高响应性：异步编程能够提高程序的响应性，尤其适用于处理IO密集型任务，如网络请求、数据库查询等；</p>\n<p>Java 8引入了CompletableFuture类，可以方便地进行异步编程。</p>\n<p><strong>3、并行编程</strong></p>\n<p>并行编程是一种利用多个线程或处理器同时执行多个任务的编程模型。它将大任务划分为多个子任务，并发地执行这些子任务，从而加速整体任务的完成时间。</p>\n<p><strong>4、并行编程的特点</strong></p>\n<p>1.分布式任务：并行编程将大任务划分为多个独立的子任务，每个子任务在不同的线程中并行执行；</p>\n<p>2..数据共享：并行编程需要考虑多个线程之间的数据共享和同步问题，以避免出现竞态条件和数据不一致的情况；</p>\n<p>3.提高性能：并行编程能够充分利用多核处理器的计算能力，加速程序的执行速度。</p>\n<p><strong>5、并行编程如何实现？</strong></p>\n<p>1.多线程：Java提供了Thread类和Runnable接口，用于创建和管理多个线程。通过创建多个线程并发执行任务，可以实现并行编程。</p>\n<p>2.线程池：Java的Executor框架提供了线程池的支持，可以方便地管理和调度多个线程。通过线程池，可以复用线程对象，减少线程创建和销毁的开销；</p>\n<p>3.并发集合：Java提供了一系列的并发集合类，如ConcurrentHashMap、ConcurrentLinkedQueue等，用于在并行编程中实现线程安全的数据共享。</p>\n<p>异步编程和并行编程是Java中处理任务并提高程序性能的两种重要方法。</p>\n<p>异步编程通过非阻塞的方式处理任务，提高程序的响应性，并适用于IO密集型任务。</p>\n<p>而并行编程则是通过多个线程或处理器并发执行任务，充分利用计算资源，加速程序的执行速度。</p>\n<p>在Java中，可以使用CompletableFuture和回调接口实现异步编程，使用多线程、线程池和并发集合实现并行编程。通过合理地运用异步和并行编程，我们可以在Java中高效地处理任务和提升程序的性能。</p>\n<p><strong>6、代码示例</strong><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    // 创建线程池</span><br><span class=\"line\">    ExecutorService executor = Executors.newFixedThreadPool(10);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 使用线程池创建CompletableFuture对象</span><br><span class=\"line\">    CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">        // 一些不为人知的操作</span><br><span class=\"line\">        return &quot;result&quot;; // 返回结果</span><br><span class=\"line\">    &#125;, executor);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 使用CompletableFuture对象执行任务</span><br><span class=\"line\">    CompletableFuture&lt;String&gt; result = future.thenApply(result -&gt; &#123;</span><br><span class=\"line\">        // 一些不为人知的操作</span><br><span class=\"line\">        return &quot;result&quot;; // 返回结果</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 处理任务结果</span><br><span class=\"line\">    String finalResult = result.join();</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 关闭线程池</span><br><span class=\"line\">    executor.shutdown();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>7、Java 8 parallel</strong></p>\n<p><strong>（1）parallel()是什么</strong></p>\n<p>Stream.parallel() 方法是 Java 8 中 Stream API 提供的一种并行处理方式。在处理大量数据或者耗时操作时，使用 Stream.parallel() 方法可以充分利用多核 CPU 的优势，提高程序的性能。</p>\n<p>Stream.parallel() 方法是将串行流转化为并行流的方法。通过该方法可以将大量数据划分为多个子任务交由多个线程并行处理，最终将各个子任务的计算结果合并得到最终结果。使用 Stream.parallel() 可以简化多线程编程，减少开发难度。</p>\n<p>需要注意的是，并行处理可能会引入线程安全等问题，需要根据具体情况进行选择。</p>\n<p><strong>（2）举一个简单的demo</strong></p>\n<p>定义一个list，然后通过parallel() 方法将集合转化为并行流，对每个元素进行i++，最后通过 collect(Collectors.toList()) 方法将结果转化为 List 集合。</p>\n<p>使用并行处理可以充分利用多核 CPU 的优势，加快处理速度。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">            list.add(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\">        List&lt;Integer&gt; result = list.stream().parallel().map(i -&gt; i++).collect(Collectors.toList());</span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>我勒个去，什么情况？<br><img src=\"/img/2024/202405104.webp\" alt=\"erik.xyz\"></p>\n<p><strong>（3）parallel()的优缺点</strong></p>\n<p><strong>①优点：</strong></p>\n<p>1.充分利用多核 CPU 的优势，提高程序的性能；</p>\n<p>2.可以简化多线程编程，减少开发难度。</p>\n<p><strong>②缺点：</strong></p>\n<p>1.并行处理可能会引入线程安全等问题，需要根据具体情况进行选择；</p>\n<p>2.并行处理需要付出额外的开销，例如线程池的创建和销毁、线程切换等，对于小数据量和简单计算而言，串行处理可能更快。</p>\n<p><strong>（4）何时使用parallel()？</strong></p>\n<p>在实际开发中，应该根据数据量、计算复杂度、硬件等因素综合考虑。</p>\n<p>比如：</p>\n<p>1.数据量较大，有1万个元素；</p>\n<p>2.计算复杂度过大，需要对每个元素进行复杂的计算；</p>\n<p>3.硬件够硬，比如多核CPU。</p>\n<h4 id=\"七、算法优化\"><a href=\"#七、算法优化\" class=\"headerlink\" title=\"七、算法优化\"></a>七、算法优化</h4><p>在上面的例子中，避免base64解密，就应该归类于算法优化。</p>\n<p>程序就是由数据结构和算法组成，一个优质的算法可以显著提高程序的执行效率，从而减少运行时间和资源消耗。相比之下，一个低效的算法就可能导致运行非常缓慢，并占用大量系统资源。</p>\n<p>很多问题都可以通过算法优化来解决，比如：</p>\n<p><strong>1、循环和递归</strong></p>\n<p>循环和递归是Java编程中常见的操作，然而，过于复杂的业务逻辑往往会带来多层循环套用，不必要的重复循环会大大降低程序的执行效率。</p>\n<p>递归是一种函数自我调用的技术，类似于循环，虽然递归可以解决很多问题，但是，递归的效率有待提高。</p>\n<p><strong>2、内存管理</strong></p>\n<p>Java自带垃圾收集器，开发人员不用手动释放内存。</p>\n<p>但是，不合理的内存使用可能导致内存泄漏和性能下降，确保及时释放不再使用的对象，避免创建过多的临时对象。</p>\n<p><strong>3、字符串</strong></p>\n<p>我觉得字符串是Java编程中使用频率最高的技术，很多程序员恨不得把所有的变量都定义成字符串。</p>\n<p>然而，由于字符串是不可变的，每次执行字符串拼接、替换时，都会创建一个新的字符串。这会占用大量的内存和处理时间。</p>\n<p>使用StringBuilder来处理字符串的拼接可以显著的提高性能。</p>\n<p><strong>4、IO操作</strong></p>\n<p>IO操作通常是最耗费性能和资源的操作。在处理大量数据IO操作时，务必注意优化IO代码，提高程序性能，比如上面提高的图片不落地就是彻底解决IO问题。</p>\n<p><strong>5、数据结构的选择</strong></p>\n<p>选择适当的数据结构对程序的性能至关重要。</p>\n<p>比如Java世界中用的第二多的Map，比较常用的有HashMap、HashTable、ConcurrentHashMap。</p>\n<p>HashMap，底层数组+链表实现，可以存储null键和null值，线程不安全；</p>\n<p>HashTable，底层数组+链表实现，无论key还是value都不能为null，线程安全，实现线程安全的方式是在修改数据时锁住整个HashTable，效率低，ConcurrentHashMap做了相关优化；</p>\n<p>ConcurrentHashMap，底层采用分段的数组+链表实现，线程安全，通过把整个Map分为N个Segment，可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。</p>\n<p>Hashtable的synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。</p>\n<p>转载自：<a href=\"https://mp.weixin.qq.com/s/V2p_p-KoDowlZxLN2by2Sg\">哪吒编程</a></p>\n",
            "tags": [
                "web",
                "优化"
            ]
        },
        {
            "id": "https://erik.xyz/2021/11/15/reids-info-lock/",
            "url": "https://erik.xyz/2021/11/15/reids-info-lock/",
            "title": "细说Redis分布式锁",
            "date_published": "2021-11-15T13:43:00.000Z",
            "content_html": "<p>谈起Redis锁，下面三个，算是出现最多的高频词汇：</p>\n<ul>\n<li>Setnx</li>\n<li>Redlock</li>\n<li>Redisson</li>\n</ul>\n<p>Setnx</p>\n<p>其实目前通常所说的Setnx命令，并非单指Redis的setnx key value这条命令。</p>\n<span id=\"more\"></span>\n<p>一般代指Redis中对set命令加上nx参数进行使用，set这个命令，目前已经支持这么多参数可选：</p>\n<pre><code>SET key value [EX seconds|PX milliseconds] [NX|XX] [KEEPTTL]\n</code></pre><p>当然了，就不在文章中默写API了，基础参数还有不清晰的，可以蹦到官网：<a href=\"https://redis.io/commands/set\">https://redis.io/commands/set</a></p>\n<p><img src=\"/2021/11/20211115214422.jpg\" alt=\"\"></p>\n<p>上图是笔者画的Setnx大致原理，主要依托了它的key不存在才能set成功的特性，进程A拿到锁，在没有删除锁的Key时，进程B自然获取锁就失败了。</p>\n<p>那么为什么要使用PX 30000去设置一个超时时间？</p>\n<p>是怕进程A不讲道理啊，锁没等释放呢，万一崩了，直接原地把锁带走了，导致系统中谁也拿不到锁。</p>\n<p>就算这样，还是不能保证万无一失。</p>\n<p>如果进程A又不讲道理，操作锁内资源超过笔者设置的超时时间，那么就会导致其他进程拿到锁，等进程A回来了，回手就是把其他进程的锁删了，如图：</p>\n<p><img src=\"/2021/11/20211115214716.jpg\" alt=\"\"></p>\n<p>还是刚才那张图，将T5时刻改成了锁超时，被Redis释放。</p>\n<p>进程B在T6开开心心拿到锁不到一会，进程A操作完成，回手一个del，就把锁释放了。</p>\n<p>当进程B操作完成，去释放锁的时候（图中T8时刻）：</p>\n<p>找不到锁其实还算好的，万一T7时刻有个进程C过来加锁成功，那么进程B就把进程C的锁释放了。</p>\n<p>以此类推，进程C可能释放进程D的锁，进程D……（禁止套娃），具体什么后果就不得而知了。</p>\n<p>所以在用Setnx的时候，key虽然是主要作用，但是value也不能闲着，可以设置一个唯一的客户端ID，或者用UUID这种随机数。</p>\n<p>当解锁的时候，先获取value判断是否是当前进程加的锁，再去删除。伪代码：</p>\n<pre><code>String uuid = xxxx;\n// 伪代码，具体实现看项目中用的连接工具\n// 有的提供的方法名为set，有的叫setIfAbsent\nset Test uuid NX PX 3000\ntry&#123;\n// biz handle....\n&#125; finally &#123;\n    // unlock\n    if(uuid.equals(redisTool.get(&#39;Test&#39;))&#123;\n        redisTool.del(&#39;Test&#39;);\n    &#125;\n&#125;\n</code></pre><p>这回看起来是不是稳了。</p>\n<p>相反，这回的问题更明显了，在finally代码块中，get和del并非原子操作，还是有进程安全问题。</p>\n<p>为什么有问题还说这么多呢？</p>\n<p>第一，搞清劣势所在，才能更好的完善。</p>\n<p>第二点，其实上文中最后这段代码，还是有很多公司在用的。</p>\n<p>大小项目悖论：大公司实现规范，但是小司小项目虽然存在不严谨，可并发倒也不高，出问题的概率和大公司一样低。——鲁迅</p>\n<p>那么删除锁的正确姿势之一，就是可以使用Lua脚本，通过Redis的eval/evalsha命令来运行：</p>\n<pre><code>-- Lua删除锁：\n-- KEYS和ARGV分别是以集合方式传入的参数，对应上文的Test和uuid。\n-- 如果对应的value等于传入的uuid。\nif redis.call(&#39;get&#39;, KEYS[1]) == ARGV[1] \n    then \n -- 执行删除操作\n        return redis.call(&#39;del&#39;, KEYS[1]) \n    else \n -- 不成功，返回0\n        return 0 \nend\n</code></pre><p>通过Lua脚本能保证原子性的原因说的通俗一点：</p>\n<p>就算你在Lua里写出花，执行也是一个命令（eval/evalsha）去执行的，一条命令没执行完，其他客户端是看不到的。</p>\n<p>那么既然这么麻烦，有没有比较好的工具呢？就要说到Redisson了。</p>\n<p>介绍Redisson之前，笔者简单解释一下为什么现在的Setnx默认是指set命令带上nx参数，而不是直接说是Setnx这个命令。</p>\n<p>因为Redis版本在2.6.12之前，set是不支持nx参数的，如果想要完成一个锁，那么需要两条命令：</p>\n<pre><code>1. setnx Test uuid\n2. expire Test 30\n</code></pre><p>即放入Key和设置有效期，是分开的两步，理论上会出现1刚执行完，程序挂掉，无法保证原子性。</p>\n<p>但是早在2013年，也就是7年前，Redis就发布了2.6.12版本，并且官网（set命令页[1]），也早早就说明了“SETNX，SETEX，PSETEX可能在未来的版本中，会弃用并永久删除”。</p>\n<p>笔者曾阅读过一位大佬的文章，其中就有一句指导入门者的面试小套路，具体文字忘记了，大概意思如下：</p>\n<pre><code>说到Redis锁的时候，可以先从Setnx讲起，最后慢慢引出set命令的可以加参数，可以体现出自己的知识面。\n</code></pre><p>如果有缘你也阅读过这篇文章，并且学到了这个套路，作为本文的笔者我要加一句提醒：</p>\n<p>请注意你的工作年限！首先回答官网表明即将废弃的命令，再引出set命令七年前的“新特性”，如果是刚毕业不久的人这么说，面试官会以为自己穿越了。</p>\n<p>你套路面试官，面试官也会套路你。——vt・沃兹基硕德</p>\n<p>Redisson</p>\n<p>Redisson是Java的Redis客户端之一，提供了一些API方便操作Redis。</p>\n<p>但是Redisson这个客户端可有点厉害，笔者在官网截了仅仅是一部分的图：</p>\n<p><img src=\"/2021/11/20211115214952.jpg\" alt=\"\"></p>\n<p>这个特性列表可以说是太多了，是不是还看到了一些JUC包下面的类名，Redisson帮我们搞了分布式的版本，比如AtomicLong，直接用RedissonAtomicLong就行了，连类名都不用去新记，很人性化了。</p>\n<p>锁只是它的冰山一角，并且从它的wiki[2]页面看到，对主从，哨兵，集群等模式都支持，当然了，单节点模式肯定是支持的。</p>\n<p>本文还是以锁为主，其他的不过多介绍。</p>\n<p>Redisson普通的锁实现源码主要是RedissonLock这个类，还没有看过它源码的盆友，不妨去瞧一瞧。</p>\n<p>源码中加锁/释放锁操作都是用Lua脚本完成的，封装的非常完善，开箱即用。</p>\n<p>这里有个小细节，加锁使用Setnx就能实现，也采用Lua脚本是不是多此一举？笔者也非常严谨的思考了一下：这么厉害的东西哪能写废代码？</p>\n<p>其实笔者仔细看了一下，加锁解锁的Lua脚本考虑的非常全面，其中就包括锁的重入性，这点可以说是考虑非常周全，我也随手写了代码测试一下：</p>\n<p><img src=\"/2021/11/20211115215028.jpg\" alt=\"\"></p>\n<p>的确用起来像JDK的ReentrantLock一样丝滑，那么Redisson实现的已经这么完善，RedLock又是什么？</p>\n<p>RedLock</p>\n<p>RedLock的中文是直译过来的，就叫红锁。</p>\n<p>红锁并非是一个工具，而是Redis官方提出的一种分布式锁的算法。</p>\n<p>就在刚刚介绍完的Redisson中，就实现了redLock版本的锁。也就是说除了getLock方法，还有getRedLock方法。</p>\n<p>笔者大概画了一下对红锁的理解：</p>\n<p><img src=\"/2021/11/20211115215116.jpg\" alt=\"\"></p>\n<p>如果你不熟悉Redis高可用部署，那么没关系。RedLock算法虽然是需要多个实例，但是这些实例都是独自部署的，没有主从关系。</p>\n<p>RedLock作者指出，之所以要用独立的，是避免了redis异步复制造成的锁丢失，比如：主节点没来的及把刚刚set进来这条数据给从节点，就挂了。</p>\n<p>有些人是不是觉得大佬们都是杠精啊，天天就想着极端情况。其实高可用嘛，拼的就是99.999……%中小数点后面的位数。</p>\n<p>回到上面那张简陋的图片，红锁算法认为，只要(N/2) + 1个节点加锁成功，那么就认为获取了锁， 解锁时将所有实例解锁。流程为：</p>\n<p>  1.顺序向五个节点请求加锁</p>\n<p>  2.根据一定的超时时间来推断是不是跳过该节点</p>\n<p>  3.三个节点加锁成功并且花费时间小于锁的有效期</p>\n<p>  4.认定加锁成功</p>\n<p>也就是说，假设锁30秒过期，三个节点加锁花了31秒，自然是加锁失败了。</p>\n<p>这只是举个例子，实际上并不应该等每个节点那么长时间，就像官网所说的那样，假设有效期是10秒，那么单个Redis实例操作超时时间，应该在5到50毫秒（注意时间单位）。</p>\n<p>还是假设我们设置有效期是30秒，图中超时了两个Redis节点。那么加锁成功的节点总共花费了3秒，所以锁的实际有效期是小于27秒的。</p>\n<p>即扣除加锁成功三个实例的3秒，还要扣除等待超时Redis实例的总共时间。</p>\n<p>看到这，你有可能对这个算法有一些疑问，那么你不是一个人。</p>\n<p>回头看看Redis官网关于红锁的描述[3]。</p>\n<p>就在这篇描述页面的最下面，你能看到著名的关于红锁的神仙打架事件。</p>\n<p>即Martin Kleppmann和Antirez的RedLock辩论。一个是很有资历的分布式架构师，一个是Redis之父。</p>\n<p>官方挂人，最为致命。</p>\n<p>开个玩笑，要是质疑能被官方挂到官网，说明肯定是有价值的。</p>\n<p>所以说如果项目里要使用红锁，除了红锁的介绍，不妨要多看两篇文章，即：</p>\n<ul>\n<li><p>Martin Kleppmann的质疑贴：<a href=\"http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html\">http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html</a></p>\n</li>\n<li><p>Antirez的反击贴：<a href=\"http://antirez.com/news/101\">http://antirez.com/news/101</a></p>\n</li>\n</ul>\n<p>总结</p>\n<p>看了这么多，是不是发现如何实现，都不能保证100%的稳定。</p>\n<p>程序就是这样，没有绝对的稳定，所以做好人工补偿环节也是重要的一环，毕竟：技术不够，人工来凑～</p>\n<p>相关链接：</p>\n<p><a href=\"https://redis.io/commands/set\">https://redis.io/commands/set</a></p>\n<p><a href=\"https://github.com/redisson/redisson/wiki/Table-of-Content\">https://github.com/redisson/redisson/wiki/Table-of-Content</a></p>\n<p><a href=\"https://redis.io/topics/distlock\">https://redis.io/topics/distlock</a></p>\n<p>原文链接：<a href=\"https://juejin.cn/post/6844904082860146695\">https://juejin.cn/post/6844904082860146695</a></p>\n",
            "tags": [
                "redis",
                "redis锁",
                "redis分布式锁"
            ]
        },
        {
            "id": "https://erik.xyz/2019/07/18/http1-1-and-http2-0/",
            "url": "https://erik.xyz/2019/07/18/http1-1-and-http2-0/",
            "title": "http1.1和http2.0的知识点",
            "date_published": "2019-07-17T16:20:00.000Z",
            "content_html": "<h3 id=\"Http1-1\"><a href=\"#Http1-1\" class=\"headerlink\" title=\"Http1.1\"></a><a href=\"#Http1-1\" title=\"Http1.1\"></a>Http1.1</h3><ul>\n<li><p>缓存处理</p>\n<p> 引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</p>\n</li>\n<li><p>带宽优化及网络连接的使用</p>\n<p>  在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。<span id=\"more\"></span></p>\n</li>\n<li><p>错误通知的管理</p>\n<p> 新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p>\n</li>\n<li><p>Host头处理</p>\n<p>  Http1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</p>\n</li>\n<li><p>长连接</p>\n<p>  Http1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</p>\n</li>\n</ul>\n<h3 id=\"Http2-0\"><a href=\"#Http2-0\" class=\"headerlink\" title=\"Http2.0\"></a>Http2.0</h3><ul>\n<li>完全采用二进制格式</li>\n<li><p>多路复用</p>\n<p>   根据request的 id将request再归属到各自不同的服务端请求里面。</p>\n</li>\n<li><p>header压缩</p>\n<p>   使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</p>\n</li>\n<li><p>服务端推送</p>\n<p>   server push功能。</p>\n</li>\n</ul>\n<h5 id=\"Http2-0的多路复用和Http1-X中的长连接复用有什么区别？\"><a href=\"#Http2-0的多路复用和Http1-X中的长连接复用有什么区别？\" class=\"headerlink\" title=\"Http2.0的多路复用和Http1.X中的长连接复用有什么区别？\"></a><a href=\"#Http2-0的多路复用和Http1-X中的长连接复用有什么区别？\" title=\"Http2.0的多路复用和Http1.X中的长连接复用有什么区别？\"></a>Http2.0的多路复用和Http1.X中的长连接复用有什么区别？</h5><ul>\n<li>Http/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；</li>\n<li>Http/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；</li>\n<li>Http/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；</li>\n</ul>\n<h5 id=\"服务器推送到底是什么？\"><a href=\"#服务器推送到底是什么？\" class=\"headerlink\" title=\"服务器推送到底是什么？\"></a><a href=\"#服务器推送到底是什么？\" title=\"服务器推送到底是什么？\"></a>服务器推送到底是什么？</h5><p>服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。</p>\n<h5 id=\"为什么需要头部压缩？\"><a href=\"#为什么需要头部压缩？\" class=\"headerlink\" title=\"为什么需要头部压缩？\"></a><a href=\"#为什么需要头部压缩？\" title=\"为什么需要头部压缩？\"></a>为什么需要头部压缩？</h5><p>假定一个页面有100个资源需要加载（这个数量对于今天的Web而言还是挺保守的）, 而每一次请求都有1kb的消息头（这同样也并不少见，因为Cookie和引用等东西的存在）, 则至少需要多消耗100kb来获取这些消息头。HTTP2.0可以维护一个字典，差量更新HTTP头部，大大降低因头部传输产生的流量</p>\n<h5 id=\"Http2-0多路复用有多好\"><a href=\"#Http2-0多路复用有多好\" class=\"headerlink\" title=\"Http2.0多路复用有多好\"></a><a href=\"#Http2-0多路复用有多好\" title=\"Http2.0多路复用有多好\"></a>Http2.0多路复用有多好</h5><ul>\n<li>Http性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。</li>\n<li>Http/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。</li>\n</ul>\n",
            "tags": [
                "web",
                "http",
                "http1.1",
                "http2.0"
            ]
        },
        {
            "id": "https://erik.xyz/2017/11/17/ru-he-chu-li-wang-zhan-xiang-ying-man-de-wen-ti/",
            "url": "https://erik.xyz/2017/11/17/ru-he-chu-li-wang-zhan-xiang-ying-man-de-wen-ti/",
            "title": "如何处理网站响应慢的问题",
            "date_published": "2017-11-17T13:19:00.000Z",
            "content_html": "<p>当一个网页请求量在10W+的时候出现慢或者很卡的情况如何解决呢？ 1.后台数据</p>\n<ul>\n<li>把所有的数据放进缓存，让服务器内存来处理。</li>\n<li>优化数据获取代码。</li>\n<li>减少接口的重复请求<span id=\"more\"></span>\n</li>\n</ul>\n<p>2.服务器</p>\n<ul>\n<li>开启服务器多线程服务。</li>\n<li>查看cpu负载和内存负载。</li>\n<li>检查服务器宽带。</li>\n<li>去掉重定向</li>\n</ul>\n<p>3.页面</p>\n<ul>\n<li>使用第三方cnd加载js公共文件。</li>\n<li>压缩图片和其他类型的文件（资源加载压缩）。</li>\n<li>优化js代码处理。</li>\n<li>预加载页面（延迟渲染），延迟执行js。</li>\n<li>把js/css/图片缓存至本地浏览器。</li>\n<li>优化js代码</li>\n</ul>\n",
            "tags": [
                "优化",
                "响应慢",
                "页面优化"
            ]
        },
        {
            "id": "https://erik.xyz/2017/10/20/hui-hua-yuan-li/",
            "url": "https://erik.xyz/2017/10/20/hui-hua-yuan-li/",
            "title": "会话原理",
            "date_published": "2017-10-20T13:18:00.000Z",
            "content_html": "<p>最近公司招聘新员工，面试中有提到会话原理，我懵了一下。 会话原理是什么？ 首先解释一下什么是会话。在计算机术语中，会话是指一个终端用户与交互系统进行通讯的过程，比如从输入账户密码进入操作系统到退出操作系统就是一个会话过程。会话较多用于网络上，TCP的三次握手就创建了一个会话，TCP关闭连接就是关闭会话。用平述的语言可以解释为：你拔打你女友的电话号码，你女友接听，然后一翻“亲爱的”，直到任何一方挂掉电话，这个过程就是一个会话。你挑逗一只小狗，它跟你互动，也是会话；它不鸟你，那就不形成会话。 这不是就是服务端与用户端的通信，或者说用户端登录服务端的认证。 她可以使服务器间的通信，浏览器与网站的通信…… 可以用传统的cookie、session机制实现。也可以用令牌认证实现。这其中包含：创建会话 、认证会话 、获取会话信息、会话时长限制、销毁会话。 通俗的就是一个用户登录到一网站，并浏览网站数据，然后离开的过程。 其实，就是登录认证服务。</p>\n",
            "tags": [
                "会话",
                "会话原理"
            ]
        },
        {
            "id": "https://erik.xyz/2017/08/07/nei-wang-chuan-tou-zhi-fu-jie-kou-ben-di-hua-kai-fa-ben-di-gua-wang-wai-wang-fang-wen/",
            "url": "https://erik.xyz/2017/08/07/nei-wang-chuan-tou-zhi-fu-jie-kou-ben-di-hua-kai-fa-ben-di-gua-wang-wai-wang-fang-wen/",
            "title": "内网穿透、支付接口本地化开发、本地挂网外网访问",
            "date_published": "2017-08-07T15:58:00.000Z",
            "content_html": "<p>在技术qq群偶然聊得最近想入手一台微型服务器，电脑装虚拟机多了感觉好卡，操作不太方便。 群友有提到利用内网穿透不必本地挂载linux服务器便可以很轻松实现。</p>\n<p>顺便就查查他们所说的ngrok，百度的解释如下：<br><img src=\"http://erik.xyz/wp-content/uploads/2017/08/1.jpg\" alt=\"\"> </p>\n<p>看来这是个不错的工具，减少挂载带来的资源占用。<span id=\"more\"></span></p>\n<p>ngrok 是一个开源程序,官网服务在国外,国内访问国外速度慢.</p>\n<p>国内有相应的ngrok服务natapp，frp，nat123端口映射，内网通 等</p>\n<p>国内ngrok网址：<a href=\"https://www.ngrok.cc/\">https://www.ngrok.cc/</a></p>\n<p>顺便查了一下群友强力推荐的frp</p>\n<p>网址 <a href=\"http://getfrp.yzxx-soft.com/\">http://getfrp.yzxx-soft.com/</a></p>\n<p><img src=\"http://erik.xyz/wp-content/uploads/2017/08/2.jpg\" alt=\"\"></p>\n<p>感觉比较不错哦。</p>\n<p>其实，可以自己买台微型服务器，放在家里挂个博客。没事可以搞搞硬件，研究一下服务器也是可以的。</p>\n",
            "tags": [
                "内网支付",
                "内网穿透",
                "支付接口本地化开发",
                "本地挂网",
                "穿透"
            ]
        },
        {
            "id": "https://erik.xyz/2017/06/29/apache-he-nginx-yin-cang-index-php-de-pei-zhi/",
            "url": "https://erik.xyz/2017/06/29/apache-he-nginx-yin-cang-index-php-de-pei-zhi/",
            "title": "apache和Nginx隐藏index.php的配置",
            "date_published": "2017-06-29T00:24:00.000Z",
            "content_html": "<p>apache<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;IfModule mod\\_rewrite.c&gt; </span><br><span class=\"line\">Options +FollowSymlinks </span><br><span class=\"line\">RewriteEngine On </span><br><span class=\"line\">RewriteCond %&#123;REQUEST\\_FILENAME&#125; !-d </span><br><span class=\"line\">RewriteCond %&#123;REQUEST\\_FILENAME&#125; !-f RewriteRule ^(.*)$ index.php \\[L,E=PATH\\_INFO:$1\\] </span><br><span class=\"line\">&lt;/IfModule&gt;  </span><br></pre></td></tr></table></figure><br><span id=\"more\"></span></p>\n<p>nginx </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location / &#123; </span><br><span class=\"line\"></span><br><span class=\"line\">if (!-e $request_filename) &#123; </span><br><span class=\"line\"></span><br><span class=\"line\">rewrite ^/index.php(.*)$ /index.php?s=$1 last;</span><br><span class=\"line\"></span><br><span class=\"line\">rewrite ^(.*)$ /index.php?s=$1 last; break; </span><br><span class=\"line\"></span><br><span class=\"line\"> &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>",
            "tags": [
                "apache优化",
                "apache隐藏index",
                "nginx优化",
                "nginx隐藏index"
            ]
        },
        {
            "id": "https://erik.xyz/2015/10/24/ss3-zhong-border-radius-shi-ie-he-360-liu-lan-qi-jian-rong-mo-shi/",
            "url": "https://erik.xyz/2015/10/24/ss3-zhong-border-radius-shi-ie-he-360-liu-lan-qi-jian-rong-mo-shi/",
            "title": "css3中border-radius使ie和360浏览器兼容模式",
            "date_published": "2015-10-24T08:06:00.000Z",
            "content_html": "<p>360浏览器好垃圾,竟然默认兼容模式，css3好多不支持。 从网友中得到这样的的答案，太给力了 <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" /> <meta name=\"renderer\" content=\"webkit|ie-comp|ie-stand\"></p>\n",
            "tags": [
                "css3",
                "css3兼容360浏览器兼容模式",
                "css圆角"
            ]
        },
        {
            "id": "https://erik.xyz/2015/07/27/web-qian-duan-xiang-ying-shi-bu-ju-zi-shi-ying-suo-you-fen-bian-lv/",
            "url": "https://erik.xyz/2015/07/27/web-qian-duan-xiang-ying-shi-bu-ju-zi-shi-ying-suo-you-fen-bian-lv/",
            "title": "web前端响应式布局，自适应所有分辨率",
            "date_published": "2015-07-26T16:13:00.000Z",
            "content_html": "<p>写phpd的我。最近公司要弄个app关键是没有web开发，而我有比较闲，那就扛枪上阵吧。 响应式布局，web端的？php我一直都是用tp框架，对于web首先想到的是bootstrap框架。只是简单了解过，没真正实践啊，bootstrap比我想象的要好用的多。关键是，关键来了…… app端是只有手机的，pc基本上木有。那就是说只能按照手机端开发，那么boostrap响应式布局就不适用于app了（反正我是做了一套半成品，被推翻了）。不能愉快的工作了，好不淡定的时间。。百度，百又问问同事，发现了amaze ui也就是妹子框架，终于可以省事了，太高兴了。 amaze框架下载后是一套让人极其郁闷的示例包，文件引入是分开来介绍的，如果你不仔细看文档，会很痛苦的（因为我就是如此，好折磨人）。 好了附上amaze的引入文件，仅供大伙参考。 <a href=\"http://tietuku.com/b84e74496e36a7e0\"><img src=\"http://i1.tietuku.com/b84e74496e36a7e0.jpg\" alt=\"\"></a> 对了手机端要在头部加上这句话<span id=\"more\"></span><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; </span><br></pre></td></tr></table></figure><br>一切就绪，那就直奔主题。 手机端目前最低宽度是300.不过说实话智能手机300的屏幕估计是木有，那就按iphone4的320来设计web。那么问题来了，设计给的参考图示640的肿么办，所有的像素除以2，一切解决。 使用amaze框架并不能很好的解决不同分辨率的像素问题，而且最苦逼的就是要设置好多@media only screen and (min-width:320px) and (max-width:480px) {}屏幕范围样式。太痛苦了，受不了。。有木有一种可以控制的方法呢，京东是怎么弄的？小米又是怎么弄的？百度吧，一切从度娘中找答案。 <a href=\"http://tietuku.com/64ab3ce5b39e08f0\"><img src=\"http://i1.tietuku.com/64ab3ce5b39e08f0.jpg\" alt=\"\"></a>   答案好多，慢慢筛选吧……   于是找到这段代码 <a href=\"http://tietuku.com/f5a3689aabbb0f21\"><img src=\"http://i3.tietuku.com/f5a3689aabbb0f21.jpg\" alt=\"\"></a>   那么问题来了，这只是页面的，我想要所有的地方在不同尺寸的浏览器都能自适应，怎解决？ clientwidth是获取屏幕显示的宽度，设定最小屏幕为320，以320为基础，那么最小最字体就是12px。于是就有了改动。 <a href=\"http://tietuku.com/234327da825807f4\"><img src=\"http://i3.tietuku.com/234327da825807f4.jpg\" alt=\"\"></a>   好了这下子无论什么浏览器都是以最宽320，最小12px为基准。接着还有个问题，所有布局改用什么单位？px/em/pt/rem px是最精确的单位,固定值。em值不固定，继承父元素。rem在设定元素时仍是相对大小，但相对的是html根元素。pt就是印刷业上的单位，不过app开发中也用到。 那么好了，该用哪种的呢，我们先来看看上面的自适应js执行效果。 <a href=\"http://tietuku.com/c68b6fbfed3d6b9c\"><img src=\"http://i1.tietuku.com/c68b6fbfed3d6b9c.jpg\" alt=\"\"></a> 在html元素中生成了一个行内字体样式，答案就有了吧。</p>\n",
            "tags": [
                "web自适应",
                "响应式布局",
                "响应式所有分辨率",
                "自适应布局",
                "自适应所有分辨率"
            ]
        },
        {
            "id": "https://erik.xyz/2015/06/18/xiang-ying-shi-bu-ju-ru-he-ce-shi-bu-tong-fen-bian-lv/",
            "url": "https://erik.xyz/2015/06/18/xiang-ying-shi-bu-ju-ru-he-ce-shi-bu-tong-fen-bian-lv/",
            "title": "响应式布局如何测试不同分辨率",
            "date_published": "2015-06-17T16:04:00.000Z",
            "content_html": "<p>最近在做响应式布局适应不同分辨率的屏幕，太痛苦了，摸着石头过河。之前没有做过这块，手机端又不是很在行，ipad/iphone/三星……一大堆不同的屏幕，如何测试呢，总不能买一大堆设备吧。</p>\n<p>偶然间发现谷歌浏览器(最新版)可以缩小来实现，这样又有问题了，分辨率是多少呢？发现新方法了，废话不多说了，直接上教程。 1.在谷歌浏览器打开你要测试的网页按键盘F12，打开网页调试   2.点击调试工具右上角形似菜单的图标   3.这时候你会发现紧挨着浏览器底部有一排英文菜单   4.把菜单往上拉出来，点击第三个菜单   5.点击打开菜单下面的手机标示   6.如此便是手机设计效果   7.有2个地方可以选择不同的分辨率及屏幕对应的像素   8.下次打开就直接点击F12，然后左上角的手机标示就可以切换</p>\n",
            "tags": [
                "css",
                "web",
                "html",
                "响应式分辨率",
                "响应式调试",
                "自适应屏幕"
            ]
        },
        {
            "id": "https://erik.xyz/2014/10/25/bai-du-tong-ji-ce-shi-wang-zhan-xiang-ying-su-du-jiang-di/",
            "url": "https://erik.xyz/2014/10/25/bai-du-tong-ji-ce-shi-wang-zhan-xiang-ying-su-du-jiang-di/",
            "title": "百度统计测试网站响应速度降低",
            "date_published": "2014-10-25T02:27:00.000Z",
            "content_html": "<p><img src=\"http://img03.taobaocdn.com/imgextra/i1/809419769/TB2UVibaVXXXXbHXXXXXXXXXXXX_!!809419769.jpg\" alt=\"seo\"> <span id=\"more\"></span>前段时间用百度统计刚刚把网站响应速度跑个满分，过个2天却又降了下来，很是郁闷啊。到底是怎么回事呢，还得从头开始分析原因。从百度统计测试看有一大堆提示，什么图片过大，没有Gzip压缩…… <img src=\"http://img02.taobaocdn.com/imgextra/i2/809419769/TB2EV5aaVXXXXcnXXXXXXXXXXXX_!!809419769.jpg\" alt=\"优化详解\"> 先分析一下，我用wp super cache开启了预缓存才出现，没有Gzip压缩。关闭预缓存问题解决。 图片问题是由于我截图后直接上传而没有保存或者转换成web格式，导致图片比较大，加载自然会占时间。 还有，首页是跟着文章的更新而出现更新，因此响应速度慢也就没什么了。</p>\n",
            "tags": [
                "seo",
                "优化"
            ]
        },
        {
            "id": "https://erik.xyz/2014/10/24/wordpress-zhong-seo-you-hua-jian-yi/",
            "url": "https://erik.xyz/2014/10/24/wordpress-zhong-seo-you-hua-jian-yi/",
            "title": "wordpress中seo优化建议",
            "date_published": "2014-10-24T04:06:00.000Z",
            "content_html": "<p><a href=\"http://www.erik.xyz/seo_wpss\"><img src=\"http://img03.taobaocdn.com/imgextra/i1/809419769/TB2UVibaVXXXXbHXXXXXXXXXXXX_!!809419769.jpg\" alt=\"艾瑞可erik\"></a> 最近一直在弄网站优化这块，百度统计测试网站响应速度已100%跑满，只剩百度站长页面优化跑到92分卡住了。我对那些不愿意花时间来做优化的同行想说句“加油哦，我已经做到了”。大家遇到问题百度一下会发现好多贴吧或者博客说你没必要去管百度统计里面的优化，什么合并域名啊，合并js、css的都不行、没必要、影响不大。如果确实影响不大，百度难道自己有问题，故意个给你测评误导你。<span id=\"more\"></span> <a href=\"http://img03.taobaocdn.com/imgextra/i3/809419769/TB210F4aVXXXXa1XXXXXXXXXXXX_!!809419769.jpg\"><img src=\"http://img03.taobaocdn.com/imgextra/i3/809419769/TB210F4aVXXXXa1XXXXXXXXXXXX_!!809419769.jpg\" alt=\"艾瑞可erik\"></a> 说多了都是泪啊，百度统计网站响应测试，刚开始很让人头疼的。出现js、css要合并，外调的图片域名要合并，网站缓存响应时间要设置……问题多多啊 <a href=\"http://img03.taobaocdn.com/imgextra/i4/809419769/TB2eRx0aVXXXXXWXpXXXXXXXXXX_!!809419769.png\"><img src=\"http://img03.taobaocdn.com/imgextra/i4/809419769/TB2eRx0aVXXXXXWXpXXXXXXXXXX_!!809419769.png\" alt=\"木木夕\"></a> 既然有这么问题那就解决吧，干看着没用啊。先上百度找找，忙活了一阵子发现百度不靠谱，好多人都没弄。怎么办呢？ 先从合并css开始吧。百度统计提示的是你代码里面有多个css文件（我的是2个）,在后台外观-编辑-header.php文件里并没有这些css文件,查查资料才知道是&lt;?php  wp<em>head(); &gt;输出的。怎么办呢，反复想想有结果了。 我先去网站首页查看源文件 [![木木夕](<a href=\"http://img03.taobaocdn.com/imgextra/i4/809419769/TB2.V40aVXXXXXyXpXXXXXXXXXX\">http://img03.taobaocdn.com/imgextra/i4/809419769/TB2.V40aVXXXXXyXpXXXXXXXXXX</a></em>!!809419769.png)](<a href=\"http://img03.taobaocdn.com/imgextra/i4/809419769/TB2.V40aVXXXXXyXpXXXXXXXXXX_!!809419769.png\">http://img03.taobaocdn.com/imgextra/i4/809419769/TB2.V40aVXXXXXyXpXXXXXXXXXX_!!809419769.png</a>) 源文件把所有的代码都解析出来了这个好啊，我们回头把header.php文件中的&lt;?php  wp_head(); &gt;注释掉，根据上下代码寻找衔接，把源文件输出替换&lt;?php  wp_head(); &gt;的代码复制粘贴到header.php中相对应的位置。然后，就会找到对应要合并css文件，同时也找到对应要合并的js文件。我们先注释其中的一个，留另外一个做调用（script貌似注释不了，只能先粘贴复制到本地文件，以防出错好恢复。），更新文件header.php。用ftp链接服务器找到对应文件。例如，我这边是style.cc和960.css，jquery.js和jquery-migrate.min.js要合并，我先找到这写文件对应的地方，下载到本地先做备份（注意jquery所在的文件夹文件较多，看仔细些）。我把960.css里面的代码粘贴复制到style.css里面，同时，注释掉header.php文件的连接路径（注意960.css文件不要删掉，因为还有其他地方在调用）。同理也把js文件合并。最后清理一下网站缓存（如果你装了缓存插件就要清楚缓存），然后在清理一下浏览器缓存，然后用百度统计测评一下会发现响应速度加分了。 <a href=\"http://img03.taobaocdn.com/imgextra/i3/809419769/TB2LAx1aVXXXXcFXXXXXXXXXXXX_!!809419769.png\"><img src=\"http://img03.taobaocdn.com/imgextra/i3/809419769/TB2LAx1aVXXXXcFXXXXXXXXXXXX_!!809419769.png\" alt=\"木木夕\"></a> <a href=\"http://img03.taobaocdn.com/imgextra/i2/809419769/TB2bEV0aVXXXXXEXpXXXXXXXXXX_!!809419769.png\"><img src=\"http://img03.taobaocdn.com/imgextra/i2/809419769/TB2bEV0aVXXXXXEXpXXXXXXXXXX_!!809419769.png\" alt=\"木木夕\"></a> 接下来还没完，因为还有域名要合并。在百度上搜到的答案是说域名是没办法合并的，都是外调别人的。有的还说你得有顶级域名才能合并，反正我对这些人无语了。 <a href=\"http://img03.taobaocdn.com/imgextra/i4/809419769/TB2daR5aVXXXXa9XXXXXXXXXXXX_!!809419769.png\"><img src=\"http://img03.taobaocdn.com/imgextra/i4/809419769/TB2daR5aVXXXXa9XXXXXXXXXXXX_!!809419769.png\" alt=\"木木夕\"></a> 外调图片是没办法的，空间不大，图片占得容量太大了，只有外调。笔者在建站时一直考虑这个问题，后来解决了。因为有做过淘宝，便有个淘宝图片空间，可以调外链。百度统计提示域名合并就是img03.taobaocdn.com和img04.taobaocdn.com就前面的不一样，把前面的改成一样的试试，结果还真有效果，不影响图片输出。合并域名就这样解决了，同理我调用360的友情链接和安全检测验证也是用这样的方法，刷新缓存重新测试，就没有要合并域名的情况了。 <a href=\"http://img03.taobaocdn.com/imgextra/i2/809419769/TB2UIh1aVXXXXcVXXXXXXXXXXXX_!!809419769.jpg\"><img src=\"http://img03.taobaocdn.com/imgextra/i2/809419769/TB2UIh1aVXXXXcVXXXXXXXXXXXX_!!809419769.jpg\" alt=\"木木夕\"></a> 笔者在这是想说有些事真的是你自己去尝试了才知道有更好的办法解决，刚开始虽然是百度，但是你自己试试就知道结果会是怎么样的。</p>\n",
            "tags": [
                "seo",
                "优化",
                "域名合并"
            ]
        },
        {
            "id": "https://erik.xyz/2014/10/21/apache-fu-wu-qi-duo-zhan-dian-pei-zhi/",
            "url": "https://erik.xyz/2014/10/21/apache-fu-wu-qi-duo-zhan-dian-pei-zhi/",
            "title": "apache服务器多站点配置",
            "date_published": "2014-10-21T10:24:00.000Z",
            "content_html": "<p>群里有网友说不知道phpstudy怎配置多站点，其实这个不难，我当初配置的不是集成环境，集成环境和不是集成环境都一样的配置 首先我们要找到apache配置文件 E:\\phpStudy\\Apache\\conf\\httpd.conf 然后打开文件查找httpd-vhosts.conf 于是我们查找到 <a href=\"http://www.erik.xyz/wp-content/uploads/2014/10/20141021175554.png\"><img src=\"http://www.erik.xyz/wp-content/uploads/2014/10/20141021175554-300x53.png\" alt=\"apache\"></a> <span id=\"more\"></span>去掉前面的# 然后按这个路径找到httpd-vhosts.conf文件并打开 找到这段 # # VirtualHost example: # Almost any Apache directive may go into a VirtualHost container. # The first VirtualHost section is used for all requests that do not # match a ServerName or ServerAlias in any <VirtualHost> block. # 看看前面有 NameVirtualHost <em>:80 如果没有就加上 然后找到 #&lt;VirtualHost </em>:80&gt; #    ServerAdmin webmaster@dummy-host.example.com #    DocumentRoot “/Apache24/docs/dummy-host.example.com” #    ServerName dummy-host.example.com #    ServerAlias www.dummy-host.example.com #    ErrorLog “logs/dummy-host.example.com-error.log” #    CustomLog “logs/dummy-host.example.com-access.log” common #</VirtualHost> #<VirtualHost *:80> #    ServerAdmin webmaster@dummy-host2.example.com #    DocumentRoot “/Apache24/docs/dummy-host2.example.com” #    ServerName dummy-host2.example.com #    ErrorLog “logs/dummy-host2.example.com-error.log” #    CustomLog “logs/dummy-host2.example.com-access.log” common #</VirtualHost> 去掉前面的#后，修改路径和域名 <a href=\"http://www.erik.xyz/wp-content/uploads/2014/10/s20141021181957.png\"><img src=\"http://www.erik.xyz/wp-content/uploads/2014/10/s20141021181957-300x207.png\" alt=\"虚拟站点配置\"></a> 到此结束，建议最好用独立配置，别用集成环境，集成环境配置的东西太多容易冲突出错，此方法仅限在服务器上运行，本地运行没测试过，目前不清楚。</p>\n",
            "tags": [
                "php服务器",
                "centos",
                "linux"
            ]
        }
    ]
}