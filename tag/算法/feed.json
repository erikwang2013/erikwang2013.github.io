{
    "version": "https://jsonfeed.org/version/1",
    "title": "艾瑞可erik • All posts by \"算法\" tag • All posts by \"undefined\" categories",
    "description": "一只PHP开发的程序猿，偶尔做做运维、Goland、Python、Java、摄影、画画、写作、顺便睡觉，反正整站都搞过。",
    "home_page_url": "https://erik.xyz",
    "items": [
        {
            "id": "https://erik.xyz/2024/03/19/randomization/",
            "url": "https://erik.xyz/2024/03/19/randomization/",
            "title": "数据随机化算法",
            "date_published": "2024-03-19T15:06:00.000Z",
            "content_html": "<p>开发卡牌游戏或者匹配游戏等等，需要重新洗牌或重新更换位置，这就需要清洗数据。那么就以最常见的扑克牌为例，来一个数据随机化算法。<br><span id=\"more\"></span><br>直接上代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> function new_rand($arr)&#123;</span><br><span class=\"line\">    $len=count($arr);</span><br><span class=\"line\">    $new_arr=[];</span><br><span class=\"line\">    for($i=0;$i&lt;$len;$i++)&#123;</span><br><span class=\"line\">        $new_arr[mt_rand()]=$arr[$i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ksort($new_arr);</span><br><span class=\"line\">    return array_values($new_arr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$arr=[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,</span><br><span class=\"line\">17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,</span><br><span class=\"line\">33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,</span><br><span class=\"line\">49,50,51,52,53,54];</span><br><span class=\"line\">echo &quot;原始结果&quot;.PHP_EOL;</span><br><span class=\"line\">print_r(json_encode($arr));</span><br><span class=\"line\">$get_arr=new_rand($arr);</span><br><span class=\"line\">echo PHP_EOL.&quot;最终结果&quot;.PHP_EOL;</span><br><span class=\"line\">print_r(json_encode($get_arr));</span><br></pre></td></tr></table></figure>\n<p>最终结果如图：<br><img src=\"/img/2024/20240319223317.png\" alt=\"erik.xyz\"></p>\n",
            "tags": [
                "算法",
                "数据随机化"
            ]
        },
        {
            "id": "https://erik.xyz/2023/07/01/new-year-read-moeny/",
            "url": "https://erik.xyz/2023/07/01/new-year-read-moeny/",
            "title": "红包算法",
            "date_published": "2023-07-01T14:27:00.000Z",
            "content_html": "<p>红包算法<br>给定具体人数和金额，所有人都有，所有人的金额都是随机。那么，在分配中就要限定最大额度不能超过平局值，最小额度1分，算法如下：</p>\n<span id=\"more\"></span>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">function moneyBag($number, $money,  $min = 1)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    $max = intval($money / $number);</span><br><span class=\"line\">    for ($i = 0; $i &lt; $number; $i++) &#123;</span><br><span class=\"line\">        if ($number - 1 == $i) &#123;</span><br><span class=\"line\">            $end_arr = $money;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            $one_money =mt_rand($min, $max);</span><br><span class=\"line\">            $end_arr = $one_money;</span><br><span class=\"line\">            $money -= $end_arr;</span><br><span class=\"line\">            $max = intval($money / ($number-($i+1)));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        yield $end_arr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$last_arr = moneyBag(1000, 10 * 100);</span><br><span class=\"line\">$arr = [];</span><br><span class=\"line\">foreach ($last_arr as $end) &#123;</span><br><span class=\"line\">    var_dump(bcdiv($end, 100, 2));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>最终结果如下：<br><img src=\"/img/202306/20230701223119.png\" alt=\"https://erik.xyz\"></p>\n",
            "tags": [
                "算法",
                "红包算法"
            ]
        },
        {
            "id": "https://erik.xyz/2020/01/29/review-points/",
            "url": "https://erik.xyz/2020/01/29/review-points/",
            "title": "算法、数据结构、线性结构、栈、队列",
            "date_published": "2020-01-29T14:46:00.000Z",
            "content_html": "<h3 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h3><p>1.算法的基本特征</p>\n<ul>\n<li>可行性<ul>\n<li>步骤实现，执行结果达到预期<ul>\n<li>确定性</li>\n</ul>\n</li>\n<li>步骤明确<ul>\n<li>有穷性</li>\n</ul>\n</li>\n<li>有限的时间完成<ul>\n<li>拥有足够的情报</li>\n</ul>\n</li>\n<li>拥有足够的输入信息和初始化信息<span id=\"more\"></span>\n</li>\n</ul>\n</li>\n</ul>\n<p>2.算法的复杂度</p>\n<ul>\n<li>时间复杂度<ul>\n<li>执行算法所需要的计算工作量</li>\n</ul>\n</li>\n<li>空间复杂度<ul>\n<li>执行算法所需要的内存空间</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><ol>\n<li>定义：有关联的数据元素的集合就是数据结构。</li>\n</ol>\n<ul>\n<li>数据结构的概念<ul>\n<li>根节点<ul>\n<li>没有前件的节点</li>\n</ul>\n</li>\n<li>终端节点<ul>\n<li>没有后件的节点</li>\n</ul>\n</li>\n<li>内部节点<ul>\n<li>除了根节点和终端节点以外的节点</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"线性结构与非线性结构\"><a href=\"#线性结构与非线性结构\" class=\"headerlink\" title=\"线性结构与非线性结构\"></a>线性结构与非线性结构</h3><p>1.线性结构</p>\n<ul>\n<li>有且只有一个根节点</li>\n<li>每个节点最多只有一个前件，也最多只有一个后件</li>\n</ul>\n<p>2.非线性结构：不满足线性结构的两个条件就是非线性结构</p>\n<ul>\n<li>树形结构</li>\n<li>网状结构</li>\n</ul>\n<h3 id=\"线性表\"><a href=\"#线性表\" class=\"headerlink\" title=\"线性表\"></a>线性表</h3><p>1.线性结构也被称为线性表</p>\n<p>2.非空线性表</p>\n<ul>\n<li>只有一个根节点</li>\n<li>有且只有一个终端节点</li>\n<li>除根节点与终端节点外，其他所有节点有且只有一个前件，也有且只有一个后件</li>\n</ul>\n<h3 id=\"线性表的顺序存储\"><a href=\"#线性表的顺序存储\" class=\"headerlink\" title=\"线性表的顺序存储\"></a>线性表的顺序存储</h3><p>1.定义：线性表的顺序存储是将线性表中的元素一个接一个地存储在一片相邻的存储区域中，这种线性表也叫顺序表</p>\n<p>2.顺序表特征</p>\n<ul>\n<li>线性表中所有元素所占的存储空间是连续的</li>\n<li>线性表中各数据元素在存储空间中是按逻辑顺序依次存放的</li>\n</ul>\n<h3 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h3><p>1.定义：栈是一种特殊的线性表，它所有的插入与删除都限定在表的同一端进行，允许插入与删除的一端称为栈顶，不允许插入与删除的另一端称为栈底。当栈中没有元素时，称为空栈。</p>\n<p>2.栈的修改原则是后进先出或先进后出</p>\n<p>3.栈的基本运算： 入栈、退栈、读栈顶元素</p>\n<h3 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h3><p>1.定义：允许在一端进行插入，而在另一端进行删除的线性表</p>\n<p>2.允许进行删除运算的一端称为队头，允许进行插入运算的一端称为队尾</p>\n<h3 id=\"顺序表和链表的对比\"><a href=\"#顺序表和链表的对比\" class=\"headerlink\" title=\"顺序表和链表的对比\"></a>顺序表和链表的对比</h3><p>1.顺序表</p>\n<ul>\n<li>优点<ul>\n<li>可随机存取表中的任意节点</li>\n<li>无需为表示节点间的逻辑关系额外增加存储空间</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>顺序表的插入和删除运算效率很低</li>\n<li>顺序表的存储空间不便扩充</li>\n<li>顺序表不便于对存储空间的动态分配</li>\n</ul>\n</li>\n</ul>\n<p>2.链表</p>\n<ul>\n<li>优点<ul>\n<li>在进行插入和删除运算时，只需要改变指针即可，不需要移动元素</li>\n<li>链表的存储空间易于扩充并且方便空间的动态分配</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li>需要额外的空间来表示数据元素之间的逻辑关系，存储密度比顺序表低</li>\n</ul>\n</li>\n<li><p>链表类型</p>\n<ul>\n<li>单向链表<ul>\n<li>链表的链接方向是单向的，对链表的访问要通过顺序读取从头部开始，链表是使用指针进行构造的列表；又称为结点列表</li>\n<li>单个结点创建非常方便，普通的线性内存通常在创建的时候就需要设定数据的大小</li>\n<li>结点的删除非常方便，不需要像线性结构那样移动剩下的数据</li>\n<li>结点的访问方便，可以通过循环或者递归的方法访问到任意数据，但是平均的访问效率低于线性表</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>双向链表</p>\n<ul>\n<li>每个数据结点中都有两个指针，分别指向直接后继和直接前驱。双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点</li>\n</ul>\n</li>\n<li><p>环形链表</p>\n<ul>\n<li>最后一个结点指向头结点，形成一个环。从循环链表中的任何一个结点出发都能找到任何其他结点</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "算法",
                "队列",
                "栈",
                "顺序表",
                "链表",
                "数据结构",
                "线性结构"
            ]
        },
        {
            "id": "https://erik.xyz/2019/07/22/ren-yi-jin-e-fen-pei-de-saun-fa/",
            "url": "https://erik.xyz/2019/07/22/ren-yi-jin-e-fen-pei-de-saun-fa/",
            "title": "关于任意金额分配10元、5元、2元的算法",
            "date_published": "2019-07-22T12:14:00.000Z",
            "content_html": "<p>今天去一家做电商的公司面试，笔试题有个算法，如下：</p>\n<p>输入任意金额，计算分配出10元、5元、2元是否可以分配，如果可以分别分配几张。</p>\n<p>根据需求可知优先分配最高金额，根据最高金额计算出分配值，然后取整数。<span id=\"more\"></span>再用输入金额减去最高金额计算出的整数乘以最高金额，得出余额。一开始我想的是分别计算，嵌套多层if else后来发现不是很友好，还越来越乱。再加上是在a4纸上手写代码，很烦躁。</p>\n<p>晚上回家花了半个小时思索，写了这样的。</p>\n<pre><code>function findMoney($money = 0)\n&#123;\n    $no_text = &quot;不能找回金额为&quot; . $money . &quot;的零钱。&quot;;\n    $text = &quot;可以找回金额为&quot; . $money . &quot;的零钱,其中&quot;;\n    if ($money &lt;= 0) &#123;\n        echo $no_text;\n    &#125;\n    $rand = [10, 5, 2];\n    for ($i = 0; $i &lt; count($rand); $i++) &#123;\n        if ($rand[$i] &gt; 0) &#123;\n            $number = floor($money / $rand[$i]);\n            $money = $money - $number * $rand[$i];\n            $text .= &quot;面额&quot; . $rand[$i] . &quot;元的&quot; . $number . &quot;张&quot; . &quot;,&quot;;\n            if ($money == 1) &#123;\n                echo $no_text . PHP_EOL;\n                exit;\n            &#125;\n        &#125;\n    &#125;\n    echo $text . PHP_EOL;\n&#125;\nfindMoney(16);\n</code></pre><p><img src=\"/img/201907/2019-07-23_00-06.png\" alt=\"\"></p>\n<p>今天周二，昨晚弄得比较晚，急着睡。下午又想了想感觉不对。<br>输入6或者8的时候并不能分配。<br>对昨天的代码优化一番。</p>\n<p>如下</p>\n<pre><code>function findMoney($money = 0)\n&#123;\n    $no_text = &quot;不能找回金额为&quot; . $money . &quot;的零钱。&quot;;\n    $text = &quot;可以找回金额为&quot; . $money . &quot;的零钱,其中&quot;;\n    if ($money &lt;= 0) &#123;\n        echo $no_text;\n    &#125;\n    $rand = [10, 5, 2];\n    for ($i = 0; $i &lt; count($rand); $i++) &#123;\n        if ($rand[$i] &gt; 0) &#123;\n            $number = floor($money / $rand[$i]);\n            $money = $money - $number * $rand[$i];\n            $text .= &quot;面额&quot; . $rand[$i] . &quot;元的&quot; . $number . &quot;张&quot; . &quot;,&quot;;\n            if ($money == 1) &#123;\n                echo $no_text . PHP_EOL;\n                exit;\n            &#125;\n        &#125;\n    &#125;\n    echo $text . PHP_EOL;\n&#125;\nfindMoney(16);\n</code></pre><p>后续改进</p>\n<p>如下</p>\n<pre><code>function findMoney($money = 0)\n&#123;\n    //print_r($money);exit;\n    $no_text = &quot;不能找回金额为&quot; . $money . &quot;的零钱。&quot;;\n    $text = &quot;可以找回金额为&quot; . $money . &quot;的零钱,其中&quot;;\n    if ($money &lt;= 0) &#123;\n        echo $no_text;\n    &#125;\n    $rand = [10, 5, 2];\n    $number = 0;\n    for ($i = 0; $i &lt; count($rand); $i++) &#123;\n        if (isset($rand[$i])) &#123;\n            //不能整除的情况\n            if (is_float($money / $rand[$i])) &#123;\n                $number = $money / $rand[$i];\n                if ($money &gt; 0 &amp;&amp; $rand[$i] == 5 &amp;&amp; ceil($number) != $number) &#123;\n                    $text .= &quot;面额&quot; . $rand[$i] . &quot;元的0张&quot; . &quot;,&quot;;\n                    $text .= getChildMoney($money);\n                &#125;else&#123;\n                    $number = is_float($number) == 1 ? floor($number) : $number;\n                    $money = $money - $number * $rand[$i];\n                    $text .= &quot;面额&quot; . $rand[$i] . &quot;元的&quot; . $number . &quot;张&quot; . &quot;,&quot;;\n                &#125;\n            &#125; else &#123;\n                $number = $money / $rand[$i];\n                $money = $money - $number * $rand[$i];\n                $text .= &quot;面额&quot; . $rand[$i] . &quot;元的&quot; . $number . &quot;张&quot; . &quot;,&quot;;\n                if ($money == 0) &#123;\n                    continue;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    if ($money &gt; 0) &#123;\n        echo $no_text . PHP_EOL;\n    &#125; else &#123;\n        echo $text . PHP_EOL;\n    &#125;\n&#125;\n\nfunction getChildMoney($money = 0)\n&#123;\n    $number = $money / 2;\n    if (is_float($number)) &#123;\n        return false;\n    &#125;\n    $text = &quot;面额&quot; . $money . &quot;元的&quot; . $number . &quot;张&quot; . &quot;,&quot;;\n    return $text;\n&#125;\n\nfindMoney(34);\n</code></pre><p>这样就是任意金额<br><img src=\"/img/201907/2019-07-23_20-09.png\" alt=\"\"></p>\n",
            "tags": [
                "算法",
                "任意金额输入",
                "10元、5元、2元"
            ]
        },
        {
            "id": "https://erik.xyz/2019/07/11/xue-hua-suan-fa-snoflake/",
            "url": "https://erik.xyz/2019/07/11/xue-hua-suan-fa-snoflake/",
            "title": "雪花算法snoflake",
            "date_published": "2019-07-11T11:13:00.000Z",
            "content_html": "<p>开发的大多数项目并未接触到百万级并发，但是一直以来有个id生成的纠结。我一般就是年月日+随机数生成唯一id,一般来说生成一个备用随机数据，不重复每次一次取值隔天重新从第一个开始取。虽然是可以解决，总感觉这个有点繁琐，仔细查查资料研究了一下，<span id=\"more\"></span>在<a href=\"https://blog.csdn.net/hero272285642/article/details/79168601z\">这里</a>有提到uuid、Vesta、Twitter-Snowflake等。从文章中uuid在php中已经有专门的扩展或者写法生成唯一字符串在大并发数据中处理效率还是不够好。其他几中方法有用到数据库……<br>  这对雪花算法我查了查资料发现还是值得操作一番。</p>\n<p>雪花算法的基本描述</p>\n<pre><code>1.最高位是符号位，始终为0，不可用。 2.41位的时间序列，精确到毫秒级，41位的长度可以使用69年。时间位还有一个很重要的作用是可以根据时间进行排序。3.10位的机器标识，10位的长度最多支持部署1024个节点。4.12位的计数序列号，序列号即一系列的自增id，可以支持同一节点同一毫秒生成多个ID序号，12位的计数序列号支持每个节点每毫秒产生4096个ID序号。\n</code></pre><p>根据以上描述及参考<a href=\"https://blog.csdn.net/jerryyang_2017/article/details/80334580\">雪花算法及运用PHP</a>、<a href=\"https://blog.csdn.net/u013636118/article/details/91042838\">基于php的雪花算法</a>等内容我的本地测试<br>代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class snowflake</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   const EPOCH_OFFSET = 0; //偏移时间戳</span><br><span class=\"line\">   const SIGN = 1;  //最高位树，始终为0，不可用</span><br><span class=\"line\">   const TIMESTAMP = 41;  //时间戳位数   默认41位，可以使用69年</span><br><span class=\"line\">   const DATA_CENTER = 5;  //IDC编号位数  最多32个节点</span><br><span class=\"line\">   const MACHINE_ID = 5;  //机器编号位数  最多32个节点</span><br><span class=\"line\">   const SEQUENCE = 12;  //计数序列号位数，即一系列自增id 每个节点每毫秒产生4096个ID序列</span><br><span class=\"line\"></span><br><span class=\"line\">   protected $data_center_id; //数据中心编号</span><br><span class=\"line\"></span><br><span class=\"line\">   protected $unix_id;  //机器编号</span><br><span class=\"line\"></span><br><span class=\"line\">   protected $last_time = null;  //最后一次生成id使用的时间戳</span><br><span class=\"line\"></span><br><span class=\"line\">   protected $serial = 1;</span><br><span class=\"line\">   protected $sign_left_shift = self::TIMESTAMP + self::DATA_CENTER + self::MACHINE_ID + self::SEQUENCE; //符号左位移</span><br><span class=\"line\">   protected $time_left_shift = self::DATA_CENTER + self::MACHINE_ID + self::SEQUENCE;  //时间戳左位移</span><br><span class=\"line\">   protected $data_center_left_shift = self::MACHINE_ID + self::SEQUENCE; //idc左位移</span><br><span class=\"line\">   protected $unix_left_shift = self::SEQUENCE;   //机器编号左位移位数</span><br><span class=\"line\">   protected $max_serial = -1 ^ (-1 &lt;&lt; self::SEQUENCE);  //最大序列号</span><br><span class=\"line\">   protected $max_unix = -1 ^ (-1 &lt;&lt; self::MACHINE_ID); //最大机器编号</span><br><span class=\"line\">   protected $max_data_center = -1 ^ (-1 &lt;&lt; self::DATA_CENTER); //最大数据中心编号</span><br><span class=\"line\"></span><br><span class=\"line\">   public function __construct($data_center_id, $unix_id)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       if ($data_center_id &gt; $this-&gt;max_data_center) &#123;</span><br><span class=\"line\">           throw new Exception(&#x27;数据中心编号取值错误，取值范围为：0-&#x27; . $this-&gt;max_data_center);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       if ($unix_id &gt; $this-&gt;max_unix) &#123;</span><br><span class=\"line\">           throw new Exception(&#x27;机器编号取值错误，取值范围为：0-&#x27; . $this-&gt;max_unix);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       $this-&gt;data_center_id = $data_center_id;</span><br><span class=\"line\">       $this-&gt;unix_id = $unix_id;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   public function generateId()</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       $sign = 0;</span><br><span class=\"line\">       $unix_time = $this-&gt;getUnixTime();</span><br><span class=\"line\">       //判断时间戳</span><br><span class=\"line\">       if ($unix_time &lt; $this-&gt;last_time) &#123;</span><br><span class=\"line\">           throw new Exception(&#x27;当前时间不能小于最后一次时间！&#x27;);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       if ($unix_time == $this-&gt;last_time) &#123;</span><br><span class=\"line\">           $serial = ++$this-&gt;serial;</span><br><span class=\"line\">           if ($serial == $this-&gt;max_serial) &#123;</span><br><span class=\"line\">               $unix_time = $this-&gt;getUnixTime();</span><br><span class=\"line\">               while ($unix_time &lt;= $this-&gt;last_time) &#123;</span><br><span class=\"line\">                   $unix_time = $this-&gt;getUnixTime();</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               $this-&gt;serial = 0;</span><br><span class=\"line\">               $serial = ++$this-&gt;serial;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125; else &#123;</span><br><span class=\"line\">           $this-&gt;serial = 0;</span><br><span class=\"line\">           $serial = ++$this-&gt;serial;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       $this-&gt;last_time = $unix_time;</span><br><span class=\"line\">       $time = (int)($unix_time - self::EPOCH_OFFSET);</span><br><span class=\"line\">       $id = ($sign &lt;&lt; $this-&gt;sign_left_shift) | ($time &lt;&lt; $this-&gt;time_left_shift)</span><br><span class=\"line\">           | ($this-&gt;data_center_id &lt;&lt; $this-&gt;data_center_left_shift)</span><br><span class=\"line\">           | ($this-&gt;unix_id &lt;&lt; $this-&gt;unix_left_shift) | $serial;</span><br><span class=\"line\">       return $id;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   public function getUnixTime()</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       return floor(microtime(true) * 1000);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$data=new snowflake(1,1);</span><br><span class=\"line\">$get_id=$data-&gt;generateId();</span><br><span class=\"line\"></span><br><span class=\"line\">echo $get_id.PHP_EOL;</span><br></pre></td></tr></table></figure>",
            "tags": [
                "算法",
                "生成唯一id",
                "生成id"
            ]
        },
        {
            "id": "https://erik.xyz/2019/03/20/php-hong-bao-suan-fa/",
            "url": "https://erik.xyz/2019/03/20/php-hong-bao-suan-fa/",
            "title": "php红包算法",
            "date_published": "2019-03-20T04:28:00.000Z",
            "content_html": "<p>今天去参见一个面试，结尾时，面试官问了个红包如何随机分配实现问题。这个确实没搞过，也想不出来。回头自己研究了一下，发现也就这么回事。。<span id=\"more\"></span></p>\n<p>参考文章 <a href=\"https://www.cnblogs.com/dreign/p/4610766.html\">https://www.cnblogs.com/dreign/p/4610766.html</a><br>得到一个正态分布的方法，反复比较其他几种，最后选择了这个。<br>分析一下需求如下：</p>\n<blockquote>\n</blockquote>\n<p> 一个用户发100元红包，分成100份。那么每份金额随机。而分成100份的金额之和刚好等于100元。那首先每个用户至少分到0.01元红包，那每个用户分得最大红包是总金额减去分出去用户的金额，剩余用户的平均金额。<br> 由此，便清晰了。那每取一个随机金额肯定在最小金额和最大金额之间。</p>\n<p>上代码试试。</p>\n<blockquote>\n</blockquote>\n<p>假如有100元要分给100个人，100个红包随机生成。代码如下：</p>\n<p><img src=\"https://erik.xyz/wp-content/uploads/2019/2019-04-23_160135.jpg\" alt=\"\"></p>\n<blockquote>\n<p>输出结果</p>\n</blockquote>\n<p><img src=\"https://erik.xyz/wp-content/uploads/2019/2019-04-23_162419.jpg\" alt=\"\"></p>\n",
            "tags": [
                "算法",
                "php随机数"
            ]
        },
        {
            "id": "https://erik.xyz/2018/04/11/fu-li-ye-bian-he-la-pu-si-bian-de-wu-li-jie-shi-ji-qu-bie/",
            "url": "https://erik.xyz/2018/04/11/fu-li-ye-bian-he-la-pu-si-bian-de-wu-li-jie-shi-ji-qu-bie/",
            "title": "傅里叶变换和拉普拉斯变换的物理解释及区别",
            "date_published": "2018-04-11T11:07:00.000Z",
            "content_html": "<blockquote>\n<p>傅里叶变换在物理学、数论、组合数学、信号处理、概率论、统计学、密码学、声学、光学、海洋学、结构动力学等领域都有着广泛的应用（例如在信号处理中，傅里叶变换的典型用途是将信号分解成幅值分量和频率分量）。<span id=\"more\"></span></p>\n</blockquote>\n<p>傅里叶变换能将满足一定条件的某个函数表示成三角函数（正弦和/或余弦函数）或者它们的积分的线性组合。在不同的研究领域，傅里叶变换具有多种不同的变体形式，如连续傅里叶变换和离散傅里叶变换。 </p>\n<blockquote>\n</blockquote>\n<p>傅里叶变换是一种解决问题的方法，一种工具，一种看待问题的角度。理解的关键是：一个连续的信号可以看作是一个个小信号的叠加，从时域叠加与从频域叠加都可以组成原来的信号，将信号这么分解后有助于处理。 </p>\n<blockquote>\n</blockquote>\n<p>我们原来对一个信号其实是从时间的角度去理解的，不知不觉中，其实是按照时间把信号进行分割，每一部分只是一个时间点对应一个信号值，一个信号是一组这样的分量的叠加。</p>\n<blockquote>\n</blockquote>\n<p>傅里叶变换后，其实还是个叠加问题，只不过是从频率的角度去叠加，只不过每个小信号是一个时间域上覆盖整个区间的信号，但他确有固定的周期，或者说，给了一个周期，我们就能画出一个整个区间上的分信号，那么给定一组周期值（或频率值），我们就可以画出其对应的曲线，就像给出时域上每一点的信号值一样，不过如果信号是周期的话 ，频域的更简单，只需要几个甚至一个就可以了，时域则需要整个时间轴上每一点都映射出一个函数值。 </p>\n<blockquote>\n<p>傅里叶变换就是将一个信号的时域表示形式映射到一个频域表示形式；逆傅里叶变换恰好相反。这都是一个信号的不同表示形式。它的公式会用就可以，当然把证明看懂了更好。</p>\n</blockquote>\n<p>对一个信号做傅里叶变换，可以得到其频域特性，包括幅度和相位两个方面。幅度是表示这个频率分量的大小，那么相位呢，它有什么物理意义？频域的相位与时域的相位有关系吗？信号前一段的相位（频域）与后一段的相位的变化是否与信号的频率成正比关系。 傅里叶变换就是把一个信号，分解成无数的正弦波（或者余弦波）信号。也就是说，用无数的正弦波，可以合成任何你所需要的信号。 </p>\n<blockquote>\n</blockquote>\n<p>想一想这个问题：给你很多正弦信号，你怎样才能合成你需要的信号呢？答案是要两个条件，一个是每个正弦波的幅度，另一个就是每个正弦波之间的相位差。所以现在应该明白了吧，频域上的相位，就是每个正弦波之间的相位。 傅里叶变换用于信号的频率域分析，一般我们把电信号描述成时间域的数学模型，而数字信号处理对信号的频率特性更感兴趣，而通过傅立叶变换很容易得到信号的频率域特性。</p>\n<blockquote>\n</blockquote>\n<p>傅里叶变换简单通俗理解就是把看似杂乱无章的信号考虑成由一定振幅、相位、频率的基本正弦（余弦）信号组合而成，傅里叶变换的目的就是找出这些基本正弦（余弦）信号中振幅较大（能量较高）信号对应的频率，从而找出杂乱无章的信号中的主要振动频率特点。如减速机故障时，通过傅里叶变换做频谱分析，根据各级齿轮转速、齿数与杂音频谱中振幅大的对比，可以快速判断哪级齿轮损伤。 </p>\n<blockquote>\n</blockquote>\n<p>拉普拉斯变换，是工程数学中常用的一种积分变换。它是为简化计算而建立的实变量函数和复变量函数间的一种函数变换。对一个实变量函数作拉普拉斯变换，并在复数域中作各种运算，再将运算结果作拉普拉斯反变换来求得实数域中的相应结果，往往比直接在实数域中求出同样的结果在计算上容易得多。拉普拉斯变换的这种运算步骤对于求解线性微分方程尤为有效，它可把微分方程化为容易求解的代数方程来处理，从而使计算简化。在经典控制理论中，对控制系统的分析和综合，都是建立在拉普拉斯变换的基础上的。 </p>\n<blockquote>\n</blockquote>\n<p>引入拉普拉斯变换的一个主要优点，是可采用传递函数代替微分方程来描述系统的特性。这就为采用直观和简便的图解方法来确定控制系统的整个特性（见信号流程图、动态结构图）、分析控制系统的运动过程（见奈奎斯特稳定判据、根轨迹法），以及综合控制系统的校正装置（见控制系统校正方法）提供了可能性。</p>\n<blockquote>\n<p>拉普拉斯变换在工程学上的应用：应用拉普拉斯变换解常变量齐次微分方程，可以将微分方程化为代数方程，使问题得以解决。</p>\n</blockquote>\n<p>在工程学上，拉普拉斯变换的重大意义在于：将一个信号从时域上，转换为复频域（s域）上来表示；在线性系统，控制自动化上都有广泛的应用。 在数字信号处理中，Z变换是一种非常重要的分析工具。但在通常的应用中，我们往往只需要分析信号或系统的频率响应，也即是说通常只需要进行傅里叶变换即可。那么，为什么还要引进Z变换呢？ Z变换和傅里叶变换之间有存在什么样的关系呢？傅里叶变换的物理意义非常清晰：将通常在时域表示的信号，分解为多个正弦信号的叠加。每个正弦信号用幅度、频率、相位就可以完全表征。</p>\n<blockquote>\n</blockquote>\n<p>傅里叶变换之后的信号通常称为频谱，频谱包括幅度谱和相位谱，分别表示幅度随频率的分布及相位随频率的分布。在自然界，频率是有明确的物理意义的，比如说声音信号，男同胞声音低沉雄浑，这主要是因为男声中低频分量更多；女同胞多高亢清脆，这主要是因为女声中高频分量更多。 </p>\n<blockquote>\n</blockquote>\n<p>对一个信号来说，就包含的信息量来讲，时域信号及其相应的傅里叶变换之后的信号是完全一样的。那傅里叶变换有什么作用呢？因为有的信号主要在时域表现其特性，如电容充放电的过程；而有的信号则主要在频域表现其特性，如机械的振动，人类的语音等。若信号的特征主要在频域表示的话，则相应的时域信号看起来可能杂乱无章，但在频域则解读非常方便。</p>\n<blockquote>\n<p>在实际中，当我们采集到一段信号之后，在没有任何先验信息的情况下，直觉是试图在时域能发现一些特征，如果在时域无所发现的话，很自然地将信号转换到频域再看看能有什么特征。信号的时域描述与频域描述，就像一枚硬币的两面，看起来虽然有所不同，但实际上都是同一个东西。正因为如此，在通常的信号与系统的分析过程中，我们非常关心傅里叶变换。</p>\n</blockquote>\n<p>既然人们只关心信号的频域表示，那么Z变换又是怎么回事呢？要说到Z变换，可能还要先追溯到拉普拉斯变换。拉普拉斯变换是以法国数学家拉普拉斯命名的一种变换方法，主要是针对连续信号的分析。拉普拉斯和傅里叶都是同时代的人，他们所处的时代在法国是处于拿破仑时代，国力鼎盛。在科学上也取代英国成为当时世界的中心，在当时众多的科学大师中，拉普拉斯、拉格朗日、傅里叶就是他们中间最为璀璨的三颗星。</p>\n<blockquote>\n</blockquote>\n<p>傅里叶关于信号可以分解为正弦信号叠加的论文，其评审人即包括拉普拉斯和拉格朗日。 回到正题，傅里叶变换虽然好用，而且物理意义明确，但有一个最大的问题是其存在的条件比较苛刻，比如时域内绝对可积的信号才可能存在傅里叶变换。拉普拉斯变换可以说是推广了这以概念。</p>\n<blockquote>\n</blockquote>\n<p>在自然界，指数信号exp(-x)是衰减最快的信号之一，对信号乘上指数信号之后，很容易满足绝对可积的条件。因此将原始信号乘上指数信号之后一般都能满足傅里叶变换的条件，这种变换就是拉普拉斯变换。这种变换能将微分方程转化为代数方程，在18世纪计算机还远未发明的时候，意义非常重大。 从上面的分析可以看出，傅里叶变换可以看做是拉普拉斯的一种特殊形式，即所乘的指数信号为exp(0)。</p>\n<blockquote>\n</blockquote>\n<p>也即是说拉普拉斯变换是傅里叶变换的推广，是一种更普遍的表达形式。在进行信号与系统的分析过程中，可以先得到拉普拉斯变换这种更普遍的结果，然后再得到傅里叶变换这种特殊的结果。这种由普遍到特殊的解决办法，已经证明在连续信号与系统的分析中能够带来很大的方便。</p>\n<blockquote>\n</blockquote>\n<p>Z变换可以说是针对离散信号和系统的拉普拉斯变换，由此我们就很容易理解Z变换的重要性，也很容易理解Z变换和傅里叶变换之间的关系。</p>\n<blockquote>\n</blockquote>\n<p>Z变换中的Z平面与拉普拉斯中的S平面存在映射的关系，z=exp(Ts)。在Z变换中，单位圆上的结果即对应离散时间傅里叶变换的结果。 本文来源于CSDN网kevinhg的博客</p>\n",
            "tags": [
                "转载",
                "算法"
            ]
        },
        {
            "id": "https://erik.xyz/2018/04/05/xiang-jie-quan-pai-lie-suan-fa/",
            "url": "https://erik.xyz/2018/04/05/xiang-jie-quan-pai-lie-suan-fa/",
            "title": "详解全排列算法",
            "date_published": "2018-04-05T11:07:00.000Z",
            "content_html": "<h5 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a><a href=\"#简介\" title=\"简介\"></a><strong>简介</strong></h5><p>给定 {1, 2, 3, , , n}，其全排列为 n! 个，这是最基础的高中组合数学知识。我们以 n=4 为例，其全部排列如下图（以字典序树形式来呈现）： <strong><img src=\"http://mmbiz.qpic.cn/mmbiz_jpg/QtPIxk7nOVeuubKtEibM6oB480VFniccK5af8JucQelsiaaZGdebJ5Tw2Fuzia4cyuX95Hl2iawtq6DFQoTTnv089WA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" alt=\"\"></strong> 我们很容易想到用递归来求出它的所有全排列。 仔细观察上图， 以 1 开头，下面跟着 {2, 3, 4} 的全排列； 以 2 开头，下面跟着 {1, 3, 4} 的全排列； 以 3 开头，下面跟着 {1, 2, 4} 的全排列； 以 4 开头，下面跟着 {1, 2, 3} 的全排列。<span id=\"more\"></span> <strong>代码如下：</strong></p>\n<blockquote>\n<p>/<em>* </em> <em> author : 刘毅（Limer） </em> date   : 2017-05-31 <em> mode   : C++ </em>/   #include<iostream> #include<algorithm>   using namespacestd;   voidFullPermutation(intarray[],intleft,intright) { if(left == right) { for(inti = 0;i &lt; 4;i++) cout &lt;&lt; array[i] &lt;&lt; “ “; cout &lt;&lt; endl; } else { for(inti = left;i &lt;= right;i++) { swap(array[i],array[left]); FullPermutation(array,left + 1,right); swap(array[i],array[left]); } } }   intmain() {   intarray[4] = {1,2,3,4};   FullPermutation(array,0,3);   return0; }</algorithm></iostream></p>\n</blockquote>\n<p><strong>运行如下：</strong> <strong><img src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"\"></strong> 咦~ 递归写出的全排列有点不完美，它并不严格遵循字典序。但是熟悉 C++ 的朋友肯定知道另一种更简单，更完美的全排列方法。 定义于文件 <algorithm> 内的两个算法函数： 1、next_permutation，对于当前的排列，如果在字典序中还存在下一个排列，返回真，并且把当前排列调整为下一个排列；如果不存在，就把当前排列调整为字典序中的第一个排列（即递增排列），返回假。 2、prev_permutation，对于当前的排列，如果在字典序中还存在上一个排列，返回真，并且把当前排列调整为上一个排列；如果不存在，就把当前排列调整为字典序中的最后一个排列（即递减排列），返回假。</algorithm></p>\n<blockquote>\n<p>/<em>* </em> <em> author : 刘毅（Limer） </em> date   : 2017-05-31 <em> mode   : C++ </em>/   #include<iostream> #include<algorithm>   using namespacestd;   voidFullPermutation(intarray[]) { do { for(inti = 0;i &lt; 4;i++) cout &lt;&lt; array[i] &lt;&lt; “ “; cout &lt;&lt; endl; }while(next_permutation(array,array + 4)); }   intmain() {   intarray[4] = {1,2,3,4};   FullPermutation(array);   return0; }</algorithm></iostream></p>\n</blockquote>\n<p>运行截图省略。输出结果正好符合字典序。 那这个 “轮子” 是怎么做的呢？（摘自侯捷的《STL 源码剖析》） 1、next_permutation，首先，从最尾端开始往前寻找两个相邻元素，令第一元素为<em>i，第二元素为</em>ii，且满足<em>i &lt; </em>ii，找到这样一组相邻元素后，再从最尾端开始往前检验，找出第一个大于<em>i的元素，令为</em>j，将 i，j 元素对调，再将 ii 之后的所有元素颠倒排列，此即所求之 “下一个” 排列组合。 2、prev_permutation，首先，从最尾端开始往前寻找两个相邻元素，令第一元素为<em>i，第二元素为</em>ii，且满足<em>i &gt; </em>ii，找到这样一组相邻元素后，再从最尾端开始往前检验，找出第一个小于<em>i的元素，令为</em>j，将 i，j 元素对调，再将 ii 之后的所有元素颠倒排列，此即所求之 “上一个” 排列组合。 <strong>代码如下：</strong></p>\n<blockquote>\n<p>boolnext<em>permutation(int <em> first,int </em> last) { if(first == last)returnfalse;// 空区间 int <em> i = first;     ++i; if(i == last)returnfalse;// 只有一个元素 i = last;     –i;   for(;;) { int </em> ii = i;         –i; if(_i &lt; <em>ii) { int </em> j = last; while(!(_i &lt; </em>–j))// 由尾端往前找，直到遇上比 <em>i 大的元素 ; swap(_i, _j); reverse(ii,last); returntrue; } }   if(i == first)// 当前排列为字典序的最后一个排列 { reverse(first,last);// 全部逆向排列，即为升序 returnfalse; } }   boolprev_premutation(int </em> first,int <em> last) { if(first == last)returnfalse;// 空区间 int </em> i = first;     ++i; if(i == last)returnfalse;// 只有一个元素 i = last;     –i;   for(;;) { int <em> ii = i;         –i; if(_i &gt; _ii) { int </em> j = last; while(!(<em>i &gt; </em>–j))// 由尾端往前找，直到遇上比 <em>i 大的元素 ; swap(_i, </em>j); reverse(ii,last); returntrue; } }   if(i == first)// 当前排列为字典序的第一个排列 { reverse(first,last);// 全部逆向排列，即为降序 returnfalse; } }</p>\n</blockquote>\n<p><strong>结后语</strong> 这篇文章主要介绍了解决不重复序列的全排列问题的两个方法：<strong>递归和字典序法</strong>。</p>\n",
            "tags": [
                "转载",
                "算法"
            ]
        },
        {
            "id": "https://erik.xyz/2016/03/07/php-suan-fa-he-di-gui/",
            "url": "https://erik.xyz/2016/03/07/php-suan-fa-he-di-gui/",
            "title": "PHP算法和递归",
            "date_published": "2016-03-07T14:32:00.000Z",
            "content_html": "<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php </span><br><span class=\"line\">header(&quot;Content-Type:text/html;charset=utf-8&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">$arr=array(1,12,53,14,5,16,7,18,91,10,11,120); //**冒泡排序** 小数往前放，大数往后放 </span><br><span class=\"line\"></span><br><span class=\"line\">function getpao($arr) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t$len=count($arr); //设置一个空数组 用来接收冒出来的泡 //该层循环控制 需要冒泡的轮数</span><br><span class=\"line\"></span><br><span class=\"line\">    for($i=1;$i&lt;$len;$i++) &#123; //该层循环用来控制每轮 冒出一个数 需要比较的次数 </span><br><span class=\"line\"></span><br><span class=\"line\">        for($k=0;$k&lt;$len-$i;$k++) &#123; </span><br><span class=\"line\"></span><br><span class=\"line\">          if($arr\\[$k\\]&gt;$arr\\[$k+1\\]) &#123; </span><br><span class=\"line\"></span><br><span class=\"line\">          $tmp=$arr\\[$k+1\\]; $arr\\[$k+1\\]=$arr\\[$k\\]; $arr\\[$k\\]=$tmp;</span><br><span class=\"line\"></span><br><span class=\"line\">          &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">return $arr;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//**选择排序** </span><br><span class=\"line\"></span><br><span class=\"line\">/\\* 每一趟从待排序的数据元素中选出最小（或最大）的一个元素， 顺序放在已排好序的数列的最后，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法 */ </span><br><span class=\"line\"></span><br><span class=\"line\">function select_sort($arr)&#123; </span><br><span class=\"line\"></span><br><span class=\"line\">for($i=0,$len=count($arr);$i&lt;$len-1;$i++)&#123; //假设最小值位置 $p=$i; //当前都和那些元素比较，$i后面的元素 </span><br><span class=\"line\"></span><br><span class=\"line\">    for($j=$i+1;$j&lt;$len;$j++)&#123; </span><br><span class=\"line\"></span><br><span class=\"line\">      if($arr\\[$p\\]&gt;$arr\\[$j\\])&#123; //比较发现更小的，记录最小值位置，并且在在下次比较时 </span><br><span class=\"line\"></span><br><span class=\"line\">      $p=$j; </span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">    &#125; //已确定最小值的位置，保存到$p中 </span><br><span class=\"line\"></span><br><span class=\"line\">    if($p != $i)&#123; </span><br><span class=\"line\">      $tmp=$arr\\[$p\\]; $arr\\[$p\\]=$arr\\[$i\\]; $arr\\[$i\\]=$tmp;</span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">return $arr; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">//**插入排序** </span><br><span class=\"line\"></span><br><span class=\"line\">/\\* 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到下一位置中 */ </span><br><span class=\"line\"></span><br><span class=\"line\">function insert_sort($arr) &#123; </span><br><span class=\"line\">//区分 哪部分是已经排序好的 </span><br><span class=\"line\">//哪部分是没有排序的 </span><br><span class=\"line\">//找到其中一个需要排序的元素</span><br><span class=\"line\">//这个元素 就是从第二个元素开始，到最后一个元素都是这个需要排序的元素 </span><br><span class=\"line\">//利用循环就可以标志出来 </span><br><span class=\"line\">//i循环控制 每次需要插入的元素，一旦需要插入的元素控制好了，</span><br><span class=\"line\">//间接已经将数组分成了2部分，下标小于当前的（左边的），是排序好的序列 </span><br><span class=\"line\"></span><br><span class=\"line\">for($i=1, $len=count($arr); $i&lt;$len; $i++) &#123; //获得当前需要比较的元素值。 </span><br><span class=\"line\">    $tmp = $arr\\[$i\\]; </span><br><span class=\"line\">    //内层循环控制 比较 并 插入 </span><br><span class=\"line\">    for($j=$i-1;$j&gt;=0;$j--) &#123; //$arr\\[$i\\];//需要插入的元素; $arr\\[$j\\];//需要比较的元素 </span><br><span class=\"line\">        if($tmp &lt; $arr\\[$j\\]) &#123; //发现插入的元素要小，交换位置 //将后边的元素与前面的元素互换 </span><br><span class=\"line\">            $arr\\[$j+1\\] = $arr\\[$j\\]; //将前面的数设置为 当前需要交换的数 </span><br><span class=\"line\">            $arr\\[$j\\] = $tmp; &#125; else &#123; //如果碰到不需要移动的元素 //由于是已经排序好是数组，则前面的就不需要再次比较了。 </span><br><span class=\"line\">            break;</span><br><span class=\"line\">          &#125; </span><br><span class=\"line\">\t\t&#125; </span><br><span class=\"line\">\t&#125; //将这个元素 插入到已经排序好的序列内。</span><br><span class=\"line\">//返回 </span><br><span class=\"line\">return $arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">//**快速排序法** 对冒泡排序的一种改进 </span><br><span class=\"line\">/\\* 通过一趟排序将要排序的数据分割成独立的两部分， 其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序， 整个排序过程可以递归进行，以此达到整个数据变成有序序列 */ </span><br><span class=\"line\"></span><br><span class=\"line\">function quick\\_sort($arr) &#123; //先判断是否需要继续进行 </span><br><span class=\"line\"></span><br><span class=\"line\">  $length = count($arr); if($length &lt;= 1) &#123; </span><br><span class=\"line\">  return $arr; </span><br><span class=\"line\"></span><br><span class=\"line\">  &#125; //如果没有返回，说明数组内的元素个数 多余1个，需要排序 //选择一个标尺 //选择第一个元素</span><br><span class=\"line\"></span><br><span class=\"line\">  $base\\_num = $arr\\[0\\]; //遍历 除了标尺外的所有元素，按照大小关系放入两个数组内 //初始化两个数组 $left\\_array = array();//小于标尺的 </span><br><span class=\"line\">  $right\\_array = array();//大于标尺的 </span><br><span class=\"line\">  for($i=1; $i&lt;$length; $i++) &#123; </span><br><span class=\"line\">    if($base\\_num &gt; $arr\\[$i\\]) &#123; //放入左边数组 </span><br><span class=\"line\">        $left\\_array\\[\\] = $arr\\[$i\\]; &#125; else &#123; //放入右边 </span><br><span class=\"line\">        $right\\_array\\[\\] = $arr\\[$i\\]; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    //再分别对 左边 和 右边的数组进行相同的排序处理方式 //递归调用这个函数,并记录结果 </span><br><span class=\"line\">  $left\\_array = quick\\_sort($left\\_array);</span><br><span class=\"line\">  $right\\_array = quick\\_sort($right\\_array); //合并左边 标尺 右边 </span><br><span class=\"line\">  return array\\_merge($left\\_array, array($base\\_num), $right\\_array);</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">print\\_r($arr); </span><br><span class=\"line\">echo &quot;&lt;br /&gt;冒泡&quot;; </span><br><span class=\"line\">print\\_r(array\\_reverse($arr)); </span><br><span class=\"line\">echo &quot;&lt;br /&gt;冒泡排序&quot;; </span><br><span class=\"line\">rint\\_r(getpao($arr)); </span><br><span class=\"line\">echo &quot;&lt;br /&gt;选择排序&quot;; </span><br><span class=\"line\">print\\_r(select\\_sort($arr)); </span><br><span class=\"line\">echo &quot;&lt;br /&gt;插入排序&quot;; </span><br><span class=\"line\">print\\_r(insert\\_sort($arr));</span><br><span class=\"line\">echo &quot;&lt;br /&gt;快速排序&quot;; </span><br><span class=\"line\">print\\_r(quick_sort($arr)); </span><br><span class=\"line\">echo &quot;&lt;br /&gt;&quot;; // **递归** 函数自身调用自身，但必须在调用自身前有条件判断，否则无限无限调用下去 function test($a=0,&amp;$result=array())&#123; // global $result; $a++; </span><br><span class=\"line\">  if($a&lt;10)&#123; </span><br><span class=\"line\">      $result\\[\\]=$a; test($a,$result);</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">return $result;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">print_r(test()); </span><br><span class=\"line\">echo &quot;&lt;br /&gt;&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">//**递归 利用全局变量** </span><br><span class=\"line\"></span><br><span class=\"line\">function test($a=0,$result=array())&#123; </span><br><span class=\"line\">global $result; $a++; if ($a&lt;10) &#123; </span><br><span class=\"line\">$result\\[\\]=$a; test($a,$result);</span><br><span class=\"line\">&#125; return $result; &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">//**递归 利用静态变量** 递归函数间作为“桥梁&quot;的变量利用static进行初始化，每一次递归都会保留&quot;桥梁变量&quot;的值。 </span><br><span class=\"line\"></span><br><span class=\"line\">function test($a=0)&#123; </span><br><span class=\"line\">static $result=array(); $a++; </span><br><span class=\"line\">if ($a&lt;10) &#123; </span><br><span class=\"line\">\t\t$result\\[\\]=$a; test($a); </span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">return $result; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">//**递归 无限级分类** </span><br><span class=\"line\"></span><br><span class=\"line\">$area = array( </span><br><span class=\"line\">array(&#x27;id&#x27;=&gt;1,&#x27;area&#x27;=&gt;&#x27;北京&#x27;,&#x27;pid&#x27;=&gt;0), </span><br><span class=\"line\">array(&#x27;id&#x27;=&gt;2,&#x27;area&#x27;=&gt;&#x27;广西&#x27;,&#x27;pid&#x27;=&gt;0), </span><br><span class=\"line\">array(&#x27;id&#x27;=&gt;3,&#x27;area&#x27;=&gt;&#x27;广东&#x27;,&#x27;pid&#x27;=&gt;0), </span><br><span class=\"line\">array(&#x27;id&#x27;=&gt;4,&#x27;area&#x27;=&gt;&#x27;福建&#x27;,&#x27;pid&#x27;=&gt;0), </span><br><span class=\"line\">array(&#x27;id&#x27;=&gt;11,&#x27;area&#x27;=&gt;&#x27;朝阳区&#x27;,&#x27;pid&#x27;=&gt;1), </span><br><span class=\"line\">array(&#x27;id&#x27;=&gt;12,&#x27;area&#x27;=&gt;&#x27;海淀区&#x27;,&#x27;pid&#x27;=&gt;1), </span><br><span class=\"line\">array(&#x27;id&#x27;=&gt;21,&#x27;area&#x27;=&gt;&#x27;南宁市&#x27;,&#x27;pid&#x27;=&gt;2), </span><br><span class=\"line\">array(&#x27;id&#x27;=&gt;45,&#x27;area&#x27;=&gt;&#x27;福州市&#x27;,&#x27;pid&#x27;=&gt;4), </span><br><span class=\"line\">array(&#x27;id&#x27;=&gt;113,&#x27;area&#x27;=&gt;&#x27;亚运村&#x27;,&#x27;pid&#x27;=&gt;11), </span><br><span class=\"line\">array(&#x27;id&#x27;=&gt;115,&#x27;area&#x27;=&gt;&#x27;奥运村&#x27;,&#x27;pid&#x27;=&gt;11), </span><br><span class=\"line\">array(&#x27;id&#x27;=&gt;234,&#x27;area&#x27;=&gt;&#x27;武鸣县&#x27;,&#x27;pid&#x27;=&gt;21) ); </span><br><span class=\"line\"></span><br><span class=\"line\">function t($arr,$pid=0,$lev=0)&#123; </span><br><span class=\"line\">static $list=array(); </span><br><span class=\"line\">foreach ($arr as $v)&#123; </span><br><span class=\"line\">if($v\\[&#x27;pid&#x27;\\]==$pid)&#123; </span><br><span class=\"line\">echo str\\_repeat(&quot;&quot;,$lev).$v\\[&#x27;area&#x27;\\].&quot;&lt;br /&gt;&quot;; </span><br><span class=\"line\">$list\\[\\]=$v; t($arr,$v\\[&#x27;id&#x27;\\],$lev+1); </span><br><span class=\"line\">\t\t&#125; </span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">return $list; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">$list=t($area);</span><br><span class=\"line\">print\\_r($area); </span><br><span class=\"line\">echo &quot;&lt;br /&gt;&quot;; </span><br><span class=\"line\">print_r($list); ?&gt;</span><br></pre></td></tr></table></figure>",
            "tags": [
                "快速排序",
                "冒泡排序",
                "算法",
                "PHP算法",
                "php递归",
                "递归"
            ]
        }
    ]
}