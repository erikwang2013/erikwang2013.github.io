{
    "version": "https://jsonfeed.org/version/1",
    "title": "艾瑞可erik • All posts by \"hyperf\" tag • All posts by \"undefined\" categories",
    "description": "一只PHP开发的程序猿，偶尔做做运维、Goland、Python、Java、摄影、画画、写作、顺便睡觉，反正整站都搞过。",
    "home_page_url": "https://erik.xyz",
    "items": [
        {
            "id": "https://erik.xyz/2025/05/26/webman-hyperf-change/",
            "url": "https://erik.xyz/2025/05/26/webman-hyperf-change/",
            "title": "webman和hyperf对比解析",
            "date_published": "2025-05-26T13:55:00.000Z",
            "content_html": "<p>好的，我们来深入探讨一下 <code>webman</code>、<code>Hyperf</code> 的底层原理以及 PHP 中注解（Annotations）的实现原理。</p>\n<h2 id=\"1-webman-底层原理\"><a href=\"#1-webman-底层原理\" class=\"headerlink\" title=\"1. webman 底层原理\"></a>1. webman 底层原理</h2><p><code>webman</code> 的核心设计理念是 <strong>轻量、高性能、易用</strong>。它构建在强大的异步事件驱动网络库 <strong>Workerman</strong> 之上，充分利用了 PHP 的 CLI（命令行接口）模式和事件循环机制，摒弃了传统的 PHP-FPM 模式，从而实现了高性能和高并发。</p>\n<span id=\"more\"></span>\n<h3 id=\"核心原理剖析\"><a href=\"#核心原理剖析\" class=\"headerlink\" title=\"核心原理剖析\"></a>核心原理剖析</h3><ol>\n<li><p><strong>基于 Workerman：</strong></p>\n<ul>\n<li><strong>事件驱动：</strong> Workerman 使用 <code>libevent</code> (默认)、<code>event</code> 或 <code>swoole</code> 扩展提供的事件循环库。它在一个或多个主进程中创建和管理一个或多个事件循环 (<code>event loop</code>)。</li>\n<li><strong>非阻塞 I/O：</strong> 所有网络操作（TCP/UDP/Unix Socket 监听和连接）都是非阻塞的。当一个连接上有数据可读、可写或发生错误时，事件循环会触发注册的回调函数进行处理。这避免了为每个连接创建线程或进程的巨大开销。</li>\n<li><strong>多进程模型：</strong><ul>\n<li><strong>主进程 (Master)：</strong> 负责解析配置、创建监听套接字、管理子进程（Worker 进程）、监控子进程状态（如崩溃重启）、处理信号（如 reload, stop, status）。</li>\n<li><strong>Worker 进程 (Worker)：</strong> 真正处理业务逻辑的进程。主进程 <code>fork</code> 出多个 Worker 子进程。<strong>默认情况下，这些 Worker 进程是常驻内存的</strong>。每个 Worker 进程都独立运行着自己的事件循环，处理分配给它的连接请求。</li>\n<li><strong>进程间通信 (IPC)：</strong> Master 和 Worker 之间通常通过 Unix Socket 管道进行通信（例如发送 reload 信号、状态查询）。</li>\n</ul>\n</li>\n<li><strong>协议支持：</strong> Workerman 内置了对 HTTP、WebSocket、TCP、UDP 等协议的支持，并能自定义协议。</li>\n</ul>\n</li>\n<li><p><strong>webman 在 Workerman 上的封装：</strong></p>\n<ul>\n<li><strong>PSR 兼容：</strong> 提供了符合 PSR-7 (HTTP 消息接口)、PSR-15 (HTTP 中间件)、PSR-11 (容器) 等标准的实现，使得开发者可以使用熟悉的中间件模式和依赖注入。</li>\n<li><strong>路由：</strong> 提供灵活的路由配置（如文件路由 <code>route.php</code>），将 HTTP 请求映射到对应的控制器方法或闭包。</li>\n<li><strong>中间件：</strong> 实现了洋葱圈模型的中间件机制，方便处理请求前、后的逻辑（如鉴权、日志、跨域）。</li>\n<li><strong>控制器：</strong> 组织业务逻辑代码。</li>\n<li><strong>视图：</strong> 支持简单的模板渲染。</li>\n<li><strong>数据库/Redis：</strong> 提供便捷的封装，但需要注意<strong>在默认 Worker 进程模型下，数据库连接不能像 Swoole 协程那样自动释放/重用，需要开发者自行管理连接的生命周期</strong>（通常在一个请求处理周期内创建和关闭，或使用连接池）。webman 官方提供了 <code>webman/redis-queue</code> 等插件来帮助管理。</li>\n<li><strong>文件监控与热更新：</strong><ul>\n<li><code>php webman start</code> 默认启动时带 <code>-w</code> 参数开启监控。</li>\n<li>Workerman 利用 Linux 内核的 <code>inotify</code> 机制（或 macOS 的 <code>kqueue</code>）监控项目文件（<code>.php</code>, <code>.env</code> 等）的更改。</li>\n<li>当检测到文件修改，主进程会向所有 Worker 进程发送 <code>SIGUSR1</code> 信号。</li>\n<li>Worker 进程收到信号后，安全地退出当前正在处理的请求（如果有），然后优雅地重启自身（重新加载修改后的代码），而主进程保持运行并重新 <code>fork</code> 新的 Worker 进程。这个过程<strong>非常快速</strong>，用户几乎感知不到服务中断，实现了“热更新”。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>高性能关键点：</strong></p>\n<ul>\n<li><strong>常驻内存：</strong> 最大的优势。框架核心、业务代码、配置等在 Worker 进程启动时加载一次，驻留在内存中。处理后续请求时<strong>无需重复初始化框架、加载核心文件、连接数据库（如果连接池管理得当）</strong>，极大减少了开销。</li>\n<li><strong>事件驱动 &amp; 非阻塞：</strong> 高效处理高并发连接，尤其适合 I/O 密集型场景。</li>\n<li><strong>轻量级：</strong> 框架本身代码量少，抽象层薄，开销小。</li>\n</ul>\n</li>\n</ol>\n<p><strong>总结 webman 原理：</strong> 利用 Workerman 的事件驱动、非阻塞 I/O 和多进程模型提供高性能网络基础。webman 在其上构建了一个符合现代 PHP 开发规范（PSR）的轻量级 Web 框架，并通过文件监控实现了便捷的热更新。其核心优势在于常驻内存带来的性能提升和 Workerman 的稳定性。</p>\n<h2 id=\"2-Hyperf-底层原理\"><a href=\"#2-Hyperf-底层原理\" class=\"headerlink\" title=\"2. Hyperf 底层原理\"></a>2. Hyperf 底层原理</h2><p><code>Hyperf</code> 是一个 <strong>高性能、高灵活性的企业级协程框架</strong>。它的核心建立在 <strong>Swoole</strong> 扩展之上，深度利用了 Swoole 提供的 <strong>协程</strong> 能力来实现高性能和高并发，并引入了大量 Java Spring Cloud 等框架的设计理念（如依赖注入、AOP、注解驱动）。</p>\n<h3 id=\"核心原理剖析-1\"><a href=\"#核心原理剖析-1\" class=\"headerlink\" title=\"核心原理剖析\"></a>核心原理剖析</h3><ol>\n<li><p><strong>基于 Swoole：</strong></p>\n<ul>\n<li><strong>协程：</strong> Swoole 的核心能力。协程是用户态的轻量级线程，由框架或运行时自身调度，切换成本极低（通常只有函数调用的开销）。Hyperf <strong>深度拥抱协程</strong>，几乎所有组件（HTTP Server、Database Client、Redis Client、RPC Client/Server、AMQP 等）都设计为<strong>协程安全</strong>或<strong>协程友好</strong>。</li>\n<li><strong>协程调度：</strong> Swoole 提供了协程调度器。当一个协程遇到 I/O 操作（如数据库查询、网络请求、文件读写）时，它会自动挂起（<code>yield</code>），将 CPU 让给其他就绪的协程。当 I/O 操作完成，调度器会恢复（<code>resume</code>）该协程继续执行。这使得<strong>单进程内可以并发处理成千上万个连接/任务</strong>，且代码逻辑依然是<strong>顺序编写</strong>（异步回调的 <code>callback hell</code> 问题得到极大缓解）。</li>\n<li><strong>事件驱动：</strong> 底层仍然是事件驱动（基于 <code>epoll</code>/<code>kqueue</code> 等），Swoole 的事件循环驱动着协程的调度。</li>\n<li><strong>Server：</strong> 提供高性能的 HTTP Server、WebSocket Server、TCP/UDP Server 等。Hyperf 主要使用 HTTP Server。</li>\n</ul>\n</li>\n<li><p><strong>Hyperf 在 Swoole 上的高级封装与架构：</strong></p>\n<ul>\n<li><strong>强大的依赖注入容器 (DI Container)：</strong><ul>\n<li>是整个框架的基石（基于 <code>hyperf/di</code> 组件）。</li>\n<li>实现了 <code>PSR-11</code>。</li>\n<li>支持自动装配（Autowiring）、接口绑定实现、构造函数注入、属性注入、方法注入。</li>\n<li>管理着应用中几乎所有对象的生命周期（单例、原型等）。</li>\n<li>是 AOP 和注解驱动实现的基础。</li>\n</ul>\n</li>\n<li><strong>注解驱动开发 (Annotation-Driven Development)：</strong><ul>\n<li>Hyperf <strong>重度依赖注解</strong>来配置路由、定义中间件、声明 AOP 切面、标记定时任务、配置依赖注入、定义 RPC 服务等。</li>\n<li>框架启动时（或在 <code>Worker</code> 进程启动时，取决于注解作用域），会通过<strong>反射</strong>扫描代码，解析类、方法、属性上的注解，收集元数据，并动态生成代理类或进行相应的配置注册（如将路由信息注册到路由器）。</li>\n<li>极大提高了开发效率和代码的可读性、可维护性（配置紧贴代码）。</li>\n</ul>\n</li>\n<li><strong>面向切面编程 (AOP)：</strong><ul>\n<li>基于 DI 容器和动态代理实现。</li>\n<li>允许开发者定义“切面”（<code>Aspect</code>）类，其中包含“通知”（<code>Advice</code> - 如 <code>@Before</code>, <code>@After</code>, <code>@Around</code>）和“切入点”（<code>Pointcut</code> - 通过注解或表达式指定哪些类的哪些方法需要被切入）。</li>\n<li>框架在运行时，会为匹配 <code>Pointcut</code> 的目标类<strong>生成代理类</strong>。当调用目标方法时，实际上是调用代理类的方法，代理类会按顺序执行相关的 <code>Advice</code> 逻辑（如日志记录、性能监控、事务管理、缓存处理、权限校验等），然后再调用或环绕调用原始目标方法。</li>\n<li>实现了横切关注点（Cross-Cutting Concerns）与核心业务逻辑的解耦。</li>\n</ul>\n</li>\n<li><strong>协程上下文管理：</strong><ul>\n<li>由于协程是轻量级且并发执行的，传统的全局变量、单例模式在协程环境下可能不安全（一个协程修改会影响其他协程）。</li>\n<li>Hyperf 提供了 <code>hyperf/context</code> 组件，利用 Swoole 的协程 API (<code>Swoole\\Coroutine::getContext()</code>) 实现<strong>协程级别的上下文隔离</strong>。<code>Context</code> 类允许安全地在同一个协程内存储和获取数据。</li>\n</ul>\n</li>\n<li><strong>连接池：</strong><ul>\n<li>为昂贵的资源（如数据库连接、Redis 连接、HTTP 客户端连接）提供池化管理。</li>\n<li>当协程需要资源时，从池中获取；使用完毕后，归还到池中。</li>\n<li><strong>避免频繁创建和销毁连接的开销</strong>，极大提升性能，并且<strong>天然适配协程模型</strong>（每个协程使用独立的连接，避免并发问题）。</li>\n</ul>\n</li>\n<li><strong>组件化与异步非阻塞客户端：</strong><ul>\n<li>Hyperf 提供了大量开箱即用的高性能协程组件：数据库 (<code>hyperf/database</code> - 基于 Eloquent/Doctrine, 带连接池)、Redis (<code>hyperf/redis</code> - 带连接池)、缓存、队列 (<code>hyperf/async-queue</code>)、RPC (<code>hyperf/json-rpc</code>)、服务注册与发现 (<code>hyperf/service-governance</code>)、配置中心 (<code>hyperf/config</code>)、分布式追踪 (<code>hyperf/tracer</code>)、限流熔断 (<code>hyperf/rate-limit</code>, <code>hyperf/circuit-breaker</code>)、GraphQL、gRPC、AMQP、WebSocket 等。</li>\n<li>这些客户端底层都使用 Swoole 提供的协程 Client 或自行实现的协程化 Client，确保所有 I/O 操作都是<strong>异步非阻塞</strong>的，能够被协程调度器挂起和恢复。</li>\n</ul>\n</li>\n<li><strong>进程模型：</strong><ul>\n<li><strong>主进程 (Master)：</strong> 管理服务生命周期。</li>\n<li><strong>Manager 进程：</strong> 管理 Worker/TaskWorker 进程（创建、回收）。</li>\n<li><strong>Worker 进程：</strong> 处理网络请求（HTTP, WebSocket, TCP 等）。<strong>每个 Worker 进程是一个独立的协程调度单元</strong>，内部可以并发运行大量协程处理请求。</li>\n<li><strong>TaskWorker 进程 (可选)：</strong> 专门处理耗时较长的同步阻塞任务（如某些复杂计算、调用不支持协程的库）。Worker 进程通过 <code>task()</code> 投递任务到 TaskWorker。Hyperf 也提供了基于消息队列 (<code>async-queue</code>) 的异步任务处理方案。</li>\n</ul>\n</li>\n<li><strong>热更新：</strong><ul>\n<li>原理类似 webman/Workerman，使用 <code>inotify</code>/<code>kqueue</code> 监控文件变化。</li>\n<li>向 Worker 进程发送信号 (<code>SIGUSR1</code> 或 <code>SIGTERM</code>) 通知其优雅重启（完成当前请求后退出，主进程重新拉起新 Worker 加载新代码）。Hyperf 的 DI 容器和代理类生成机制使得热更新相对可靠。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p><strong>总结 Hyperf 原理：</strong> 深度集成 Swoole 协程，构建了一个高性能、企业级的微服务框架。其核心在于强大的依赖注入容器、基于注解的元编程和配置、AOP 解耦横切关注点、完善的协程上下文和连接池管理，以及大量开箱即用的高性能协程组件。它更适合构建复杂的、分布式的高并发系统（如微服务架构）。</p>\n<h2 id=\"3-PHP-注解-Annotations-原理\"><a href=\"#3-PHP-注解-Annotations-原理\" class=\"headerlink\" title=\"3. PHP 注解 (Annotations) 原理\"></a>3. PHP 注解 (Annotations) 原理</h2><p>注解（PHP 8 之前常称为 DocBlock Annotations，PHP 8 引入了原生 Attributes）是一种<strong>元数据</strong>机制。它允许你将结构化的信息（元数据）附加到代码元素（类、方法、属性、函数、参数）上。这些信息本身<strong>不会直接影响代码的逻辑执行</strong>，但可以被<strong>外部工具（如框架、库、IDE、文档生成器）在运行时或编译时读取并利用</strong>。</p>\n<h3 id=\"实现原理-重点在框架如何利用\"><a href=\"#实现原理-重点在框架如何利用\" class=\"headerlink\" title=\"实现原理 (重点在框架如何利用)\"></a>实现原理 (重点在框架如何利用)</h3><ol>\n<li><p><strong>PHP 8 之前 (DocBlock Annotations)：</strong></p>\n<ul>\n<li><strong>存储位置：</strong> 元数据以特定格式的注释块（<code>/** ... */</code>）形式写在代码元素的上方。</li>\n<li><strong>格式：</strong> 遵循 PHPDoc 标准，但框架会定义自己的特殊标签（如 <code>@Route</code>, <code>@Inject</code>, <code>@Cacheable</code>）。</li>\n<li><strong>解析：</strong><ul>\n<li><strong>反射 (Reflection)：</strong> 框架利用 PHP 的反射 API (<code>ReflectionClass</code>, <code>ReflectionMethod</code>, <code>ReflectionProperty</code>) 获取代码元素（类、方法、属性）。</li>\n<li><strong>获取 DocComment：</strong> 通过反射对象的 <code>getDocComment()</code> 方法获取该元素上的文档注释字符串。</li>\n<li><strong>解析字符串：</strong> 框架需要编写自己的解析器（或使用库如 <code>doctrine/annotations</code>）来解析这个字符串。解析器：<ul>\n<li>识别以 <code>@</code> 开头的标记（Tags）。</li>\n<li>解析标记后的参数（可能是简单的字符串、键值对、数组、甚至嵌套结构）。</li>\n<li>将解析结果转换为结构化的数据（通常是数组或特定的注解对象）。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>处理：</strong><ul>\n<li><strong>启动时扫描：</strong> 框架通常在启动阶段（或首次请求时）扫描指定的目录或命名空间下的所有 PHP 文件。</li>\n<li><strong>反射与解析：</strong> 对扫描到的类、方法、属性使用反射获取 DocComment 并进行解析。</li>\n<li><strong>元数据收集：</strong> 将解析得到的结构化注解信息收集并存储起来（例如，将 <code>@Route</code> 信息注册到路由表中；将 <code>@Inject</code> 信息用于 DI 容器的自动装配配置）。</li>\n<li><strong>运行时利用：</strong> 在处理请求或执行特定逻辑时，框架会根据之前收集的注解元数据来指导行为（如根据路由注解匹配控制器方法；根据缓存注解决定是否从缓存读取数据）。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>PHP 8 及之后 (原生 Attributes)：</strong></p>\n<ul>\n<li><strong>语言级支持：</strong> PHP 8 将注解作为<strong>一级语言特性</strong>引入，称为 <strong>Attributes</strong>。它们不再是注释，而是<strong>正式的语法结构</strong>。</li>\n<li><strong>定义：</strong> 使用 <code>#[...]</code> 语法定义。Attribute 本身就是一个普通的 PHP 类（通常继承自 <code>\\Attribute</code>），可以有自己的构造函数、属性和方法，用于定义和验证元数据的结构。</li>\n<li><strong>反射获取：</strong> 反射 API 新增了 <code>getAttributes()</code> 方法（例如 <code>ReflectionClass::getAttributes()</code>）。这个方法返回一个 <code>ReflectionAttribute</code> 对象数组。</li>\n<li><strong>实例化：</strong> 可以通过 <code>ReflectionAttribute::newInstance()</code> 方法实例化 Attribute 类对象（如果定义了类），传入的参数就是在 Attribute 定义时提供的参数。这样就得到了一个<strong>强类型的、结构化的注解对象</strong>。</li>\n<li><strong>优势：</strong><ul>\n<li><strong>性能：</strong> 原生语法，解析速度比解析 DocComment 字符串快得多。</li>\n<li><strong>验证：</strong> Attribute 类可以定义构造函数参数类型，PHP 引擎会在定义时就进行参数类型检查，避免运行时解析错误。</li>\n<li><strong>结构清晰：</strong> 强类型对象比解析字符串得到的数组更清晰、更安全。</li>\n<li><strong>IDE 支持：</strong> IDE 能更好地识别、自动补全和检查 Attributes。</li>\n</ul>\n</li>\n<li><strong>框架处理流程 (类似 DocBlock，但更高效安全)：</strong><ul>\n<li>启动扫描目录/命名空间。</li>\n<li>使用反射 API 获取类/方法/属性。</li>\n<li>调用 <code>getAttributes()</code> 获取附加的 Attribute 列表。</li>\n<li><code>newInstance()</code> 实例化需要的 Attribute 对象。</li>\n<li>收集这些 Attribute 对象包含的元数据。</li>\n<li>根据元数据配置框架（注册路由、配置 DI、定义 AOP 切入点等）。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p><strong>总结注解原理：</strong> 无论是旧的 DocBlock 还是新的原生 Attribute，注解的本质都是<strong>附加在代码元素上的元数据</strong>。框架通过 <strong>反射机制</strong> 在<strong>启动阶段（或按需）</strong> 扫描代码，<strong>解析</strong>这些元数据，将其转换为<strong>结构化信息</strong>，并<strong>利用这些信息来动态配置框架行为、生成代理代码（AOP）或指导运行时逻辑</strong>。原生 Attributes 在性能、类型安全性和开发体验上带来了显著提升。像 Hyperf 这类现代框架已全面转向使用原生 Attributes。</p>\n<h2 id=\"webman-vs-Hyperf-核心原理对比摘要\"><a href=\"#webman-vs-Hyperf-核心原理对比摘要\" class=\"headerlink\" title=\"webman vs Hyperf 核心原理对比摘要\"></a>webman vs Hyperf 核心原理对比摘要</h2><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">特性</th>\n<th style=\"text-align:left\">webman</th>\n<th style=\"text-align:left\">Hyperf</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>核心引擎</strong></td>\n<td style=\"text-align:left\">Workerman (事件驱动, 多进程)</td>\n<td style=\"text-align:left\">Swoole (事件驱动 + <strong>协程</strong>, 多进程)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>编程模型</strong></td>\n<td style=\"text-align:left\">事件回调 + 传统同步逻辑 (需自行管理阻塞I/O)</td>\n<td style=\"text-align:left\"><strong>协程</strong> (同步写法, 异步非阻塞I/O)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>性能关键</strong></td>\n<td style=\"text-align:left\">常驻内存 (减少初始化开销)</td>\n<td style=\"text-align:left\">常驻内存 + <strong>协程</strong> (高并发, 低资源消耗)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>连接管理</strong></td>\n<td style=\"text-align:left\">需手动管理或借助插件/连接池</td>\n<td style=\"text-align:left\"><strong>内置协程连接池</strong> (DB, Redis, HTTP Client等)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>核心机制</strong></td>\n<td style=\"text-align:left\">轻量路由、中间件、PSR 封装</td>\n<td style=\"text-align:left\"><strong>强大的DI容器</strong>、<strong>注解驱动</strong>、<strong>AOP</strong>、丰富组件化</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>并发能力</strong></td>\n<td style=\"text-align:left\">高 (多进程)</td>\n<td style=\"text-align:left\"><strong>极高</strong> (多进程 + 单进程内高协程并发)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>复杂度</strong></td>\n<td style=\"text-align:left\"><strong>轻量简单</strong>，学习曲线平缓</td>\n<td style=\"text-align:left\"><strong>功能强大复杂</strong>，学习曲线较陡 (需理解DI, AOP, 协程)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>定位</strong></td>\n<td style=\"text-align:left\">高性能 HTTP API / 简单实时应用</td>\n<td style=\"text-align:left\">企业级、微服务、分布式系统、复杂高并发应用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>热更新</strong></td>\n<td style=\"text-align:left\">支持 (基于 inotify/kqueue)</td>\n<td style=\"text-align:left\">支持 (基于 inotify/kqueue)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>代表技术</strong></td>\n<td style=\"text-align:left\">文件监听、Workerman API</td>\n<td style=\"text-align:left\">Attributes、AOP、依赖注入、连接池、服务治理</td>\n</tr>\n</tbody>\n</table>\n</div>\n",
            "tags": [
                "php",
                "hyperf",
                "webman"
            ]
        },
        {
            "id": "https://erik.xyz/2022/01/12/hyperf-errors/",
            "url": "https://erik.xyz/2022/01/12/hyperf-errors/",
            "title": "hyperf异常",
            "date_published": "2022-01-12T07:30:00.000Z",
            "content_html": "<ul>\n<li><p>Maximum function nesting level of ‘256’ reached, aborting</p>\n<pre><code>先跑了所有接口，发现都是这个报错。梳理新增加的接口方法后，直接屏蔽新接口所有方法逻辑，就恢复正常。依次排除法，最终发现在model里面封装的方法调用了service层的方法导致超负荷加载函数嵌套。\n</code></pre></li>\n</ul>\n<span id=\"more\"></span>",
            "tags": [
                "hyperf"
            ]
        }
    ]
}