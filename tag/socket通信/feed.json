{
    "version": "https://jsonfeed.org/version/1",
    "title": "艾瑞可erik • All posts by \"socket通信\" tag • All posts by \"undefined\" categories",
    "description": "一只PHP开发的程序猿，偶尔做做运维、Goland、Python、Java、摄影、画画、写作、顺便睡觉，反正整站都搞过。",
    "home_page_url": "https://erik.xyz",
    "items": [
        {
            "id": "https://erik.xyz/2019/09/18/socket-jin-cheng-tong-xin-ji-zhi/",
            "url": "https://erik.xyz/2019/09/18/socket-jin-cheng-tong-xin-ji-zhi/",
            "title": "socket进程通信及多进程",
            "date_published": "2019-09-18T05:31:00.000Z",
            "content_html": "<p>socket是操作系统提供的通信层的一组抽象API</p>\n<h4 id=\"函数介绍\"><a href=\"#函数介绍\" class=\"headerlink\" title=\"函数介绍\"></a>函数介绍</h4><ul>\n<li><p>socket_create(int $domain , int $type , int $protocol)  </p>\n<p>正确时返回一个套接字(通讯），失败时返回 FALSE。要读取错误代码，可以调用 socket_last_error()。这个错误代码可以通过 socket_strerror() 读取文字的错误说明。</p>\n<p>创建一个通讯节点，socket_create包含三个参数</p>\n<ul>\n<li>$domain  指定哪个协议用在当前套接字(通讯节点)，有以下三种：<ul>\n<li>AF_INET：IPv4网络协议。TCP 和 UDP 都可使用此协议。</li>\n<li>AF_INET6：    IPv6网络协议。TCP 和 UDP 都可使用此协议。</li>\n<li>AF_UNIX：        本地通讯协议。具有高性能和低成本的 IPC（进程间通讯）。<span id=\"more\"></span></li>\n</ul>\n</li>\n<li>$type  选择套接字(通讯节点)使用的类型，有以下五种：<ul>\n<li>SOCK_STREAM：提供一个顺序化的、可靠的、全双工的、基于连接的字节流。支持数据传送流量控制机制。TCP 协议即基于这种流式套接字。</li>\n<li>SOCK_DGRAM：提供数据报文的支持。(无连接，不可靠、固定最大长度).UDP协议即基于这种数据报文套接字。</li>\n<li>SOCK_SEQPACKET：提供一个顺序化的、可靠的、全双工的、面向连接的、固定最大长度的数据通信；数据端通过接收每一个数据段来读取整个数据包。</li>\n<li>SOCK_RAW：提供读取原始的网络协议。这种特殊的套接字可用于手工构建任意类型的协议。一般使用这个套接字来实现 ICMP 请求（例如 ping）。</li>\n<li>SOCK_RDM：提供一个可靠的数据层，但不保证到达顺序。一般的操作系统都未实现此功能。</li>\n</ul>\n</li>\n<li>$protocol 设定$domain套接字(通讯节点)下的具体协议。这个值可以使用 getprotobyname() 函数进行读取。如果所需的协议是 TCP 或 UDP，可以直接使用常量 SOL_TCP 和 SOL_UDP 。<ul>\n<li>icmp：Internet Control Message Protocol 主要用于网关和主机报告错误的数据通信。</li>\n<li>udp(SOL_UDP)：User Datagram Protocol 是一个无连接的、不可靠的、具有固定最大长度的报文协议。</li>\n<li>tcp(SOL_TCP)：Transmission Control Protocol 是一个可靠的、基于连接的、面向数据流的全双工协议</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>socket_set_option ( resource $socket , int $level , int $optname , mixed $optval ) </p>\n<p>成功时返回 TRUE， 或者在失败时返回 FALSE。</p>\n<p>设置套接字的套接字选项</p>\n<ul>\n<li>$socket: 套接节(通讯节点)</li>\n<li>$level: 指定选项所在的协议级别</li>\n<li>$optname: 可用的套接字选项与 socket_get_option() 选项相同</li>\n<li>$optval: 可选项值</li>\n</ul>\n</li>\n<li><p>socket_read ( resource $socket , int $length [, int $type = PHP_BINARY_READ ] ) 从套接字读取最大长度字节</p>\n<ul>\n<li>$socket: 套接节(通讯节点)</li>\n<li>$length: socket资源中的buffer的长度</li>\n<li>$type: 可选类型参数<ul>\n<li>PHP_BINARY_READ   默认值，安全的读取二进制数</li>\n<li>PHP_NORMAL_READ   读取停止</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>socket_getpeername ( resource $socket , string &amp;$address [, int &amp;$port ] )  查询远端套接字</p>\n<ul>\n<li>$socket: 套接节(通讯节点)</li>\n<li>$address: 查询地址</li>\n<li>$port: 查询端口(非必填)</li>\n</ul>\n</li>\n<li><p>socket_recv ( resource $socket , string &amp;$buf , int $len , int $flags )  从已连接的socket接收数据</p>\n<ul>\n<li>$socket: 套接节(通讯节点)</li>\n<li>$buf: 从socket中获取的数据将被保存在由 buf 制定的变量中</li>\n<li>$len: 长度最多为 len 字节的数据将被接收</li>\n<li>$flags: 可以为下列任意flag的组合:<ul>\n<li>MSG_OOB    处理超出边界的数据</li>\n<li>MSG_PEEK    从接受队列的起始位置接收数据，但不将他们从接受队列中移除。</li>\n<li>MSG_WAITALL    在接收到至少 len 字节的数据之前，造成一个阻塞，并暂停脚本运行（block）</li>\n<li>MSG_DONTWAIT    如果制定了该flag，函数将不会造成阻塞，即使在全局设置中指定了阻塞设置</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>socket_select ( array &amp;$read , array &amp;$write , array &amp;$except , int $tv_sec [, int $tv_usec = 0 ] )    系统调用给定的套接字数组并指定超时</p>\n<ul>\n<li>$read： 监听读取数组中列出的套接字</li>\n<li>$write： 将监听写入数组中列出的套接字以查看写入是否不会阻塞</li>\n<li>$except：  将监视except数组中列出的套接字是否有异常。</li>\n<li>$tv_sec：  tv_sec和tv_usec一起形成超时参数。 超时是socket_select（）返回之前经过的时间量的上限。 tv_sec可能为零，导致socket_select（）立即返回。 这对轮询非常有用。 如果tv_sec为NULL（无超时），则socket_select（）可以无限期地阻塞。</li>\n<li>$tv_usec  同上</li>\n</ul>\n</li>\n<li><p>socket_accept ( resource $socket )  接受套接字上的连接</p>\n</li>\n<li><p>socket_write ( resource $socket , string $buffer [, int $length = 0 ] )  写入套接字</p>\n<ul>\n<li>$socket: 套接节(通讯节点)</li>\n<li>$buffer：要写入的缓冲区。</li>\n<li>$length：可选参数 长度</li>\n</ul>\n</li>\n<li><p>socket_close</p>\n<p>TODO ： 关闭 socket 资源 函数原型: void socket_close ( resource $socket )</p>\n<ul>\n<li>socket: socket_accept或者socket_create产生的资源，不能用于stream资源的关闭</li>\n</ul>\n</li>\n<li><p>stream_socket_server</p>\n<p>由于创建一个SOCKET的流程总是 socket、bind、listen，所以PHP提供了一个非常方便的函数一次性创建、绑定端口、监听端口</p>\n<p>函数原型: resource stream_socket_server ( string $local_socket [, int &amp;$errno [, string &amp;$errstr [, int $flags = STREAM_SERVER_BIND | STREAM_SERVER_LISTEN [, resource $context ]]]] )</p>\n<ul>\n<li>local_socket: 协议名://地址:端口号</li>\n<li>errno: 错误码</li>\n<li>errstr: 错误信息</li>\n<li>flags: 只使用该函数的部分功能</li>\n<li>context: 使用stream_context_create函数创建的资源流上下文</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"socket通信示例\"><a href=\"#socket通信示例\" class=\"headerlink\" title=\"socket通信示例\"></a>socket通信示例</h4><pre><code>&lt;?php\n\n\nclass SocketServer\n&#123;\n    protected $address;\n    protected $port;\n\n    public function __construct($address = &#39;127.0.0.1&#39;, $port = &#39;8080&#39;)\n    &#123;\n        $this-&gt;address = $address;\n        $this-&gt;port = $port;\n    &#125;\n\n    public function startSocket()\n    &#123;\n        $socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);\n        socket_bind($socket, $this-&gt;address, $this-&gt;port);\n        socket_listen($socket);\n        for ( ; ; ) &#123;\n            $conn = socket_accept($socket);\n\n            $write_buffer = &quot;HTTP/1.0 200 OK\\r\\nServer: my_server\\r\\nContent-Type: text/html; charset=utf-8\\r\\n\\r\\n&#123;&#39;code&#39;:100020,&#39;data&#39;:&#123;&#39;name&#39;:&#39;艾瑞可erik&#39;,&#39;url&#39;:&#39;https://erik.xyz&#39;&#125;,&#39;msg&#39;:&#39;ok&#39;&#125;&quot;;\n\n            socket_write($conn, $write_buffer);\n\n            socket_close($conn);\n        &#125;\n    &#125;\n\n    public function run()&#123;\n        $this-&gt;startSocket();\n    &#125;\n&#125;\n\n$sock=new SocketServer();\n$sock-&gt;run();\n</code></pre><p>   运行结果如下：<br>   <img src=\"/img/201909/2019-09-19_162558.jpg\" alt=\"socket运行结果\"></p>\n<p>也可以用stream，即流集成实现。</p>\n<pre><code>&lt;?php\n      class StreamSocketServer\n      &#123;\n          protected $address;\n          protected $port;\n\n          public function __construct($address=&#39;127.0.0.1&#39;,$port=8080)\n          &#123;\n              $this-&gt;address=$address;\n              $this-&gt;port=$port;\n          &#125;\n\n          public function startSocket()&#123;\n              $socket=stream_socket_server(&quot;tcp://&quot;.$this-&gt;address.&quot;:&quot;.$this-&gt;port,$errno,$errstr);\n              $data=&quot;&#123;&#39;code&#39;:100020,&#39;msg&#39;:&#39;ok&#39;,&#39;data&#39;:&#123;&#39;name&#39;:&#39;艾瑞可erik&#39;,&#39;url&#39;:&#39;https://erik.xyz&#39;&#125;&#125;&quot;;\n              for ( ; ; ) &#123;\n                  $conn = stream_socket_accept($socket);\n\n                  $write_buffer = &quot;HTTP/1.0 200 OK\\r\\nServer: my_server\\r\\nContent-Type: text/html; charset=utf-8\\r\\n\\r\\n&quot;.$data;\n\n                  fwrite($conn, $write_buffer);\n\n                  fclose($conn);\n              &#125;\n          &#125;\n\n          public function run()&#123;\n              $this-&gt;startSocket();\n          &#125;\n      &#125;\n\n      $socket=new StreamSocketServer();\n      $socket-&gt;run();\n</code></pre><h3 id=\"多进程\"><a href=\"#多进程\" class=\"headerlink\" title=\"多进程\"></a>多进程</h3><p>多进程示例</p>\n<pre><code>&lt;?php\nheader(&quot;Content-type:text/html;charset=utf-8&quot;);\n\nclass ProcessTest\n&#123;\n\n    public function add()&#123;\n        $pid=pcntl_fork();\n\n        if($pid)&#123;\n            echo &quot;这是一个父进程\\n&quot;;\n            pcntl_waitpid($pid,$status);\n        &#125;elseif ($pid==0)&#123;\n            echo &quot;这是子进程\\n&quot;;\n        &#125;else&#123;\n            die(&quot;进程结束\\n&quot;);\n        &#125;\n    &#125;\n\n    public function run()&#123;\n        $this-&gt;add();\n    &#125;\n&#125;\n\n$process=new ProcessTest();\n$process-&gt;run();\n</code></pre><p>运行的效果<br><img src=\"/img/201909/2019-09-19_170643.jpg\" alt=\"多进行效果\"></p>\n<ul>\n<li><p>pcntl_fork</p>\n<p>函数原型: int pcntl_fork ( void )</p>\n<p>执行该函数，会复制当前进程产生另一个进程，称之为当前进程的子进程，该函数在父进程和子进程的返回值不相同，在父进程中返回的是fork出的子进程的进程ID，而在子进程中返回值为0。</p>\n<p>要注意的是在复制进程时，会复制该进程的数据（堆数据、栈数据和静态数据），包括在父进程打开的文件描述符，在子进程中也是打开的，这意味着当你在父进程使用了大量内存时，fork出来的子进程必须拥有等量的内存资源，否则可能会导致fork失败。</p>\n</li>\n</ul>\n<ul>\n<li><p>pcntl_waitpid</p>\n<p>函数原型: int pcntl_waitpid ( int $pid , int &amp;$status [, int $options = 0 ] )</p>\n<ul>\n<li>pid: 进程ID</li>\n<li>status: 子进程的退出状态</li>\n<li>option: 取决于操作系统是否提供wait3函数，如果提供该函数，则该选项参数才生效.</li>\n</ul>\n</li>\n</ul>\n<p>上面的进程还是有缺陷，处理多任务时并不太合适。<br>就用一个非常简单的leader-follower模型，创建一个进程池，随机选出一个进程作为leader进程，该进程监听是否有新连接，如果有则提升另一个follower为leader进程来继续监听，而原leader进程则去处理新连接的请求</p>\n<p>socket多任务示例</p>\n<pre><code>&lt;?php\n\n\nclass StreamSocketServer\n&#123;\n    protected $address;\n    protected $port;\n\n    public function __construct($address=&#39;127.0.0.1&#39;,$port=8080)\n    &#123;\n        $this-&gt;address=$address;\n        $this-&gt;port=$port;\n    &#125;\n\n    public function startSocket()&#123;\n        $socket=stream_socket_server(&quot;tcp://&quot;.$this-&gt;address.&quot;:&quot;.$this-&gt;port,$errno,$errstr);\n        $data=&quot;&#123;&#39;code&#39;:100020,&#39;msg&#39;:&#39;ok&#39;,&#39;data&#39;:&#123;&#39;name&#39;:&#39;艾瑞可erik&#39;,&#39;url&#39;:&#39;https://erik.xyz&#39;&#125;&#125;&quot;;\n        $pids=[];\n        for($i=0;$i&lt;10;$i++)&#123;\n            $pid=pcntl_fork();\n            $pids[]=$pid;\n            if($pid==0)&#123;\n                for ( ; ; ) &#123;\n                    $conn = stream_socket_accept($socket);\n\n                    $write_buffer = &quot;HTTP/1.0 200 OK\\r\\nServer: my_server\\r\\nContent-Type: text/html; charset=utf-8\\r\\n\\r\\n&quot;.$data;\n\n                    fwrite($conn, $write_buffer);\n\n                    fclose($conn);\n                &#125;\n                exit(&quot;结束了\\n&quot;);\n            &#125;\n        &#125;\n\n        foreach ($pids as $pid)&#123;\n            pcntl_waitpid($pid,$status);\n        &#125;\n    &#125;\n\n    public function run()&#123;\n        $this-&gt;startSocket();\n    &#125;\n&#125;\n\n$socket=new StreamSocketServer();\n$socket-&gt;run();\n</code></pre><p>运行结果</p>\n<p><img src=\"/img/201909/2019-09-19_173231.jpg\" alt=\"多任务运行socket\"></p>\n<p>运行10个任务没问题，但是多进程是消耗cpu资源的，如果任务多，进程不断的增加，服务器是无法承受的。这时候多进程处理大的并发就不合适了。那就用IO复用。</p>\n<h3 id=\"IO复用\"><a href=\"#IO复用\" class=\"headerlink\" title=\"IO复用\"></a>IO复用</h3><ul>\n<li><p>阻塞／非阻塞</p>\n<p>这两个概念是针对 IO 过程中进程的状态来说的，阻塞 IO 是指调用结果返回之前，当前线程会被挂起；相反，非阻塞指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</p>\n</li>\n<li><p>同步／异步</p>\n<p>这两个概念是针对调用如果返回结果来说的，所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回；相反，当一个异步过程调用发出后，调用者不能立刻得到结果，实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</p>\n</li>\n<li><p>阻塞与非阻塞</p>\n<p>在介绍IO复用技术之前，先介绍一下阻塞和非阻塞，在我们前几节的WEB服务器中，调用socket_accept函数会使整个进程阻塞，直到有新连接，操作系统才唤醒进程继续执行。而非阻塞模式, stream_socket_accept的行为就不一样了，如果没有新连接，不会阻塞进程，而是马上返回false。</p>\n</li>\n<li><p>I/O多路复用</p>\n<p>多路复用（IO/Multiplexing）：为了提高数据信息在网络通信线路中传输的效率，在一条物理通信线路上建立多条逻辑通信信道，同时传输若干路信号的技术就叫做多路复用技术。对于 Socket 来说，应该说能同时处理多个连接的模型都应该被称为多路复用，目前比较常用的有 select/poll/epoll/kqueue 这些 IO 模型（目前也有像 Apache 这种每个连接用单独的进程/线程来处理的 IO 模型，但是效率相对比较差，也很容易出问题，所以暂时不做介绍了）。在这些多路复用的模式中，异步阻塞/非阻塞模式的扩展性和性能最好。</p>\n</li>\n<li><p>select 轮询 </p>\n<p>使用select会轮询连接池，当有连接可读或可写时，select函数返回可读写的连接数，然后再轮询一遍连接池，查找活动连接进行读写操作</p>\n</li>\n</ul>\n<p>socket_select只支持socket类型的资源，而不支持stream类型的资源，所以这里需要使用socket_create创建socket资源</p>\n<p>select轮询示例</p>\n<pre><code>&lt;?php\n\nclass SocketServer\n&#123;\n    protected $address;\n    protected $port;\n\n    public function __construct($address = &#39;127.0.0.1&#39;, $port = &#39;8080&#39;)\n    &#123;\n        $this-&gt;address = $address;\n        $this-&gt;port = $port;\n    &#125;\n\n    public function startSocket()\n    &#123;\n        $socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);\n        socket_bind($socket, $this-&gt;address, $this-&gt;port);\n        socket_listen($socket);\n        $reads = [];\n        $clients = [];\n        $writes = null;\n        $exceptions = null;\n        socket_set_nonblock($socket);\n        $write_buffer = &quot;HTTP/1.0 200 OK\\r\\nServer: my_server\\r\\nContent-Type: text/html; charset=utf-8\\r\\n\\r\\n&#123;&#39;code&#39;:100,&#39;data&#39;:&#123;&#39;name&#39;:&#39;艾瑞可erik&#39;&#125;,&#39;msg&#39;:&#39;ok&#39;&#125;&quot;;\n        for (; ;) &#123;\n            $reads = array_merge(array($socket), $clients);\n            $activity_counts = socket_select($reads, $writes, $exceptions, 0);\n            if ($activity_counts &gt; 0) &#123;\n                if (($conn = socket_accept($socket)) !== false) &#123;\n                    $clients[] = $conn;\n                &#125;\n            &#125;\n            $this-&gt;client($clients,$write_buffer);\n        &#125;\n    &#125;\n\n    /**\n     * @param $clients\n     * @param $write_buffer\n     */\n    public function client($clients,$write_buffer)&#123;\n        $length = count($clients);\n        for ($i = 0; $i &lt; $length; $i++) &#123;\n            $client = $clients[$i];\n            if (($read_buff = socket_read($client, 1024))!=false) &#123;\n                socket_write($client, $write_buffer);\n                socket_close($client);\n                break;\n            &#125;\n        &#125;\n    &#125;\n\n    public function run()\n    &#123;\n        $this-&gt;startSocket();\n    &#125;\n&#125;\n\n$sock = new SocketServer();\n$sock-&gt;run();\n</code></pre><p>select虽然可以监听多个连接，但是它最多只能监听1024个连接。这虽然在poll中得到了改进，但是select和poll本质上都是通过轮询的方式进行监听，这意味着当监听了上万连接时，就算只有一个连接是活动的，依然要把上万连接都遍历一次。显然，这无疑是极大的性能浪费，而epoll的出现彻底地解决了这个问题</p>\n<ul>\n<li><p>epoll<br>epoll并不是只有一个函数来实现，而是多个函数。我们这里并不讨论epoll相关的函数，因为PHP并不提供相关的函数，但它提供了基于libevent库的libevent扩展，以及基于libevent库的event扩展。libevent库实现了Reactor模型，关于Reactor模型，这里只作简单的介绍</p>\n<p>Reactor模型，包含了几个组件：句柄，事件分发器，事件处理器。</p>\n<ul>\n<li>句柄，就是文件描述符，在Socket编程中，就是使用socket_create创建的socket资源.</li>\n<li>事件分发器, 通过事件循环，事件循环是通过诸如epoll<code>Select</code>Poll等IO复用技术实现的，监听句柄期待的事件是否发生，发生了则将事件分发给事件处理器.</li>\n<li>事件处理器，当事件发生时，处理相关的逻辑.</li>\n</ul>\n</li>\n</ul>\n<p>  libevent库已经实现了Reactor模型，安装event扩展即可。</p>\n<p>  示例</p>\n<pre><code>&lt;?php\n\n$address = &#39;127.0.0.1&#39;;\n$port = 8080;\n\n//创建句柄\n$data = &quot;&#123;&#39;code&#39;:100020,&#39;msg&#39;:&#39;ok&#39;,&#39;data&#39;:&#123;&#39;name&#39;:&#39;艾瑞可erik&#39;,&#39;url&#39;:&#39;https://erik.xyz&#39;&#125;&#125;&quot;;\n$write_buffer = &quot;HTTP/1.0 200 OK\\r\\nServer: my_server\\r\\nContent-Type: text/html; charset=utf-8\\r\\n\\r\\n&quot; . $data;\n$socket = @stream_socket_server(&quot;tcp://&quot; . $address . &quot;:&quot; . $port, $errno, $errstr);\nstream_set_blocking($socket, 0);\n//创建事件循环器\n$event_base = new EventBase();\n//创建事件，并指定事件监听的事件类型及注册事件处理器\n$event = new Event($event_base, $socket, Event::READ | Event::PERSIST, function ($socket) use (&amp;$event_base, $write_buffer) &#123;\n    $conn = stream_socket_accept($socket);\n    fwrite($conn, $write_buffer);\n    fclose($conn);\n&#125;, $socket);\n//向循环器中添加事件\n$event-&gt;add();\n$event_base-&gt;loop();\n</code></pre><p>在浏览器运行请求，或者用工具检测。</p>\n<p>运行结果<br><img src=\"/img/201909/2019-09-19_190045.jpg\" alt=\"epoll运行结果\"></p>\n<p>这时需要考虑一个问题：如果进程断了怎么办？</p>\n<p>那就需要进程守护。</p>\n<p>一般PPID为0的，都是内核态进程。一般PPID为1的都是守护进程</p>\n<ul>\n<li><p>守护进程创建的标准流程<br>让WEB服务器进程变为守护进程，成为守护进程有几个标准的步骤：</p>\n<ul>\n<li>设置文件创建掩码，一般设置为0，umask(0)</li>\n<li>pcntl_fork一个子进程，并马上退出，这样做的目的是让子进程继承进程组ID并获取一个新的进程ID，这样就可以确保子进程一定不是进程组组长，因为进程组组长不能创建新会话</li>\n<li>posix_setsid创建新会话和新进程组，并成为会话组长和进程组组长，并和原来的控制终端脱离关系，这样该进程就不会被原来终端的控制信号中断</li>\n<li>pcntl_fork，再fork一次并不是必须的，只是在基于System-V的系统上，有人建议再fork一次，避免打开终端设备，使程序的通用性更强。</li>\n</ul>\n</li>\n</ul>\n<p>守护进程示例</p>\n<pre><code> &lt;?php\n  header(&#39;Content-type:text/html;charset:utf-8&#39;);\n  //守护进程\n  function daemon()&#123;\n      umask(0);\n      //创建进程，并退出进程\n      if(pcntl_fork())&#123;\n          exit(&quot;退出进程\\n&quot;);\n      &#125;\n\n      //创建新的会话和进程组,并退出原来的控制端\n      posix_setsid();\n\n      //再次创建进程，并退出\n      if(pcntl_fork())&#123;\n          exit(&quot;再次创建进程，并退出\\n&quot;);\n      &#125;\n  &#125;\n  daemon();\n\n  $address = &#39;127.0.0.1&#39;;\n  $port = 8080;\n\n  //创建句柄\n  $data = &quot;&#123;&#39;code&#39;:100020,&#39;msg&#39;:&#39;ok&#39;,&#39;data&#39;:&#123;&#39;name&#39;:&#39;艾瑞可erik&#39;,&#39;url&#39;:&#39;https://erik.xyz&#39;&#125;&#125;&quot;;\n  $write_buffer = &quot;HTTP/1.0 200 OK\\r\\nServer: my_server\\r\\nContent-Type: text/html; charset=utf-8\\r\\n\\r\\n&quot; . $data;\n  $socket = @stream_socket_server(&quot;tcp://&quot; . $address . &quot;:&quot; . $port, $errno, $errstr);\n  stream_set_blocking($socket, 0);\n  //创建事件循环器\n  $event_base = new EventBase();\n  //创建事件，并指定事件监听的事件类型及注册事件处理器\n  $event = new Event($event_base, $socket, Event::READ | Event::PERSIST, function ($socket) use (&amp;$event_base, $write_buffer) &#123;\n      $conn = stream_socket_accept($socket);\n      fwrite($conn, $write_buffer);\n      fclose($conn);\n  &#125;, $socket);\n  //向循环器中添加事件\n  $event-&gt;add();\n  $event_base-&gt;loop();\n</code></pre><p>  运行结果</p>\n<p>  <img src=\"/img/201909/2019-09-19_213853.jpg\" alt=\"守护进程运行结果\"></p>\n<p>  那么守护进程有了，如何重启、关闭呢。那就调用函数发送信号</p>\n<ul>\n<li><p>posix_kill<br>函数原型: bool posix_kill ( int $pid , int $sig )</p>\n<ul>\n<li>pid: 进程ID</li>\n<li>sig: 系统预定义的信号常量</li>\n</ul>\n</li>\n<li><p>pcntl_signal<br>函数原型: bool pcntl_signal ( int $signo , callback $handler [, bool $restart_syscalls = true ] )</p>\n<ul>\n<li>signo: 系统预定义的信号常量</li>\n<li>handler: 信号处理器，一个回调函数</li>\n<li>restart_syscalls: 当进程在进行系统调用时，被信号中断时，系统调用是否重新调用，一般默认为true</li>\n</ul>\n</li>\n</ul>\n<p>  那么根据以上几个步骤，我做个整合。完整版的socket进程及多进程控制</p>\n<p> EventServer</p>\n<pre><code> &lt;?php\n\nclass EventServer\n&#123;\n    public $event_base;\n    public $events = [];\n\n    public function __construct()\n    &#123;\n        $this-&gt;event_base = new EventBase();\n    &#125;\n\n    public function add($fd, $what, $callback, $callback_arg)\n    &#123;\n        $event = new Event($this-&gt;event_base, $fd, $what, $callback, $callback_arg);\n        $this-&gt;events[intval($fd)] = $event;\n        $event-&gt;add();\n    &#125;\n\n    public function remove($fb)\n    &#123;\n        $event = $this-&gt;events[intval($fb)];\n        $event-&gt;free();\n    &#125;\n\n    public function loop()\n    &#123;\n        $this-&gt;event_base-&gt;loop();\n    &#125;\n&#125;\n</code></pre><p>StreamServer</p>\n<pre><code>&lt;?php\n\nrequire &quot;EventServer.php&quot;;\n\nclass StreamServer\n&#123;\n    protected $ip = &#39;127.0.0.1&#39;;\n    protected $port = 8080;\n    protected $path = &#39;./pid.txt&#39;;\n    protected $event;\n    protected $data = &quot;&#123;&#39;code&#39;:100020,&#39;msg&#39;:&#39;ok&#39;,&#39;data&#39;:&#123;&#39;name&#39;:&#39;艾瑞可erik&#39;,&#39;url&#39;:&#39;https://erik.xyz&#39;&#125;&#125;&quot;;\n    protected $write_buffer = &quot;HTTP/1.0 200 OK\\r\\nServer: my_server\\r\\nContent-Type: text/html; charset=utf-8\\r\\n\\r\\n&quot;;\n\n\n    public static function daemon()\n    &#123;\n        umask(0);\n\n        $pid = pcntl_fork();\n\n        if ($pid) &#123;\n            exit(0);\n        &#125; elseif ($pid &lt; 0) &#123;\n            die(&quot;进程启动失败\\n&quot;);\n        &#125;\n\n        $sid = posix_setsid();\n\n        $pid = pcntl_fork();\n\n        if ($pid) &#123;\n            exit(0);\n        &#125; elseif ($pid &lt; 0) &#123;\n            die(&quot;进程启动失败\\n&quot;);\n        &#125;\n\n        if ($sid &lt; 0) &#123;\n            die(&quot;创建服务失败\\n&quot;);\n        &#125;\n    &#125;\n\n    public function __construct($ip, $port = 80)\n    &#123;\n        $this-&gt;ip = $ip;\n        $this-&gt;port = $port;\n        $this-&gt;event = new EventServer();\n    &#125;\n\n    /**\n     * 启动\n     */\n    public function run()\n    &#123;\n        if ($GLOBALS[&#39;argc&#39;] &gt; 1) &#123;\n            $this-&gt;sendSignal();\n            exit(0);\n        &#125; else &#123;\n            self::daemon();\n        &#125;\n\n        $this-&gt;installSignalHandler();\n        $this-&gt;recordPid();\n        $this-&gt;start();\n    &#125;\n\n    //存储信号\n    public function sendSignal()\n    &#123;\n        if (posix_kill($this-&gt;getPid(), 0)) &#123;\n            if (strpos($GLOBALS[&#39;argv&#39;][1], &quot;stop&quot;) !== false) &#123;\n                posix_kill($this-&gt;getPid(), SIGUSR1);\n            &#125;\n        &#125;\n    &#125;\n\n    //启动进程\n    public function start()\n    &#123;\n        $domain = sprintf(&quot;tcp://%s:%d&quot;, $this-&gt;ip, $this-&gt;port);\n\n        $fd = stream_socket_server($domain, $errno, $errstr);\n\n        if (!$fd) &#123;\n            die(&quot;$errno $errstr\\n&quot;);\n        &#125;\n\n        stream_set_blocking($fd, 0);\n\n        $this-&gt;event-&gt;add($fd, Event::READ | Event::PERSIST, [$this, &#39;requestHandler&#39;], $fd);\n\n        $this-&gt;event-&gt;loop();\n    &#125;\n\n    /**响应信息\n     * @param $fd\n     */\n    public function requestHandler($fd)\n    &#123;\n        $write_buffer = $this-&gt;write_buffer . $this-&gt;data;\n        $conn = stream_socket_accept($fd);\n        fwrite($conn, $write_buffer);\n        fclose($conn);\n    &#125;\n\n    //添加信号\n    public function installSignalHandler()\n    &#123;\n        $this-&gt;event-&gt;add(SIGUSR1, Event::SIGNAL, [$this, &quot;handler&quot;], SIGUSR1);\n    &#125;\n\n    /**终止信号\n     * @param $signo\n     */\n    public function handler($signo)\n    &#123;\n        switch ($signo) &#123;\n            default:\n            case SIGUSR1:\n                $this-&gt;event-&gt;remove($signo);\n                $this-&gt;stop();\n                break;\n        &#125;\n    &#125;\n\n    public function stop()\n    &#123;\n        exit(&quot;终止信号\\n&quot;);\n    &#125;\n\n    public function getPid()\n    &#123;\n        return file_get_contents($this-&gt;path);\n    &#125;\n\n    private function recordPid()\n    &#123;\n        file_put_contents($this-&gt;path, posix_getpid());\n    &#125;\n&#125;\n\n$server = new StreamServer(&quot;127.0.0.1&quot;, 8080);\n$server-&gt;run();\n</code></pre><p>运行结果</p>\n<p><img src=\"/img/201909/2019-09-19_232908.jpg\" alt=\"最终执行结果\"></p>\n",
            "tags": [
                "socket通信",
                "socket多进程",
                "socket"
            ]
        }
    ]
}