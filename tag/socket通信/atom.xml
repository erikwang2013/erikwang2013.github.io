<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://erik.xyz</id>
    <title>艾瑞可erik • Posts by &#34;socket通信&#34; tag • Posts by &#34;undefined&#34; categories</title>
    <link href="https://erik.xyz" />
    <updated>2019-09-18T05:31:00.000Z</updated>
    <category term="php扩展" />
    <category term="php技巧" />
    <category term="php类库" />
    <category term="php资源" />
    <category term="日志" />
    <category term="工具" />
    <category term="jquery" />
    <category term="jquery插件" />
    <category term="js" />
    <category term="css" />
    <category term="php" />
    <category term="web" />
    <category term="代码" />
    <category term="压缩" />
    <category term="说说" />
    <category term="趣闻" />
    <category term="php服务器" />
    <category term="随笔" />
    <category term="php实例" />
    <category term="nginx" />
    <category term="转载" />
    <category term="php库" />
    <category term="互联" />
    <category term="项目实战" />
    <category term="javascript" />
    <category term="漏洞" />
    <category term="php应用" />
    <category term="浮点" />
    <category term="http" />
    <category term="http服务器" />
    <category term="负载均衡" />
    <category term="kali" />
    <category term="kali安装" />
    <category term="农业系统" />
    <category term="系统设计" />
    <category term="克莱姆法则" />
    <category term="行列式" />
    <category term="n阶行列式" />
    <category term="支付系统" />
    <category term="支付" />
    <category term="centos" />
    <category term="linux" />
    <category term="apache优化" />
    <category term="apache隐藏index" />
    <category term="nginx优化" />
    <category term="nginx隐藏index" />
    <category term="日常" />
    <category term="seo" />
    <category term="优化" />
    <category term="摘要" />
    <category term="文章" />
    <category term="游记" />
    <category term="ca证书" />
    <category term="证书生成" />
    <category term="二战" />
    <category term="二战熊" />
    <category term="西伯利亚熊" />
    <category term="centos软件" />
    <category term="yum仓库" />
    <category term="软件" />
    <category term="centos安装chromium报错" />
    <category term="chromium安装报错" />
    <category term="svn" />
    <category term="代码提交" />
    <category term="deb" />
    <category term="deb/rpm互转" />
    <category term="deb转rpm" />
    <category term="rpm互转" />
    <category term="centos7安装steam" />
    <category term="centos安装steam" />
    <category term="centos安装吃鸡steam" />
    <category term="linux安装steam" />
    <category term="steam安装" />
    <category term="centos软件安装" />
    <category term="centos6.5" />
    <category term="linux系统" />
    <category term="centos7安装Redis Desktop Manager" />
    <category term="centos7安装redis桌面" />
    <category term="centos安装redis桌面" />
    <category term="linux安装centos7安装Redis Desktop Manager" />
    <category term="Redis Desktop Manager" />
    <category term="redis桌面" />
    <category term="centos7" />
    <category term="centos7-wine" />
    <category term="wine" />
    <category term="wine安装" />
    <category term="root密码" />
    <category term="root密码重置" />
    <category term="忘记root密码" />
    <category term="memcache" />
    <category term="memcached" />
    <category term="生活手记" />
    <category term="艾瑞可erik" />
    <category term="程序员" />
    <category term="开源云" />
    <category term="容器" />
    <category term="cncf" />
    <category term="监控" />
    <category term="composer" />
    <category term="composer部署" />
    <category term="内网部署composer" />
    <category term="cphalcon" />
    <category term="cphalcon报错" />
    <category term="css中的em" />
    <category term="响应式字体" />
    <category term="响应式布局样式" />
    <category term="proxy代理搭建" />
    <category term="代理服务器搭建" />
    <category term="proxy服务器" />
    <category term="查找" />
    <category term="排序" />
    <category term="快速排序" />
    <category term="冒泡排序" />
    <category term="二分查找" />
    <category term="datahub" />
    <category term="datahub安装" />
    <category term="deepin" />
    <category term="emergency" />
    <category term="emergency mode" />
    <category term="deepin黑屏" />
    <category term="清理系统" />
    <category term="清理c盘" />
    <category term="dns" />
    <category term="域名监测" />
    <category term="网站监测" />
    <category term="docker" />
    <category term="php安装" />
    <category term="杂谈" />
    <category term="ecshop" />
    <category term="框架" />
    <category term="beego数据分页" />
    <category term="分页" />
    <category term="elasticsearch" />
    <category term="elasticsearch搭建" />
    <category term="elasticsearch集群" />
    <category term="系统" />
    <category term="emm" />
    <category term="mdm" />
    <category term="phone" />
    <category term="手机" />
    <category term="新闻" />
    <category term="免费" />
    <category term="jenkis" />
    <category term="jenkis教程" />
    <category term="随笔吐槽" />
    <category term="算法" />
    <category term="ping" />
    <category term="ping服务器" />
    <category term="各大网站ping" />
    <category term="搜引擎ping服务器" />
    <category term="go获取ip" />
    <category term="im" />
    <category term="go中pdf生成" />
    <category term="go中限流" />
    <category term="go对接快递签名" />
    <category term="go时间获取" />
    <category term="go类型转换" />
    <category term="微服务" />
    <category term="go-zero" />
    <category term="rpc" />
    <category term="go加密" />
    <category term="go解密" />
    <category term="归" />
    <category term="吐槽" />
    <category term="php大全" />
    <category term="php资料" />
    <category term="hadoop" />
    <category term="hadoop2.8.0" />
    <category term="hadoop安装教程" />
    <category term="hadoop安装详细教程" />
    <category term="hadoop教程" />
    <category term="hadoop部署" />
    <category term="hadoop3" />
    <category term="hadoop配置" />
    <category term="log4j2" />
    <category term="数据库" />
    <category term="hbase安装教程" />
    <category term="hbase" />
    <category term="http1.1" />
    <category term="http2.0" />
    <category term="会话" />
    <category term="会话原理" />
    <category term="hyperf" />
    <category term="杂录" />
    <category term="新冠肺炎" />
    <category term="springboot" />
    <category term="springboot内网部署" />
    <category term="linux恢复" />
    <category term="linux误删" />
    <category term="linux命令" />
    <category term="linux命令汇总" />
    <category term="jenkins" />
    <category term="jetbtrains" />
    <category term="phpstorm" />
    <category term="搜索引擎" />
    <category term="图片" />
    <category term="素材" />
    <category term="jq" />
    <category term="jq侧边导航" />
    <category term="侧边导航" />
    <category term="js判断浏览器" />
    <category term="js判断浏览器版本" />
    <category term="判断浏览器" />
    <category term="浏览器版本判断" />
    <category term="获取浏览器信息" />
    <category term="kali右键汉化" />
    <category term="kali桌面右键汉化" />
    <category term="kali右键创建文件" />
    <category term="区块链" />
    <category term="lanmp" />
    <category term="php环境独立配置" />
    <category term="服务器" />
    <category term="劳动纠纷" />
    <category term="追缴工资" />
    <category term="申请仲裁" />
    <category term="flash" />
    <category term="表单" />
    <category term="linux报错" />
    <category term="linux中update-command-not-found" />
    <category term="linux运行命令报错" />
    <category term="web前端" />
    <category term="web优化" />
    <category term="撮合算法" />
    <category term="撮合" />
    <category term="php撮合算法" />
    <category term="maven搭建库" />
    <category term="maven" />
    <category term="maven内网库" />
    <category term="高级缓存配置" />
    <category term="mongodb" />
    <category term="mongodb权限" />
    <category term="可穿戴设备" />
    <category term="mysql" />
    <category term="分库分表" />
    <category term="mysql应对千万级" />
    <category term="mysql瓶颈" />
    <category term="mysql瓶颈解决办法" />
    <category term="redis" />
    <category term="数据一致性" />
    <category term="mysql消息" />
    <category term="mysql队列" />
    <category term="mysql高并发" />
    <category term="mysql存储" />
    <category term="mysql引擎" />
    <category term="mysql数据表设计选择" />
    <category term="mysql监控" />
    <category term="mysql性能" />
    <category term="内网支付" />
    <category term="内网穿透" />
    <category term="支付接口本地化开发" />
    <category term="本地挂网" />
    <category term="穿透" />
    <category term="go" />
    <category term="new和make的区别" />
    <category term="红包算法" />
    <category term="深圳劳动法服务部门" />
    <category term="非关系型数据库" />
    <category term="onethink" />
    <category term="oop" />
    <category term="php管理系统" />
    <category term="开放接口开发" />
    <category term="开源工具" />
    <category term="桌面共享工具" />
    <category term="openresty" />
    <category term="openvas" />
    <category term="openvas安装" />
    <category term="php变量" />
    <category term="php超级全局变量" />
    <category term="php超级变量" />
    <category term="php基本类型" />
    <category term="php数据类型" />
    <category term="php设计模式" />
    <category term="php对接微信支付" />
    <category term="微信支付" />
    <category term="微信支付回调" />
    <category term="游戏" />
    <category term="php函数" />
    <category term="php随机数" />
    <category term="php获取闰年" />
    <category term="闰年.php时间" />
    <category term="php环境" />
    <category term="php集成环境" />
    <category term="服务器集成环境" />
    <category term="数组函数" />
    <category term="数组排序函数" />
    <category term="php数学函数" />
    <category term="php面试题" />
    <category term="php面向对象" />
    <category term="面向对象" />
    <category term="php-zookeeper" />
    <category term="zookeeper3.5.5" />
    <category term="php-zookeeper扩展" />
    <category term="php串口开发" />
    <category term="php倒计时" />
    <category term="php时间" />
    <category term="倒计时" />
    <category term="计算时间" />
    <category term="PHP数组" />
    <category term="字符串函数" />
    <category term="排序函数" />
    <category term="php的SPL" />
    <category term="SPL手册" />
    <category term="PHP算法" />
    <category term="php递归" />
    <category term="递归" />
    <category term="phpunit" />
    <category term="phpunit安装" />
    <category term="php过滤" />
    <category term="过滤" />
    <category term="foreach" />
    <category term="foreach报错" />
    <category term="php中foreach报错" />
    <category term="php中if" />
    <category term="php中if判断" />
    <category term="php的if" />
    <category term="php字符串" />
    <category term="php7中sphinx" />
    <category term="php7中sphinx扩展" />
    <category term="sphinx扩展" />
    <category term="python" />
    <category term="python库" />
    <category term="a标签" />
    <category term="a标签虚线" />
    <category term="虚线框" />
    <category term="R语言" />
    <category term="数据随机化" />
    <category term="redis总结" />
    <category term="redis命令" />
    <category term="redis监控" />
    <category term="redis锁" />
    <category term="redis分布式锁" />
    <category term="任意金额输入" />
    <category term="10元、5元、2元" />
    <category term="队列" />
    <category term="栈" />
    <category term="顺序表" />
    <category term="链表" />
    <category term="数据结构" />
    <category term="线性结构" />
    <category term="浏览器禁止操作视频" />
    <category term="禁止视频" />
    <category term="响应慢" />
    <category term="页面优化" />
    <category term="js编辑" />
    <category term="runjs" />
    <category term="在线编辑" />
    <category term="rust" />
    <category term="rust配置" />
    <category term="seajs" />
    <category term="session" />
    <category term="路由器烧录" />
    <category term="烧录" />
    <category term="极路由2烧录" />
    <category term="砖头烧录" />
    <category term="免费服务器" />
    <category term="空间" />
    <category term="资源" />
    <category term="深圳政府电话" />
    <category term="深圳电话" />
    <category term="特区电话" />
    <category term="居住证" />
    <category term="居住证签注" />
    <category term="深圳新居住证" />
    <category term="国庆骑行" />
    <category term="深圳珠海骑行" />
    <category term="骑行" />
    <category term="世界那么大" />
    <category term="css3" />
    <category term="css在线生成工具" />
    <category term="css工具" />
    <category term="php正则" />
    <category term="正则" />
    <category term="shodan" />
    <category term="黑谷歌" />
    <category term="黒帽搜素" />
    <category term="shopex" />
    <category term="可视化数据" />
    <category term="数据" />
    <category term="数据表" />
    <category term="json" />
    <category term="json数组" />
    <category term="json解析" />
    <category term="socket通信" />
    <category term="socket多进程" />
    <category term="socket" />
    <category term="sql" />
    <category term="sql优化" />
    <category term="css3兼容360浏览器兼容模式" />
    <category term="css圆角" />
    <category term="结构体转map" />
    <category term="config" />
    <category term="thinkphp" />
    <category term="配置文件" />
    <category term="树" />
    <category term="二叉树" />
    <category term="js插件" />
    <category term="web自适应" />
    <category term="响应式布局" />
    <category term="响应式所有分辨率" />
    <category term="自适应布局" />
    <category term="自适应所有分辨率" />
    <category term="webman" />
    <category term="mysql设置超时，超时" />
    <category term="markdown" />
    <category term="wget" />
    <category term="wget抓取" />
    <category term="网站抓取" />
    <category term="我在" />
    <category term="wordpress" />
    <category term="wordpress标签" />
    <category term="wpscan" />
    <category term="usbrip" />
    <category term="无限极分类" />
    <category term="php无限极" />
    <category term="分类tree" />
    <category term="无限极分类树型" />
    <category term="域名合并" />
    <category term="xhprof" />
    <category term="laravel" />
    <category term="composer插件" />
    <category term="html" />
    <category term="响应式分辨率" />
    <category term="响应式调试" />
    <category term="自适应屏幕" />
    <category term="携程" />
    <category term="携程攻击" />
    <category term="携程网站瘫痪" />
    <category term="物理删除" />
    <category term="3D" />
    <category term="动画" />
    <category term="平台" />
    <category term="虚幻4引擎编辑" />
    <category term="生成唯一id" />
    <category term="生成id" />
    <category term="发邮件" />
    <category term="邮件函数" />
    <category term="储蓄卡免年费" />
    <category term="银行卡" />
    <category term="银行卡免年费" />
    <category term="composer安装" />
    <category term="composer配置" />
    <category term="项目创建composer" />
    <category term="mysql优化" />
    <category term="mysql读写优化" />
    <category term="数据库优化，mysql语句优化" />
    <category term="php加密" />
    <category term="php技术" />
    <category term="夕阳" />
    <category term="mysql函数" />
    <category term="php中mysql函数" />
    <category term="互联网时代" />
    <category term="开源技术" />
    <category term="web框架" />
    <category term="php抓取图片" />
    <category term="php批量抓取页面图片" />
    <category term="邮箱服务器" />
    <category term="正则表达式" />
    <category term="翻墙" />
    <category term="谷歌" />
    <category term="谷歌搜索" />
    <entry>
        <id>https://erik.xyz/2019/09/18/socket-jin-cheng-tong-xin-ji-zhi/</id>
        <title>socket进程通信及多进程</title>
        <link rel="alternate" href="https://erik.xyz/2019/09/18/socket-jin-cheng-tong-xin-ji-zhi/"/>
        <content type="html">&lt;link rel=&#34;stylesheet&#34; class=&#34;aplayer-secondary-style-marker&#34; href=&#34;/assets/css/APlayer.min.css&#34;&gt;&lt;script src=&#34;/assets/js/APlayer.min.js&#34; class=&#34;aplayer-secondary-script-marker&#34;&gt;&lt;/script&gt;&lt;p&gt;socket是操作系统提供的通信层的一组抽象API&lt;/p&gt;
&lt;h4 id=&#34;函数介绍&#34;&gt;&lt;a href=&#34;#函数介绍&#34; class=&#34;headerlink&#34; title=&#34;函数介绍&#34;&gt;&lt;/a&gt;函数介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;socket_create(int $domain , int $type , int $protocol)  &lt;/p&gt;
&lt;p&gt;正确时返回一个套接字(通讯），失败时返回 FALSE。要读取错误代码，可以调用 socket_last_error()。这个错误代码可以通过 socket_strerror() 读取文字的错误说明。&lt;/p&gt;
&lt;p&gt;创建一个通讯节点，socket_create包含三个参数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$domain  指定哪个协议用在当前套接字(通讯节点)，有以下三种：&lt;ul&gt;
&lt;li&gt;AF_INET：IPv4网络协议。TCP 和 UDP 都可使用此协议。&lt;/li&gt;
&lt;li&gt;AF_INET6：    IPv6网络协议。TCP 和 UDP 都可使用此协议。&lt;/li&gt;
&lt;li&gt;AF_UNIX：        本地通讯协议。具有高性能和低成本的 IPC（进程间通讯）。&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;$type  选择套接字(通讯节点)使用的类型，有以下五种：&lt;ul&gt;
&lt;li&gt;SOCK_STREAM：提供一个顺序化的、可靠的、全双工的、基于连接的字节流。支持数据传送流量控制机制。TCP 协议即基于这种流式套接字。&lt;/li&gt;
&lt;li&gt;SOCK_DGRAM：提供数据报文的支持。(无连接，不可靠、固定最大长度).UDP协议即基于这种数据报文套接字。&lt;/li&gt;
&lt;li&gt;SOCK_SEQPACKET：提供一个顺序化的、可靠的、全双工的、面向连接的、固定最大长度的数据通信；数据端通过接收每一个数据段来读取整个数据包。&lt;/li&gt;
&lt;li&gt;SOCK_RAW：提供读取原始的网络协议。这种特殊的套接字可用于手工构建任意类型的协议。一般使用这个套接字来实现 ICMP 请求（例如 ping）。&lt;/li&gt;
&lt;li&gt;SOCK_RDM：提供一个可靠的数据层，但不保证到达顺序。一般的操作系统都未实现此功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;$protocol 设定$domain套接字(通讯节点)下的具体协议。这个值可以使用 getprotobyname() 函数进行读取。如果所需的协议是 TCP 或 UDP，可以直接使用常量 SOL_TCP 和 SOL_UDP 。&lt;ul&gt;
&lt;li&gt;icmp：Internet Control Message Protocol 主要用于网关和主机报告错误的数据通信。&lt;/li&gt;
&lt;li&gt;udp(SOL_UDP)：User Datagram Protocol 是一个无连接的、不可靠的、具有固定最大长度的报文协议。&lt;/li&gt;
&lt;li&gt;tcp(SOL_TCP)：Transmission Control Protocol 是一个可靠的、基于连接的、面向数据流的全双工协议&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;socket_set_option ( resource $socket , int $level , int $optname , mixed $optval ) &lt;/p&gt;
&lt;p&gt;成功时返回 TRUE， 或者在失败时返回 FALSE。&lt;/p&gt;
&lt;p&gt;设置套接字的套接字选项&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$socket: 套接节(通讯节点)&lt;/li&gt;
&lt;li&gt;$level: 指定选项所在的协议级别&lt;/li&gt;
&lt;li&gt;$optname: 可用的套接字选项与 socket_get_option() 选项相同&lt;/li&gt;
&lt;li&gt;$optval: 可选项值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;socket_read ( resource $socket , int $length [, int $type = PHP_BINARY_READ ] ) 从套接字读取最大长度字节&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$socket: 套接节(通讯节点)&lt;/li&gt;
&lt;li&gt;$length: socket资源中的buffer的长度&lt;/li&gt;
&lt;li&gt;$type: 可选类型参数&lt;ul&gt;
&lt;li&gt;PHP_BINARY_READ   默认值，安全的读取二进制数&lt;/li&gt;
&lt;li&gt;PHP_NORMAL_READ   读取停止&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;socket_getpeername ( resource $socket , string &amp;amp;$address [, int &amp;amp;$port ] )  查询远端套接字&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$socket: 套接节(通讯节点)&lt;/li&gt;
&lt;li&gt;$address: 查询地址&lt;/li&gt;
&lt;li&gt;$port: 查询端口(非必填)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;socket_recv ( resource $socket , string &amp;amp;$buf , int $len , int $flags )  从已连接的socket接收数据&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$socket: 套接节(通讯节点)&lt;/li&gt;
&lt;li&gt;$buf: 从socket中获取的数据将被保存在由 buf 制定的变量中&lt;/li&gt;
&lt;li&gt;$len: 长度最多为 len 字节的数据将被接收&lt;/li&gt;
&lt;li&gt;$flags: 可以为下列任意flag的组合:&lt;ul&gt;
&lt;li&gt;MSG_OOB    处理超出边界的数据&lt;/li&gt;
&lt;li&gt;MSG_PEEK    从接受队列的起始位置接收数据，但不将他们从接受队列中移除。&lt;/li&gt;
&lt;li&gt;MSG_WAITALL    在接收到至少 len 字节的数据之前，造成一个阻塞，并暂停脚本运行（block）&lt;/li&gt;
&lt;li&gt;MSG_DONTWAIT    如果制定了该flag，函数将不会造成阻塞，即使在全局设置中指定了阻塞设置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;socket_select ( array &amp;amp;$read , array &amp;amp;$write , array &amp;amp;$except , int $tv_sec [, int $tv_usec = 0 ] )    系统调用给定的套接字数组并指定超时&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$read： 监听读取数组中列出的套接字&lt;/li&gt;
&lt;li&gt;$write： 将监听写入数组中列出的套接字以查看写入是否不会阻塞&lt;/li&gt;
&lt;li&gt;$except：  将监视except数组中列出的套接字是否有异常。&lt;/li&gt;
&lt;li&gt;$tv_sec：  tv_sec和tv_usec一起形成超时参数。 超时是socket_select（）返回之前经过的时间量的上限。 tv_sec可能为零，导致socket_select（）立即返回。 这对轮询非常有用。 如果tv_sec为NULL（无超时），则socket_select（）可以无限期地阻塞。&lt;/li&gt;
&lt;li&gt;$tv_usec  同上&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;socket_accept ( resource $socket )  接受套接字上的连接&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;socket_write ( resource $socket , string $buffer [, int $length = 0 ] )  写入套接字&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$socket: 套接节(通讯节点)&lt;/li&gt;
&lt;li&gt;$buffer：要写入的缓冲区。&lt;/li&gt;
&lt;li&gt;$length：可选参数 长度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;socket_close&lt;/p&gt;
&lt;p&gt;TODO ： 关闭 socket 资源 函数原型: void socket_close ( resource $socket )&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;socket: socket_accept或者socket_create产生的资源，不能用于stream资源的关闭&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;stream_socket_server&lt;/p&gt;
&lt;p&gt;由于创建一个SOCKET的流程总是 socket、bind、listen，所以PHP提供了一个非常方便的函数一次性创建、绑定端口、监听端口&lt;/p&gt;
&lt;p&gt;函数原型: resource stream_socket_server ( string $local_socket [, int &amp;amp;$errno [, string &amp;amp;$errstr [, int $flags = STREAM_SERVER_BIND | STREAM_SERVER_LISTEN [, resource $context ]]]] )&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;local_socket: 协议名://地址:端口号&lt;/li&gt;
&lt;li&gt;errno: 错误码&lt;/li&gt;
&lt;li&gt;errstr: 错误信息&lt;/li&gt;
&lt;li&gt;flags: 只使用该函数的部分功能&lt;/li&gt;
&lt;li&gt;context: 使用stream_context_create函数创建的资源流上下文&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;socket通信示例&#34;&gt;&lt;a href=&#34;#socket通信示例&#34; class=&#34;headerlink&#34; title=&#34;socket通信示例&#34;&gt;&lt;/a&gt;socket通信示例&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;?php


class SocketServer
&amp;#123;
    protected $address;
    protected $port;

    public function __construct($address = &amp;#39;127.0.0.1&amp;#39;, $port = &amp;#39;8080&amp;#39;)
    &amp;#123;
        $this-&amp;gt;address = $address;
        $this-&amp;gt;port = $port;
    &amp;#125;

    public function startSocket()
    &amp;#123;
        $socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);
        socket_bind($socket, $this-&amp;gt;address, $this-&amp;gt;port);
        socket_listen($socket);
        for ( ; ; ) &amp;#123;
            $conn = socket_accept($socket);

            $write_buffer = &amp;quot;HTTP/1.0 200 OK\r\nServer: my_server\r\nContent-Type: text/html; charset=utf-8\r\n\r\n&amp;#123;&amp;#39;code&amp;#39;:100020,&amp;#39;data&amp;#39;:&amp;#123;&amp;#39;name&amp;#39;:&amp;#39;艾瑞可erik&amp;#39;,&amp;#39;url&amp;#39;:&amp;#39;https://erik.xyz&amp;#39;&amp;#125;,&amp;#39;msg&amp;#39;:&amp;#39;ok&amp;#39;&amp;#125;&amp;quot;;

            socket_write($conn, $write_buffer);

            socket_close($conn);
        &amp;#125;
    &amp;#125;

    public function run()&amp;#123;
        $this-&amp;gt;startSocket();
    &amp;#125;
&amp;#125;

$sock=new SocketServer();
$sock-&amp;gt;run();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   运行结果如下：&lt;br&gt;   &lt;img src=&#34;/img/201909/2019-09-19_162558.jpg&#34; alt=&#34;socket运行结果&#34;&gt;&lt;/p&gt;
&lt;p&gt;也可以用stream，即流集成实现。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
      class StreamSocketServer
      &amp;#123;
          protected $address;
          protected $port;

          public function __construct($address=&amp;#39;127.0.0.1&amp;#39;,$port=8080)
          &amp;#123;
              $this-&amp;gt;address=$address;
              $this-&amp;gt;port=$port;
          &amp;#125;

          public function startSocket()&amp;#123;
              $socket=stream_socket_server(&amp;quot;tcp://&amp;quot;.$this-&amp;gt;address.&amp;quot;:&amp;quot;.$this-&amp;gt;port,$errno,$errstr);
              $data=&amp;quot;&amp;#123;&amp;#39;code&amp;#39;:100020,&amp;#39;msg&amp;#39;:&amp;#39;ok&amp;#39;,&amp;#39;data&amp;#39;:&amp;#123;&amp;#39;name&amp;#39;:&amp;#39;艾瑞可erik&amp;#39;,&amp;#39;url&amp;#39;:&amp;#39;https://erik.xyz&amp;#39;&amp;#125;&amp;#125;&amp;quot;;
              for ( ; ; ) &amp;#123;
                  $conn = stream_socket_accept($socket);

                  $write_buffer = &amp;quot;HTTP/1.0 200 OK\r\nServer: my_server\r\nContent-Type: text/html; charset=utf-8\r\n\r\n&amp;quot;.$data;

                  fwrite($conn, $write_buffer);

                  fclose($conn);
              &amp;#125;
          &amp;#125;

          public function run()&amp;#123;
              $this-&amp;gt;startSocket();
          &amp;#125;
      &amp;#125;

      $socket=new StreamSocketServer();
      $socket-&amp;gt;run();
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;多进程&#34;&gt;&lt;a href=&#34;#多进程&#34; class=&#34;headerlink&#34; title=&#34;多进程&#34;&gt;&lt;/a&gt;多进程&lt;/h3&gt;&lt;p&gt;多进程示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
header(&amp;quot;Content-type:text/html;charset=utf-8&amp;quot;);

class ProcessTest
&amp;#123;

    public function add()&amp;#123;
        $pid=pcntl_fork();

        if($pid)&amp;#123;
            echo &amp;quot;这是一个父进程\n&amp;quot;;
            pcntl_waitpid($pid,$status);
        &amp;#125;elseif ($pid==0)&amp;#123;
            echo &amp;quot;这是子进程\n&amp;quot;;
        &amp;#125;else&amp;#123;
            die(&amp;quot;进程结束\n&amp;quot;);
        &amp;#125;
    &amp;#125;

    public function run()&amp;#123;
        $this-&amp;gt;add();
    &amp;#125;
&amp;#125;

$process=new ProcessTest();
$process-&amp;gt;run();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行的效果&lt;br&gt;&lt;img src=&#34;/img/201909/2019-09-19_170643.jpg&#34; alt=&#34;多进行效果&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;pcntl_fork&lt;/p&gt;
&lt;p&gt;函数原型: int pcntl_fork ( void )&lt;/p&gt;
&lt;p&gt;执行该函数，会复制当前进程产生另一个进程，称之为当前进程的子进程，该函数在父进程和子进程的返回值不相同，在父进程中返回的是fork出的子进程的进程ID，而在子进程中返回值为0。&lt;/p&gt;
&lt;p&gt;要注意的是在复制进程时，会复制该进程的数据（堆数据、栈数据和静态数据），包括在父进程打开的文件描述符，在子进程中也是打开的，这意味着当你在父进程使用了大量内存时，fork出来的子进程必须拥有等量的内存资源，否则可能会导致fork失败。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;pcntl_waitpid&lt;/p&gt;
&lt;p&gt;函数原型: int pcntl_waitpid ( int $pid , int &amp;amp;$status [, int $options = 0 ] )&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pid: 进程ID&lt;/li&gt;
&lt;li&gt;status: 子进程的退出状态&lt;/li&gt;
&lt;li&gt;option: 取决于操作系统是否提供wait3函数，如果提供该函数，则该选项参数才生效.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面的进程还是有缺陷，处理多任务时并不太合适。&lt;br&gt;就用一个非常简单的leader-follower模型，创建一个进程池，随机选出一个进程作为leader进程，该进程监听是否有新连接，如果有则提升另一个follower为leader进程来继续监听，而原leader进程则去处理新连接的请求&lt;/p&gt;
&lt;p&gt;socket多任务示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php


class StreamSocketServer
&amp;#123;
    protected $address;
    protected $port;

    public function __construct($address=&amp;#39;127.0.0.1&amp;#39;,$port=8080)
    &amp;#123;
        $this-&amp;gt;address=$address;
        $this-&amp;gt;port=$port;
    &amp;#125;

    public function startSocket()&amp;#123;
        $socket=stream_socket_server(&amp;quot;tcp://&amp;quot;.$this-&amp;gt;address.&amp;quot;:&amp;quot;.$this-&amp;gt;port,$errno,$errstr);
        $data=&amp;quot;&amp;#123;&amp;#39;code&amp;#39;:100020,&amp;#39;msg&amp;#39;:&amp;#39;ok&amp;#39;,&amp;#39;data&amp;#39;:&amp;#123;&amp;#39;name&amp;#39;:&amp;#39;艾瑞可erik&amp;#39;,&amp;#39;url&amp;#39;:&amp;#39;https://erik.xyz&amp;#39;&amp;#125;&amp;#125;&amp;quot;;
        $pids=[];
        for($i=0;$i&amp;lt;10;$i++)&amp;#123;
            $pid=pcntl_fork();
            $pids[]=$pid;
            if($pid==0)&amp;#123;
                for ( ; ; ) &amp;#123;
                    $conn = stream_socket_accept($socket);

                    $write_buffer = &amp;quot;HTTP/1.0 200 OK\r\nServer: my_server\r\nContent-Type: text/html; charset=utf-8\r\n\r\n&amp;quot;.$data;

                    fwrite($conn, $write_buffer);

                    fclose($conn);
                &amp;#125;
                exit(&amp;quot;结束了\n&amp;quot;);
            &amp;#125;
        &amp;#125;

        foreach ($pids as $pid)&amp;#123;
            pcntl_waitpid($pid,$status);
        &amp;#125;
    &amp;#125;

    public function run()&amp;#123;
        $this-&amp;gt;startSocket();
    &amp;#125;
&amp;#125;

$socket=new StreamSocketServer();
$socket-&amp;gt;run();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/201909/2019-09-19_173231.jpg&#34; alt=&#34;多任务运行socket&#34;&gt;&lt;/p&gt;
&lt;p&gt;运行10个任务没问题，但是多进程是消耗cpu资源的，如果任务多，进程不断的增加，服务器是无法承受的。这时候多进程处理大的并发就不合适了。那就用IO复用。&lt;/p&gt;
&lt;h3 id=&#34;IO复用&#34;&gt;&lt;a href=&#34;#IO复用&#34; class=&#34;headerlink&#34; title=&#34;IO复用&#34;&gt;&lt;/a&gt;IO复用&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;阻塞／非阻塞&lt;/p&gt;
&lt;p&gt;这两个概念是针对 IO 过程中进程的状态来说的，阻塞 IO 是指调用结果返回之前，当前线程会被挂起；相反，非阻塞指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;同步／异步&lt;/p&gt;
&lt;p&gt;这两个概念是针对调用如果返回结果来说的，所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回；相反，当一个异步过程调用发出后，调用者不能立刻得到结果，实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;阻塞与非阻塞&lt;/p&gt;
&lt;p&gt;在介绍IO复用技术之前，先介绍一下阻塞和非阻塞，在我们前几节的WEB服务器中，调用socket_accept函数会使整个进程阻塞，直到有新连接，操作系统才唤醒进程继续执行。而非阻塞模式, stream_socket_accept的行为就不一样了，如果没有新连接，不会阻塞进程，而是马上返回false。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I/O多路复用&lt;/p&gt;
&lt;p&gt;多路复用（IO/Multiplexing）：为了提高数据信息在网络通信线路中传输的效率，在一条物理通信线路上建立多条逻辑通信信道，同时传输若干路信号的技术就叫做多路复用技术。对于 Socket 来说，应该说能同时处理多个连接的模型都应该被称为多路复用，目前比较常用的有 select/poll/epoll/kqueue 这些 IO 模型（目前也有像 Apache 这种每个连接用单独的进程/线程来处理的 IO 模型，但是效率相对比较差，也很容易出问题，所以暂时不做介绍了）。在这些多路复用的模式中，异步阻塞/非阻塞模式的扩展性和性能最好。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;select 轮询 &lt;/p&gt;
&lt;p&gt;使用select会轮询连接池，当有连接可读或可写时，select函数返回可读写的连接数，然后再轮询一遍连接池，查找活动连接进行读写操作&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;socket_select只支持socket类型的资源，而不支持stream类型的资源，所以这里需要使用socket_create创建socket资源&lt;/p&gt;
&lt;p&gt;select轮询示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php

class SocketServer
&amp;#123;
    protected $address;
    protected $port;

    public function __construct($address = &amp;#39;127.0.0.1&amp;#39;, $port = &amp;#39;8080&amp;#39;)
    &amp;#123;
        $this-&amp;gt;address = $address;
        $this-&amp;gt;port = $port;
    &amp;#125;

    public function startSocket()
    &amp;#123;
        $socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);
        socket_bind($socket, $this-&amp;gt;address, $this-&amp;gt;port);
        socket_listen($socket);
        $reads = [];
        $clients = [];
        $writes = null;
        $exceptions = null;
        socket_set_nonblock($socket);
        $write_buffer = &amp;quot;HTTP/1.0 200 OK\r\nServer: my_server\r\nContent-Type: text/html; charset=utf-8\r\n\r\n&amp;#123;&amp;#39;code&amp;#39;:100,&amp;#39;data&amp;#39;:&amp;#123;&amp;#39;name&amp;#39;:&amp;#39;艾瑞可erik&amp;#39;&amp;#125;,&amp;#39;msg&amp;#39;:&amp;#39;ok&amp;#39;&amp;#125;&amp;quot;;
        for (; ;) &amp;#123;
            $reads = array_merge(array($socket), $clients);
            $activity_counts = socket_select($reads, $writes, $exceptions, 0);
            if ($activity_counts &amp;gt; 0) &amp;#123;
                if (($conn = socket_accept($socket)) !== false) &amp;#123;
                    $clients[] = $conn;
                &amp;#125;
            &amp;#125;
            $this-&amp;gt;client($clients,$write_buffer);
        &amp;#125;
    &amp;#125;

    /**
     * @param $clients
     * @param $write_buffer
     */
    public function client($clients,$write_buffer)&amp;#123;
        $length = count($clients);
        for ($i = 0; $i &amp;lt; $length; $i++) &amp;#123;
            $client = $clients[$i];
            if (($read_buff = socket_read($client, 1024))!=false) &amp;#123;
                socket_write($client, $write_buffer);
                socket_close($client);
                break;
            &amp;#125;
        &amp;#125;
    &amp;#125;

    public function run()
    &amp;#123;
        $this-&amp;gt;startSocket();
    &amp;#125;
&amp;#125;

$sock = new SocketServer();
$sock-&amp;gt;run();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;select虽然可以监听多个连接，但是它最多只能监听1024个连接。这虽然在poll中得到了改进，但是select和poll本质上都是通过轮询的方式进行监听，这意味着当监听了上万连接时，就算只有一个连接是活动的，依然要把上万连接都遍历一次。显然，这无疑是极大的性能浪费，而epoll的出现彻底地解决了这个问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;epoll&lt;br&gt;epoll并不是只有一个函数来实现，而是多个函数。我们这里并不讨论epoll相关的函数，因为PHP并不提供相关的函数，但它提供了基于libevent库的libevent扩展，以及基于libevent库的event扩展。libevent库实现了Reactor模型，关于Reactor模型，这里只作简单的介绍&lt;/p&gt;
&lt;p&gt;Reactor模型，包含了几个组件：句柄，事件分发器，事件处理器。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;句柄，就是文件描述符，在Socket编程中，就是使用socket_create创建的socket资源.&lt;/li&gt;
&lt;li&gt;事件分发器, 通过事件循环，事件循环是通过诸如epoll&lt;code&gt;Select&lt;/code&gt;Poll等IO复用技术实现的，监听句柄期待的事件是否发生，发生了则将事件分发给事件处理器.&lt;/li&gt;
&lt;li&gt;事件处理器，当事件发生时，处理相关的逻辑.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;  libevent库已经实现了Reactor模型，安装event扩展即可。&lt;/p&gt;
&lt;p&gt;  示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php

$address = &amp;#39;127.0.0.1&amp;#39;;
$port = 8080;

//创建句柄
$data = &amp;quot;&amp;#123;&amp;#39;code&amp;#39;:100020,&amp;#39;msg&amp;#39;:&amp;#39;ok&amp;#39;,&amp;#39;data&amp;#39;:&amp;#123;&amp;#39;name&amp;#39;:&amp;#39;艾瑞可erik&amp;#39;,&amp;#39;url&amp;#39;:&amp;#39;https://erik.xyz&amp;#39;&amp;#125;&amp;#125;&amp;quot;;
$write_buffer = &amp;quot;HTTP/1.0 200 OK\r\nServer: my_server\r\nContent-Type: text/html; charset=utf-8\r\n\r\n&amp;quot; . $data;
$socket = @stream_socket_server(&amp;quot;tcp://&amp;quot; . $address . &amp;quot;:&amp;quot; . $port, $errno, $errstr);
stream_set_blocking($socket, 0);
//创建事件循环器
$event_base = new EventBase();
//创建事件，并指定事件监听的事件类型及注册事件处理器
$event = new Event($event_base, $socket, Event::READ | Event::PERSIST, function ($socket) use (&amp;amp;$event_base, $write_buffer) &amp;#123;
    $conn = stream_socket_accept($socket);
    fwrite($conn, $write_buffer);
    fclose($conn);
&amp;#125;, $socket);
//向循环器中添加事件
$event-&amp;gt;add();
$event_base-&amp;gt;loop();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在浏览器运行请求，或者用工具检测。&lt;/p&gt;
&lt;p&gt;运行结果&lt;br&gt;&lt;img src=&#34;/img/201909/2019-09-19_190045.jpg&#34; alt=&#34;epoll运行结果&#34;&gt;&lt;/p&gt;
&lt;p&gt;这时需要考虑一个问题：如果进程断了怎么办？&lt;/p&gt;
&lt;p&gt;那就需要进程守护。&lt;/p&gt;
&lt;p&gt;一般PPID为0的，都是内核态进程。一般PPID为1的都是守护进程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;守护进程创建的标准流程&lt;br&gt;让WEB服务器进程变为守护进程，成为守护进程有几个标准的步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置文件创建掩码，一般设置为0，umask(0)&lt;/li&gt;
&lt;li&gt;pcntl_fork一个子进程，并马上退出，这样做的目的是让子进程继承进程组ID并获取一个新的进程ID，这样就可以确保子进程一定不是进程组组长，因为进程组组长不能创建新会话&lt;/li&gt;
&lt;li&gt;posix_setsid创建新会话和新进程组，并成为会话组长和进程组组长，并和原来的控制终端脱离关系，这样该进程就不会被原来终端的控制信号中断&lt;/li&gt;
&lt;li&gt;pcntl_fork，再fork一次并不是必须的，只是在基于System-V的系统上，有人建议再fork一次，避免打开终端设备，使程序的通用性更强。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;守护进程示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;?php
  header(&amp;#39;Content-type:text/html;charset:utf-8&amp;#39;);
  //守护进程
  function daemon()&amp;#123;
      umask(0);
      //创建进程，并退出进程
      if(pcntl_fork())&amp;#123;
          exit(&amp;quot;退出进程\n&amp;quot;);
      &amp;#125;

      //创建新的会话和进程组,并退出原来的控制端
      posix_setsid();

      //再次创建进程，并退出
      if(pcntl_fork())&amp;#123;
          exit(&amp;quot;再次创建进程，并退出\n&amp;quot;);
      &amp;#125;
  &amp;#125;
  daemon();

  $address = &amp;#39;127.0.0.1&amp;#39;;
  $port = 8080;

  //创建句柄
  $data = &amp;quot;&amp;#123;&amp;#39;code&amp;#39;:100020,&amp;#39;msg&amp;#39;:&amp;#39;ok&amp;#39;,&amp;#39;data&amp;#39;:&amp;#123;&amp;#39;name&amp;#39;:&amp;#39;艾瑞可erik&amp;#39;,&amp;#39;url&amp;#39;:&amp;#39;https://erik.xyz&amp;#39;&amp;#125;&amp;#125;&amp;quot;;
  $write_buffer = &amp;quot;HTTP/1.0 200 OK\r\nServer: my_server\r\nContent-Type: text/html; charset=utf-8\r\n\r\n&amp;quot; . $data;
  $socket = @stream_socket_server(&amp;quot;tcp://&amp;quot; . $address . &amp;quot;:&amp;quot; . $port, $errno, $errstr);
  stream_set_blocking($socket, 0);
  //创建事件循环器
  $event_base = new EventBase();
  //创建事件，并指定事件监听的事件类型及注册事件处理器
  $event = new Event($event_base, $socket, Event::READ | Event::PERSIST, function ($socket) use (&amp;amp;$event_base, $write_buffer) &amp;#123;
      $conn = stream_socket_accept($socket);
      fwrite($conn, $write_buffer);
      fclose($conn);
  &amp;#125;, $socket);
  //向循环器中添加事件
  $event-&amp;gt;add();
  $event_base-&amp;gt;loop();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  运行结果&lt;/p&gt;
&lt;p&gt;  &lt;img src=&#34;/img/201909/2019-09-19_213853.jpg&#34; alt=&#34;守护进程运行结果&#34;&gt;&lt;/p&gt;
&lt;p&gt;  那么守护进程有了，如何重启、关闭呢。那就调用函数发送信号&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;posix_kill&lt;br&gt;函数原型: bool posix_kill ( int $pid , int $sig )&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pid: 进程ID&lt;/li&gt;
&lt;li&gt;sig: 系统预定义的信号常量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;pcntl_signal&lt;br&gt;函数原型: bool pcntl_signal ( int $signo , callback $handler [, bool $restart_syscalls = true ] )&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;signo: 系统预定义的信号常量&lt;/li&gt;
&lt;li&gt;handler: 信号处理器，一个回调函数&lt;/li&gt;
&lt;li&gt;restart_syscalls: 当进程在进行系统调用时，被信号中断时，系统调用是否重新调用，一般默认为true&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;  那么根据以上几个步骤，我做个整合。完整版的socket进程及多进程控制&lt;/p&gt;
&lt;p&gt; EventServer&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;?php

class EventServer
&amp;#123;
    public $event_base;
    public $events = [];

    public function __construct()
    &amp;#123;
        $this-&amp;gt;event_base = new EventBase();
    &amp;#125;

    public function add($fd, $what, $callback, $callback_arg)
    &amp;#123;
        $event = new Event($this-&amp;gt;event_base, $fd, $what, $callback, $callback_arg);
        $this-&amp;gt;events[intval($fd)] = $event;
        $event-&amp;gt;add();
    &amp;#125;

    public function remove($fb)
    &amp;#123;
        $event = $this-&amp;gt;events[intval($fb)];
        $event-&amp;gt;free();
    &amp;#125;

    public function loop()
    &amp;#123;
        $this-&amp;gt;event_base-&amp;gt;loop();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;StreamServer&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php

require &amp;quot;EventServer.php&amp;quot;;

class StreamServer
&amp;#123;
    protected $ip = &amp;#39;127.0.0.1&amp;#39;;
    protected $port = 8080;
    protected $path = &amp;#39;./pid.txt&amp;#39;;
    protected $event;
    protected $data = &amp;quot;&amp;#123;&amp;#39;code&amp;#39;:100020,&amp;#39;msg&amp;#39;:&amp;#39;ok&amp;#39;,&amp;#39;data&amp;#39;:&amp;#123;&amp;#39;name&amp;#39;:&amp;#39;艾瑞可erik&amp;#39;,&amp;#39;url&amp;#39;:&amp;#39;https://erik.xyz&amp;#39;&amp;#125;&amp;#125;&amp;quot;;
    protected $write_buffer = &amp;quot;HTTP/1.0 200 OK\r\nServer: my_server\r\nContent-Type: text/html; charset=utf-8\r\n\r\n&amp;quot;;


    public static function daemon()
    &amp;#123;
        umask(0);

        $pid = pcntl_fork();

        if ($pid) &amp;#123;
            exit(0);
        &amp;#125; elseif ($pid &amp;lt; 0) &amp;#123;
            die(&amp;quot;进程启动失败\n&amp;quot;);
        &amp;#125;

        $sid = posix_setsid();

        $pid = pcntl_fork();

        if ($pid) &amp;#123;
            exit(0);
        &amp;#125; elseif ($pid &amp;lt; 0) &amp;#123;
            die(&amp;quot;进程启动失败\n&amp;quot;);
        &amp;#125;

        if ($sid &amp;lt; 0) &amp;#123;
            die(&amp;quot;创建服务失败\n&amp;quot;);
        &amp;#125;
    &amp;#125;

    public function __construct($ip, $port = 80)
    &amp;#123;
        $this-&amp;gt;ip = $ip;
        $this-&amp;gt;port = $port;
        $this-&amp;gt;event = new EventServer();
    &amp;#125;

    /**
     * 启动
     */
    public function run()
    &amp;#123;
        if ($GLOBALS[&amp;#39;argc&amp;#39;] &amp;gt; 1) &amp;#123;
            $this-&amp;gt;sendSignal();
            exit(0);
        &amp;#125; else &amp;#123;
            self::daemon();
        &amp;#125;

        $this-&amp;gt;installSignalHandler();
        $this-&amp;gt;recordPid();
        $this-&amp;gt;start();
    &amp;#125;

    //存储信号
    public function sendSignal()
    &amp;#123;
        if (posix_kill($this-&amp;gt;getPid(), 0)) &amp;#123;
            if (strpos($GLOBALS[&amp;#39;argv&amp;#39;][1], &amp;quot;stop&amp;quot;) !== false) &amp;#123;
                posix_kill($this-&amp;gt;getPid(), SIGUSR1);
            &amp;#125;
        &amp;#125;
    &amp;#125;

    //启动进程
    public function start()
    &amp;#123;
        $domain = sprintf(&amp;quot;tcp://%s:%d&amp;quot;, $this-&amp;gt;ip, $this-&amp;gt;port);

        $fd = stream_socket_server($domain, $errno, $errstr);

        if (!$fd) &amp;#123;
            die(&amp;quot;$errno $errstr\n&amp;quot;);
        &amp;#125;

        stream_set_blocking($fd, 0);

        $this-&amp;gt;event-&amp;gt;add($fd, Event::READ | Event::PERSIST, [$this, &amp;#39;requestHandler&amp;#39;], $fd);

        $this-&amp;gt;event-&amp;gt;loop();
    &amp;#125;

    /**响应信息
     * @param $fd
     */
    public function requestHandler($fd)
    &amp;#123;
        $write_buffer = $this-&amp;gt;write_buffer . $this-&amp;gt;data;
        $conn = stream_socket_accept($fd);
        fwrite($conn, $write_buffer);
        fclose($conn);
    &amp;#125;

    //添加信号
    public function installSignalHandler()
    &amp;#123;
        $this-&amp;gt;event-&amp;gt;add(SIGUSR1, Event::SIGNAL, [$this, &amp;quot;handler&amp;quot;], SIGUSR1);
    &amp;#125;

    /**终止信号
     * @param $signo
     */
    public function handler($signo)
    &amp;#123;
        switch ($signo) &amp;#123;
            default:
            case SIGUSR1:
                $this-&amp;gt;event-&amp;gt;remove($signo);
                $this-&amp;gt;stop();
                break;
        &amp;#125;
    &amp;#125;

    public function stop()
    &amp;#123;
        exit(&amp;quot;终止信号\n&amp;quot;);
    &amp;#125;

    public function getPid()
    &amp;#123;
        return file_get_contents($this-&amp;gt;path);
    &amp;#125;

    private function recordPid()
    &amp;#123;
        file_put_contents($this-&amp;gt;path, posix_getpid());
    &amp;#125;
&amp;#125;

$server = new StreamServer(&amp;quot;127.0.0.1&amp;quot;, 8080);
$server-&amp;gt;run();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/201909/2019-09-19_232908.jpg&#34; alt=&#34;最终执行结果&#34;&gt;&lt;/p&gt;
</content>
        <category term="socket通信" />
        <category term="socket多进程" />
        <category term="socket" />
        <updated>2019-09-18T05:31:00.000Z</updated>
    </entry>
</feed>