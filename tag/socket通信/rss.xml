<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>艾瑞可erik • Posts by &#34;socket通信&#34; tag • Posts by &#34;undefined&#34; categories</title>
        <link>https://erik.xyz</link>
        <description>一只PHP开发的程序猿，偶尔做做运维、Goland、Python、Java、摄影、画画、写作、顺便睡觉，反正整站都搞过。</description>
        <language>zh-CN</language>
        <pubDate>Wed, 18 Sep 2019 13:31:00 +0800</pubDate>
        <lastBuildDate>Wed, 18 Sep 2019 13:31:00 +0800</lastBuildDate>
        <category>日志</category>
        <category>工具</category>
        <category>jquery</category>
        <category>jquery插件</category>
        <category>js</category>
        <category>css</category>
        <category>php</category>
        <category>web</category>
        <category>代码</category>
        <category>压缩</category>
        <category>php扩展</category>
        <category>php技巧</category>
        <category>php类库</category>
        <category>php资源</category>
        <category>说说</category>
        <category>趣闻</category>
        <category>php服务器</category>
        <category>随笔</category>
        <category>php实例</category>
        <category>php库</category>
        <category>转载</category>
        <category>互联</category>
        <category>项目实战</category>
        <category>nginx</category>
        <category>javascript</category>
        <category>漏洞</category>
        <category>php应用</category>
        <category>浮点</category>
        <category>负载均衡</category>
        <category>kali</category>
        <category>kali安装</category>
        <category>http</category>
        <category>http服务器</category>
        <category>农业系统</category>
        <category>系统设计</category>
        <category>克莱姆法则</category>
        <category>行列式</category>
        <category>n阶行列式</category>
        <category>支付系统</category>
        <category>支付</category>
        <category>centos</category>
        <category>linux</category>
        <category>apache优化</category>
        <category>apache隐藏index</category>
        <category>nginx优化</category>
        <category>nginx隐藏index</category>
        <category>seo</category>
        <category>优化</category>
        <category>日常</category>
        <category>摘要</category>
        <category>文章</category>
        <category>游记</category>
        <category>ca证书</category>
        <category>证书生成</category>
        <category>二战</category>
        <category>二战熊</category>
        <category>西伯利亚熊</category>
        <category>centos软件</category>
        <category>yum仓库</category>
        <category>软件</category>
        <category>centos安装chromium报错</category>
        <category>chromium安装报错</category>
        <category>svn</category>
        <category>代码提交</category>
        <category>deb</category>
        <category>deb/rpm互转</category>
        <category>deb转rpm</category>
        <category>rpm互转</category>
        <category>centos7安装steam</category>
        <category>centos安装steam</category>
        <category>centos安装吃鸡steam</category>
        <category>linux安装steam</category>
        <category>steam安装</category>
        <category>centos软件安装</category>
        <category>centos6.5</category>
        <category>linux系统</category>
        <category>centos7安装Redis Desktop Manager</category>
        <category>centos7安装redis桌面</category>
        <category>centos安装redis桌面</category>
        <category>linux安装centos7安装Redis Desktop Manager</category>
        <category>Redis Desktop Manager</category>
        <category>redis桌面</category>
        <category>centos7</category>
        <category>centos7-wine</category>
        <category>wine</category>
        <category>wine安装</category>
        <category>root密码</category>
        <category>root密码重置</category>
        <category>忘记root密码</category>
        <category>memcache</category>
        <category>memcached</category>
        <category>生活手记</category>
        <category>艾瑞可erik</category>
        <category>程序员</category>
        <category>开源云</category>
        <category>容器</category>
        <category>cncf</category>
        <category>监控</category>
        <category>composer</category>
        <category>composer部署</category>
        <category>内网部署composer</category>
        <category>cphalcon</category>
        <category>cphalcon报错</category>
        <category>css中的em</category>
        <category>响应式字体</category>
        <category>响应式布局样式</category>
        <category>proxy代理搭建</category>
        <category>代理服务器搭建</category>
        <category>proxy服务器</category>
        <category>查找</category>
        <category>排序</category>
        <category>快速排序</category>
        <category>冒泡排序</category>
        <category>二分查找</category>
        <category>datahub</category>
        <category>datahub安装</category>
        <category>deepin</category>
        <category>emergency</category>
        <category>emergency mode</category>
        <category>deepin黑屏</category>
        <category>清理系统</category>
        <category>清理c盘</category>
        <category>dns</category>
        <category>域名监测</category>
        <category>网站监测</category>
        <category>docker</category>
        <category>php安装</category>
        <category>杂谈</category>
        <category>ecshop</category>
        <category>框架</category>
        <category>beego数据分页</category>
        <category>分页</category>
        <category>elasticsearch</category>
        <category>elasticsearch搭建</category>
        <category>elasticsearch集群</category>
        <category>系统</category>
        <category>emm</category>
        <category>mdm</category>
        <category>phone</category>
        <category>手机</category>
        <category>新闻</category>
        <category>免费</category>
        <category>jenkis</category>
        <category>jenkis教程</category>
        <category>随笔吐槽</category>
        <category>算法</category>
        <category>ping</category>
        <category>ping服务器</category>
        <category>各大网站ping</category>
        <category>搜引擎ping服务器</category>
        <category>go获取ip</category>
        <category>im</category>
        <category>go中pdf生成</category>
        <category>go中限流</category>
        <category>go对接快递签名</category>
        <category>go时间获取</category>
        <category>go类型转换</category>
        <category>微服务</category>
        <category>go-zero</category>
        <category>rpc</category>
        <category>go加密</category>
        <category>go解密</category>
        <category>归</category>
        <category>吐槽</category>
        <category>php大全</category>
        <category>php资料</category>
        <category>hadoop</category>
        <category>hadoop2.8.0</category>
        <category>hadoop安装教程</category>
        <category>hadoop安装详细教程</category>
        <category>hadoop教程</category>
        <category>hadoop部署</category>
        <category>hadoop3</category>
        <category>hadoop配置</category>
        <category>log4j2</category>
        <category>数据库</category>
        <category>hbase安装教程</category>
        <category>hbase</category>
        <category>http1.1</category>
        <category>http2.0</category>
        <category>会话</category>
        <category>会话原理</category>
        <category>hyperf</category>
        <category>杂录</category>
        <category>新冠肺炎</category>
        <category>springboot</category>
        <category>springboot内网部署</category>
        <category>linux恢复</category>
        <category>linux误删</category>
        <category>linux命令</category>
        <category>linux命令汇总</category>
        <category>jenkins</category>
        <category>jetbtrains</category>
        <category>phpstorm</category>
        <category>搜索引擎</category>
        <category>图片</category>
        <category>素材</category>
        <category>jq</category>
        <category>jq侧边导航</category>
        <category>侧边导航</category>
        <category>js判断浏览器</category>
        <category>js判断浏览器版本</category>
        <category>判断浏览器</category>
        <category>浏览器版本判断</category>
        <category>获取浏览器信息</category>
        <category>kali右键汉化</category>
        <category>kali桌面右键汉化</category>
        <category>kali右键创建文件</category>
        <category>区块链</category>
        <category>lanmp</category>
        <category>php环境独立配置</category>
        <category>服务器</category>
        <category>劳动纠纷</category>
        <category>追缴工资</category>
        <category>申请仲裁</category>
        <category>flash</category>
        <category>表单</category>
        <category>linux报错</category>
        <category>linux中update-command-not-found</category>
        <category>linux运行命令报错</category>
        <category>web前端</category>
        <category>web优化</category>
        <category>撮合算法</category>
        <category>撮合</category>
        <category>php撮合算法</category>
        <category>maven搭建库</category>
        <category>maven</category>
        <category>maven内网库</category>
        <category>高级缓存配置</category>
        <category>mongodb</category>
        <category>mongodb权限</category>
        <category>可穿戴设备</category>
        <category>mysql</category>
        <category>分库分表</category>
        <category>mysql应对千万级</category>
        <category>mysql瓶颈</category>
        <category>mysql瓶颈解决办法</category>
        <category>redis</category>
        <category>数据一致性</category>
        <category>mysql消息</category>
        <category>mysql队列</category>
        <category>mysql高并发</category>
        <category>mysql存储</category>
        <category>mysql引擎</category>
        <category>mysql数据表设计选择</category>
        <category>mysql监控</category>
        <category>mysql性能</category>
        <category>内网支付</category>
        <category>内网穿透</category>
        <category>支付接口本地化开发</category>
        <category>本地挂网</category>
        <category>穿透</category>
        <category>go</category>
        <category>new和make的区别</category>
        <category>红包算法</category>
        <category>深圳劳动法服务部门</category>
        <category>非关系型数据库</category>
        <category>onethink</category>
        <category>oop</category>
        <category>php管理系统</category>
        <category>开放接口开发</category>
        <category>开源工具</category>
        <category>桌面共享工具</category>
        <category>openresty</category>
        <category>openvas</category>
        <category>openvas安装</category>
        <category>php变量</category>
        <category>php超级全局变量</category>
        <category>php超级变量</category>
        <category>php基本类型</category>
        <category>php数据类型</category>
        <category>php设计模式</category>
        <category>php对接微信支付</category>
        <category>微信支付</category>
        <category>微信支付回调</category>
        <category>游戏</category>
        <category>php函数</category>
        <category>php随机数</category>
        <category>php获取闰年</category>
        <category>闰年.php时间</category>
        <category>php环境</category>
        <category>php集成环境</category>
        <category>服务器集成环境</category>
        <category>数组函数</category>
        <category>数组排序函数</category>
        <category>php数学函数</category>
        <category>php面试题</category>
        <category>php面向对象</category>
        <category>面向对象</category>
        <category>php-zookeeper</category>
        <category>zookeeper3.5.5</category>
        <category>php-zookeeper扩展</category>
        <category>php串口开发</category>
        <category>php倒计时</category>
        <category>php时间</category>
        <category>倒计时</category>
        <category>计算时间</category>
        <category>PHP数组</category>
        <category>字符串函数</category>
        <category>排序函数</category>
        <category>php的SPL</category>
        <category>SPL手册</category>
        <category>PHP算法</category>
        <category>php递归</category>
        <category>递归</category>
        <category>phpunit</category>
        <category>phpunit安装</category>
        <category>php过滤</category>
        <category>过滤</category>
        <category>foreach</category>
        <category>foreach报错</category>
        <category>php中foreach报错</category>
        <category>php中if</category>
        <category>php中if判断</category>
        <category>php的if</category>
        <category>php字符串</category>
        <category>php7中sphinx</category>
        <category>php7中sphinx扩展</category>
        <category>sphinx扩展</category>
        <category>python</category>
        <category>python库</category>
        <category>a标签</category>
        <category>a标签虚线</category>
        <category>虚线框</category>
        <category>R语言</category>
        <category>数据随机化</category>
        <category>redis总结</category>
        <category>redis命令</category>
        <category>redis监控</category>
        <category>redis锁</category>
        <category>redis分布式锁</category>
        <category>任意金额输入</category>
        <category>10元、5元、2元</category>
        <category>队列</category>
        <category>栈</category>
        <category>顺序表</category>
        <category>链表</category>
        <category>数据结构</category>
        <category>线性结构</category>
        <category>浏览器禁止操作视频</category>
        <category>禁止视频</category>
        <category>响应慢</category>
        <category>页面优化</category>
        <category>js编辑</category>
        <category>runjs</category>
        <category>在线编辑</category>
        <category>rust</category>
        <category>rust配置</category>
        <category>seajs</category>
        <category>session</category>
        <category>路由器烧录</category>
        <category>烧录</category>
        <category>极路由2烧录</category>
        <category>砖头烧录</category>
        <category>免费服务器</category>
        <category>空间</category>
        <category>资源</category>
        <category>深圳政府电话</category>
        <category>深圳电话</category>
        <category>特区电话</category>
        <category>居住证</category>
        <category>居住证签注</category>
        <category>深圳新居住证</category>
        <category>国庆骑行</category>
        <category>深圳珠海骑行</category>
        <category>骑行</category>
        <category>世界那么大</category>
        <category>css3</category>
        <category>css在线生成工具</category>
        <category>css工具</category>
        <category>php正则</category>
        <category>正则</category>
        <category>shodan</category>
        <category>黑谷歌</category>
        <category>黒帽搜素</category>
        <category>shopex</category>
        <category>可视化数据</category>
        <category>数据</category>
        <category>数据表</category>
        <category>socket通信</category>
        <category>socket多进程</category>
        <category>socket</category>
        <category>json</category>
        <category>json数组</category>
        <category>json解析</category>
        <category>sql</category>
        <category>sql优化</category>
        <category>css3兼容360浏览器兼容模式</category>
        <category>css圆角</category>
        <category>结构体转map</category>
        <category>config</category>
        <category>thinkphp</category>
        <category>配置文件</category>
        <category>树</category>
        <category>二叉树</category>
        <category>js插件</category>
        <category>web自适应</category>
        <category>响应式布局</category>
        <category>响应式所有分辨率</category>
        <category>自适应布局</category>
        <category>自适应所有分辨率</category>
        <category>webman</category>
        <category>mysql设置超时，超时</category>
        <category>markdown</category>
        <category>wget</category>
        <category>wget抓取</category>
        <category>网站抓取</category>
        <category>我在</category>
        <category>wordpress</category>
        <category>wordpress标签</category>
        <category>域名合并</category>
        <category>wpscan</category>
        <category>usbrip</category>
        <category>无限极分类</category>
        <category>php无限极</category>
        <category>分类tree</category>
        <category>无限极分类树型</category>
        <category>xhprof</category>
        <category>laravel</category>
        <category>composer插件</category>
        <category>html</category>
        <category>响应式分辨率</category>
        <category>响应式调试</category>
        <category>自适应屏幕</category>
        <category>携程</category>
        <category>携程攻击</category>
        <category>携程网站瘫痪</category>
        <category>物理删除</category>
        <category>3D</category>
        <category>动画</category>
        <category>平台</category>
        <category>虚幻4引擎编辑</category>
        <category>生成唯一id</category>
        <category>生成id</category>
        <category>发邮件</category>
        <category>邮件函数</category>
        <category>储蓄卡免年费</category>
        <category>银行卡</category>
        <category>银行卡免年费</category>
        <category>composer安装</category>
        <category>composer配置</category>
        <category>项目创建composer</category>
        <category>mysql优化</category>
        <category>mysql读写优化</category>
        <category>数据库优化，mysql语句优化</category>
        <category>php加密</category>
        <category>php技术</category>
        <category>夕阳</category>
        <category>mysql函数</category>
        <category>php中mysql函数</category>
        <category>互联网时代</category>
        <category>开源技术</category>
        <category>web框架</category>
        <category>php抓取图片</category>
        <category>php批量抓取页面图片</category>
        <category>邮箱服务器</category>
        <category>正则表达式</category>
        <category>翻墙</category>
        <category>谷歌</category>
        <category>谷歌搜索</category>
        <item>
            <guid isPermalink="true">https://erik.xyz/2019/09/18/socket-jin-cheng-tong-xin-ji-zhi/</guid>
            <title>socket进程通信及多进程</title>
            <link>https://erik.xyz/2019/09/18/socket-jin-cheng-tong-xin-ji-zhi/</link>
            <category>socket通信</category>
            <category>socket多进程</category>
            <category>socket</category>
            <pubDate>Wed, 18 Sep 2019 13:31:00 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;socket是操作系统提供的通信层的一组抽象API&lt;/p&gt;
&lt;h4 id=&#34;函数介绍&#34;&gt;&lt;a href=&#34;#函数介绍&#34; class=&#34;headerlink&#34; title=&#34;函数介绍&#34;&gt;&lt;/a&gt;函数介绍&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;socket_create(int $domain , int $type , int $protocol)  &lt;/p&gt;
&lt;p&gt;正确时返回一个套接字(通讯），失败时返回 FALSE。要读取错误代码，可以调用 socket_last_error()。这个错误代码可以通过 socket_strerror() 读取文字的错误说明。&lt;/p&gt;
&lt;p&gt;创建一个通讯节点，socket_create包含三个参数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$domain  指定哪个协议用在当前套接字(通讯节点)，有以下三种：&lt;ul&gt;
&lt;li&gt;AF_INET：IPv4网络协议。TCP 和 UDP 都可使用此协议。&lt;/li&gt;
&lt;li&gt;AF_INET6：    IPv6网络协议。TCP 和 UDP 都可使用此协议。&lt;/li&gt;
&lt;li&gt;AF_UNIX：        本地通讯协议。具有高性能和低成本的 IPC（进程间通讯）。&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;$type  选择套接字(通讯节点)使用的类型，有以下五种：&lt;ul&gt;
&lt;li&gt;SOCK_STREAM：提供一个顺序化的、可靠的、全双工的、基于连接的字节流。支持数据传送流量控制机制。TCP 协议即基于这种流式套接字。&lt;/li&gt;
&lt;li&gt;SOCK_DGRAM：提供数据报文的支持。(无连接，不可靠、固定最大长度).UDP协议即基于这种数据报文套接字。&lt;/li&gt;
&lt;li&gt;SOCK_SEQPACKET：提供一个顺序化的、可靠的、全双工的、面向连接的、固定最大长度的数据通信；数据端通过接收每一个数据段来读取整个数据包。&lt;/li&gt;
&lt;li&gt;SOCK_RAW：提供读取原始的网络协议。这种特殊的套接字可用于手工构建任意类型的协议。一般使用这个套接字来实现 ICMP 请求（例如 ping）。&lt;/li&gt;
&lt;li&gt;SOCK_RDM：提供一个可靠的数据层，但不保证到达顺序。一般的操作系统都未实现此功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;$protocol 设定$domain套接字(通讯节点)下的具体协议。这个值可以使用 getprotobyname() 函数进行读取。如果所需的协议是 TCP 或 UDP，可以直接使用常量 SOL_TCP 和 SOL_UDP 。&lt;ul&gt;
&lt;li&gt;icmp：Internet Control Message Protocol 主要用于网关和主机报告错误的数据通信。&lt;/li&gt;
&lt;li&gt;udp(SOL_UDP)：User Datagram Protocol 是一个无连接的、不可靠的、具有固定最大长度的报文协议。&lt;/li&gt;
&lt;li&gt;tcp(SOL_TCP)：Transmission Control Protocol 是一个可靠的、基于连接的、面向数据流的全双工协议&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;socket_set_option ( resource $socket , int $level , int $optname , mixed $optval ) &lt;/p&gt;
&lt;p&gt;成功时返回 TRUE， 或者在失败时返回 FALSE。&lt;/p&gt;
&lt;p&gt;设置套接字的套接字选项&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$socket: 套接节(通讯节点)&lt;/li&gt;
&lt;li&gt;$level: 指定选项所在的协议级别&lt;/li&gt;
&lt;li&gt;$optname: 可用的套接字选项与 socket_get_option() 选项相同&lt;/li&gt;
&lt;li&gt;$optval: 可选项值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;socket_read ( resource $socket , int $length [, int $type = PHP_BINARY_READ ] ) 从套接字读取最大长度字节&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$socket: 套接节(通讯节点)&lt;/li&gt;
&lt;li&gt;$length: socket资源中的buffer的长度&lt;/li&gt;
&lt;li&gt;$type: 可选类型参数&lt;ul&gt;
&lt;li&gt;PHP_BINARY_READ   默认值，安全的读取二进制数&lt;/li&gt;
&lt;li&gt;PHP_NORMAL_READ   读取停止&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;socket_getpeername ( resource $socket , string &amp;amp;$address [, int &amp;amp;$port ] )  查询远端套接字&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$socket: 套接节(通讯节点)&lt;/li&gt;
&lt;li&gt;$address: 查询地址&lt;/li&gt;
&lt;li&gt;$port: 查询端口(非必填)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;socket_recv ( resource $socket , string &amp;amp;$buf , int $len , int $flags )  从已连接的socket接收数据&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$socket: 套接节(通讯节点)&lt;/li&gt;
&lt;li&gt;$buf: 从socket中获取的数据将被保存在由 buf 制定的变量中&lt;/li&gt;
&lt;li&gt;$len: 长度最多为 len 字节的数据将被接收&lt;/li&gt;
&lt;li&gt;$flags: 可以为下列任意flag的组合:&lt;ul&gt;
&lt;li&gt;MSG_OOB    处理超出边界的数据&lt;/li&gt;
&lt;li&gt;MSG_PEEK    从接受队列的起始位置接收数据，但不将他们从接受队列中移除。&lt;/li&gt;
&lt;li&gt;MSG_WAITALL    在接收到至少 len 字节的数据之前，造成一个阻塞，并暂停脚本运行（block）&lt;/li&gt;
&lt;li&gt;MSG_DONTWAIT    如果制定了该flag，函数将不会造成阻塞，即使在全局设置中指定了阻塞设置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;socket_select ( array &amp;amp;$read , array &amp;amp;$write , array &amp;amp;$except , int $tv_sec [, int $tv_usec = 0 ] )    系统调用给定的套接字数组并指定超时&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$read： 监听读取数组中列出的套接字&lt;/li&gt;
&lt;li&gt;$write： 将监听写入数组中列出的套接字以查看写入是否不会阻塞&lt;/li&gt;
&lt;li&gt;$except：  将监视except数组中列出的套接字是否有异常。&lt;/li&gt;
&lt;li&gt;$tv_sec：  tv_sec和tv_usec一起形成超时参数。 超时是socket_select（）返回之前经过的时间量的上限。 tv_sec可能为零，导致socket_select（）立即返回。 这对轮询非常有用。 如果tv_sec为NULL（无超时），则socket_select（）可以无限期地阻塞。&lt;/li&gt;
&lt;li&gt;$tv_usec  同上&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;socket_accept ( resource $socket )  接受套接字上的连接&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;socket_write ( resource $socket , string $buffer [, int $length = 0 ] )  写入套接字&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$socket: 套接节(通讯节点)&lt;/li&gt;
&lt;li&gt;$buffer：要写入的缓冲区。&lt;/li&gt;
&lt;li&gt;$length：可选参数 长度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;socket_close&lt;/p&gt;
&lt;p&gt;TODO ： 关闭 socket 资源 函数原型: void socket_close ( resource $socket )&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;socket: socket_accept或者socket_create产生的资源，不能用于stream资源的关闭&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;stream_socket_server&lt;/p&gt;
&lt;p&gt;由于创建一个SOCKET的流程总是 socket、bind、listen，所以PHP提供了一个非常方便的函数一次性创建、绑定端口、监听端口&lt;/p&gt;
&lt;p&gt;函数原型: resource stream_socket_server ( string $local_socket [, int &amp;amp;$errno [, string &amp;amp;$errstr [, int $flags = STREAM_SERVER_BIND | STREAM_SERVER_LISTEN [, resource $context ]]]] )&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;local_socket: 协议名://地址:端口号&lt;/li&gt;
&lt;li&gt;errno: 错误码&lt;/li&gt;
&lt;li&gt;errstr: 错误信息&lt;/li&gt;
&lt;li&gt;flags: 只使用该函数的部分功能&lt;/li&gt;
&lt;li&gt;context: 使用stream_context_create函数创建的资源流上下文&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;socket通信示例&#34;&gt;&lt;a href=&#34;#socket通信示例&#34; class=&#34;headerlink&#34; title=&#34;socket通信示例&#34;&gt;&lt;/a&gt;socket通信示例&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;?php


class SocketServer
&amp;#123;
    protected $address;
    protected $port;

    public function __construct($address = &amp;#39;127.0.0.1&amp;#39;, $port = &amp;#39;8080&amp;#39;)
    &amp;#123;
        $this-&amp;gt;address = $address;
        $this-&amp;gt;port = $port;
    &amp;#125;

    public function startSocket()
    &amp;#123;
        $socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);
        socket_bind($socket, $this-&amp;gt;address, $this-&amp;gt;port);
        socket_listen($socket);
        for ( ; ; ) &amp;#123;
            $conn = socket_accept($socket);

            $write_buffer = &amp;quot;HTTP/1.0 200 OK\r\nServer: my_server\r\nContent-Type: text/html; charset=utf-8\r\n\r\n&amp;#123;&amp;#39;code&amp;#39;:100020,&amp;#39;data&amp;#39;:&amp;#123;&amp;#39;name&amp;#39;:&amp;#39;艾瑞可erik&amp;#39;,&amp;#39;url&amp;#39;:&amp;#39;https://erik.xyz&amp;#39;&amp;#125;,&amp;#39;msg&amp;#39;:&amp;#39;ok&amp;#39;&amp;#125;&amp;quot;;

            socket_write($conn, $write_buffer);

            socket_close($conn);
        &amp;#125;
    &amp;#125;

    public function run()&amp;#123;
        $this-&amp;gt;startSocket();
    &amp;#125;
&amp;#125;

$sock=new SocketServer();
$sock-&amp;gt;run();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   运行结果如下：&lt;br&gt;   &lt;img src=&#34;/img/201909/2019-09-19_162558.jpg&#34; alt=&#34;socket运行结果&#34;&gt;&lt;/p&gt;
&lt;p&gt;也可以用stream，即流集成实现。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
      class StreamSocketServer
      &amp;#123;
          protected $address;
          protected $port;

          public function __construct($address=&amp;#39;127.0.0.1&amp;#39;,$port=8080)
          &amp;#123;
              $this-&amp;gt;address=$address;
              $this-&amp;gt;port=$port;
          &amp;#125;

          public function startSocket()&amp;#123;
              $socket=stream_socket_server(&amp;quot;tcp://&amp;quot;.$this-&amp;gt;address.&amp;quot;:&amp;quot;.$this-&amp;gt;port,$errno,$errstr);
              $data=&amp;quot;&amp;#123;&amp;#39;code&amp;#39;:100020,&amp;#39;msg&amp;#39;:&amp;#39;ok&amp;#39;,&amp;#39;data&amp;#39;:&amp;#123;&amp;#39;name&amp;#39;:&amp;#39;艾瑞可erik&amp;#39;,&amp;#39;url&amp;#39;:&amp;#39;https://erik.xyz&amp;#39;&amp;#125;&amp;#125;&amp;quot;;
              for ( ; ; ) &amp;#123;
                  $conn = stream_socket_accept($socket);

                  $write_buffer = &amp;quot;HTTP/1.0 200 OK\r\nServer: my_server\r\nContent-Type: text/html; charset=utf-8\r\n\r\n&amp;quot;.$data;

                  fwrite($conn, $write_buffer);

                  fclose($conn);
              &amp;#125;
          &amp;#125;

          public function run()&amp;#123;
              $this-&amp;gt;startSocket();
          &amp;#125;
      &amp;#125;

      $socket=new StreamSocketServer();
      $socket-&amp;gt;run();
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;多进程&#34;&gt;&lt;a href=&#34;#多进程&#34; class=&#34;headerlink&#34; title=&#34;多进程&#34;&gt;&lt;/a&gt;多进程&lt;/h3&gt;&lt;p&gt;多进程示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
header(&amp;quot;Content-type:text/html;charset=utf-8&amp;quot;);

class ProcessTest
&amp;#123;

    public function add()&amp;#123;
        $pid=pcntl_fork();

        if($pid)&amp;#123;
            echo &amp;quot;这是一个父进程\n&amp;quot;;
            pcntl_waitpid($pid,$status);
        &amp;#125;elseif ($pid==0)&amp;#123;
            echo &amp;quot;这是子进程\n&amp;quot;;
        &amp;#125;else&amp;#123;
            die(&amp;quot;进程结束\n&amp;quot;);
        &amp;#125;
    &amp;#125;

    public function run()&amp;#123;
        $this-&amp;gt;add();
    &amp;#125;
&amp;#125;

$process=new ProcessTest();
$process-&amp;gt;run();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行的效果&lt;br&gt;&lt;img src=&#34;/img/201909/2019-09-19_170643.jpg&#34; alt=&#34;多进行效果&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;pcntl_fork&lt;/p&gt;
&lt;p&gt;函数原型: int pcntl_fork ( void )&lt;/p&gt;
&lt;p&gt;执行该函数，会复制当前进程产生另一个进程，称之为当前进程的子进程，该函数在父进程和子进程的返回值不相同，在父进程中返回的是fork出的子进程的进程ID，而在子进程中返回值为0。&lt;/p&gt;
&lt;p&gt;要注意的是在复制进程时，会复制该进程的数据（堆数据、栈数据和静态数据），包括在父进程打开的文件描述符，在子进程中也是打开的，这意味着当你在父进程使用了大量内存时，fork出来的子进程必须拥有等量的内存资源，否则可能会导致fork失败。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;pcntl_waitpid&lt;/p&gt;
&lt;p&gt;函数原型: int pcntl_waitpid ( int $pid , int &amp;amp;$status [, int $options = 0 ] )&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pid: 进程ID&lt;/li&gt;
&lt;li&gt;status: 子进程的退出状态&lt;/li&gt;
&lt;li&gt;option: 取决于操作系统是否提供wait3函数，如果提供该函数，则该选项参数才生效.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面的进程还是有缺陷，处理多任务时并不太合适。&lt;br&gt;就用一个非常简单的leader-follower模型，创建一个进程池，随机选出一个进程作为leader进程，该进程监听是否有新连接，如果有则提升另一个follower为leader进程来继续监听，而原leader进程则去处理新连接的请求&lt;/p&gt;
&lt;p&gt;socket多任务示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php


class StreamSocketServer
&amp;#123;
    protected $address;
    protected $port;

    public function __construct($address=&amp;#39;127.0.0.1&amp;#39;,$port=8080)
    &amp;#123;
        $this-&amp;gt;address=$address;
        $this-&amp;gt;port=$port;
    &amp;#125;

    public function startSocket()&amp;#123;
        $socket=stream_socket_server(&amp;quot;tcp://&amp;quot;.$this-&amp;gt;address.&amp;quot;:&amp;quot;.$this-&amp;gt;port,$errno,$errstr);
        $data=&amp;quot;&amp;#123;&amp;#39;code&amp;#39;:100020,&amp;#39;msg&amp;#39;:&amp;#39;ok&amp;#39;,&amp;#39;data&amp;#39;:&amp;#123;&amp;#39;name&amp;#39;:&amp;#39;艾瑞可erik&amp;#39;,&amp;#39;url&amp;#39;:&amp;#39;https://erik.xyz&amp;#39;&amp;#125;&amp;#125;&amp;quot;;
        $pids=[];
        for($i=0;$i&amp;lt;10;$i++)&amp;#123;
            $pid=pcntl_fork();
            $pids[]=$pid;
            if($pid==0)&amp;#123;
                for ( ; ; ) &amp;#123;
                    $conn = stream_socket_accept($socket);

                    $write_buffer = &amp;quot;HTTP/1.0 200 OK\r\nServer: my_server\r\nContent-Type: text/html; charset=utf-8\r\n\r\n&amp;quot;.$data;

                    fwrite($conn, $write_buffer);

                    fclose($conn);
                &amp;#125;
                exit(&amp;quot;结束了\n&amp;quot;);
            &amp;#125;
        &amp;#125;

        foreach ($pids as $pid)&amp;#123;
            pcntl_waitpid($pid,$status);
        &amp;#125;
    &amp;#125;

    public function run()&amp;#123;
        $this-&amp;gt;startSocket();
    &amp;#125;
&amp;#125;

$socket=new StreamSocketServer();
$socket-&amp;gt;run();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/201909/2019-09-19_173231.jpg&#34; alt=&#34;多任务运行socket&#34;&gt;&lt;/p&gt;
&lt;p&gt;运行10个任务没问题，但是多进程是消耗cpu资源的，如果任务多，进程不断的增加，服务器是无法承受的。这时候多进程处理大的并发就不合适了。那就用IO复用。&lt;/p&gt;
&lt;h3 id=&#34;IO复用&#34;&gt;&lt;a href=&#34;#IO复用&#34; class=&#34;headerlink&#34; title=&#34;IO复用&#34;&gt;&lt;/a&gt;IO复用&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;阻塞／非阻塞&lt;/p&gt;
&lt;p&gt;这两个概念是针对 IO 过程中进程的状态来说的，阻塞 IO 是指调用结果返回之前，当前线程会被挂起；相反，非阻塞指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;同步／异步&lt;/p&gt;
&lt;p&gt;这两个概念是针对调用如果返回结果来说的，所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回；相反，当一个异步过程调用发出后，调用者不能立刻得到结果，实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;阻塞与非阻塞&lt;/p&gt;
&lt;p&gt;在介绍IO复用技术之前，先介绍一下阻塞和非阻塞，在我们前几节的WEB服务器中，调用socket_accept函数会使整个进程阻塞，直到有新连接，操作系统才唤醒进程继续执行。而非阻塞模式, stream_socket_accept的行为就不一样了，如果没有新连接，不会阻塞进程，而是马上返回false。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I/O多路复用&lt;/p&gt;
&lt;p&gt;多路复用（IO/Multiplexing）：为了提高数据信息在网络通信线路中传输的效率，在一条物理通信线路上建立多条逻辑通信信道，同时传输若干路信号的技术就叫做多路复用技术。对于 Socket 来说，应该说能同时处理多个连接的模型都应该被称为多路复用，目前比较常用的有 select/poll/epoll/kqueue 这些 IO 模型（目前也有像 Apache 这种每个连接用单独的进程/线程来处理的 IO 模型，但是效率相对比较差，也很容易出问题，所以暂时不做介绍了）。在这些多路复用的模式中，异步阻塞/非阻塞模式的扩展性和性能最好。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;select 轮询 &lt;/p&gt;
&lt;p&gt;使用select会轮询连接池，当有连接可读或可写时，select函数返回可读写的连接数，然后再轮询一遍连接池，查找活动连接进行读写操作&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;socket_select只支持socket类型的资源，而不支持stream类型的资源，所以这里需要使用socket_create创建socket资源&lt;/p&gt;
&lt;p&gt;select轮询示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php

class SocketServer
&amp;#123;
    protected $address;
    protected $port;

    public function __construct($address = &amp;#39;127.0.0.1&amp;#39;, $port = &amp;#39;8080&amp;#39;)
    &amp;#123;
        $this-&amp;gt;address = $address;
        $this-&amp;gt;port = $port;
    &amp;#125;

    public function startSocket()
    &amp;#123;
        $socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);
        socket_bind($socket, $this-&amp;gt;address, $this-&amp;gt;port);
        socket_listen($socket);
        $reads = [];
        $clients = [];
        $writes = null;
        $exceptions = null;
        socket_set_nonblock($socket);
        $write_buffer = &amp;quot;HTTP/1.0 200 OK\r\nServer: my_server\r\nContent-Type: text/html; charset=utf-8\r\n\r\n&amp;#123;&amp;#39;code&amp;#39;:100,&amp;#39;data&amp;#39;:&amp;#123;&amp;#39;name&amp;#39;:&amp;#39;艾瑞可erik&amp;#39;&amp;#125;,&amp;#39;msg&amp;#39;:&amp;#39;ok&amp;#39;&amp;#125;&amp;quot;;
        for (; ;) &amp;#123;
            $reads = array_merge(array($socket), $clients);
            $activity_counts = socket_select($reads, $writes, $exceptions, 0);
            if ($activity_counts &amp;gt; 0) &amp;#123;
                if (($conn = socket_accept($socket)) !== false) &amp;#123;
                    $clients[] = $conn;
                &amp;#125;
            &amp;#125;
            $this-&amp;gt;client($clients,$write_buffer);
        &amp;#125;
    &amp;#125;

    /**
     * @param $clients
     * @param $write_buffer
     */
    public function client($clients,$write_buffer)&amp;#123;
        $length = count($clients);
        for ($i = 0; $i &amp;lt; $length; $i++) &amp;#123;
            $client = $clients[$i];
            if (($read_buff = socket_read($client, 1024))!=false) &amp;#123;
                socket_write($client, $write_buffer);
                socket_close($client);
                break;
            &amp;#125;
        &amp;#125;
    &amp;#125;

    public function run()
    &amp;#123;
        $this-&amp;gt;startSocket();
    &amp;#125;
&amp;#125;

$sock = new SocketServer();
$sock-&amp;gt;run();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;select虽然可以监听多个连接，但是它最多只能监听1024个连接。这虽然在poll中得到了改进，但是select和poll本质上都是通过轮询的方式进行监听，这意味着当监听了上万连接时，就算只有一个连接是活动的，依然要把上万连接都遍历一次。显然，这无疑是极大的性能浪费，而epoll的出现彻底地解决了这个问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;epoll&lt;br&gt;epoll并不是只有一个函数来实现，而是多个函数。我们这里并不讨论epoll相关的函数，因为PHP并不提供相关的函数，但它提供了基于libevent库的libevent扩展，以及基于libevent库的event扩展。libevent库实现了Reactor模型，关于Reactor模型，这里只作简单的介绍&lt;/p&gt;
&lt;p&gt;Reactor模型，包含了几个组件：句柄，事件分发器，事件处理器。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;句柄，就是文件描述符，在Socket编程中，就是使用socket_create创建的socket资源.&lt;/li&gt;
&lt;li&gt;事件分发器, 通过事件循环，事件循环是通过诸如epoll&lt;code&gt;Select&lt;/code&gt;Poll等IO复用技术实现的，监听句柄期待的事件是否发生，发生了则将事件分发给事件处理器.&lt;/li&gt;
&lt;li&gt;事件处理器，当事件发生时，处理相关的逻辑.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;  libevent库已经实现了Reactor模型，安装event扩展即可。&lt;/p&gt;
&lt;p&gt;  示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php

$address = &amp;#39;127.0.0.1&amp;#39;;
$port = 8080;

//创建句柄
$data = &amp;quot;&amp;#123;&amp;#39;code&amp;#39;:100020,&amp;#39;msg&amp;#39;:&amp;#39;ok&amp;#39;,&amp;#39;data&amp;#39;:&amp;#123;&amp;#39;name&amp;#39;:&amp;#39;艾瑞可erik&amp;#39;,&amp;#39;url&amp;#39;:&amp;#39;https://erik.xyz&amp;#39;&amp;#125;&amp;#125;&amp;quot;;
$write_buffer = &amp;quot;HTTP/1.0 200 OK\r\nServer: my_server\r\nContent-Type: text/html; charset=utf-8\r\n\r\n&amp;quot; . $data;
$socket = @stream_socket_server(&amp;quot;tcp://&amp;quot; . $address . &amp;quot;:&amp;quot; . $port, $errno, $errstr);
stream_set_blocking($socket, 0);
//创建事件循环器
$event_base = new EventBase();
//创建事件，并指定事件监听的事件类型及注册事件处理器
$event = new Event($event_base, $socket, Event::READ | Event::PERSIST, function ($socket) use (&amp;amp;$event_base, $write_buffer) &amp;#123;
    $conn = stream_socket_accept($socket);
    fwrite($conn, $write_buffer);
    fclose($conn);
&amp;#125;, $socket);
//向循环器中添加事件
$event-&amp;gt;add();
$event_base-&amp;gt;loop();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在浏览器运行请求，或者用工具检测。&lt;/p&gt;
&lt;p&gt;运行结果&lt;br&gt;&lt;img src=&#34;/img/201909/2019-09-19_190045.jpg&#34; alt=&#34;epoll运行结果&#34;&gt;&lt;/p&gt;
&lt;p&gt;这时需要考虑一个问题：如果进程断了怎么办？&lt;/p&gt;
&lt;p&gt;那就需要进程守护。&lt;/p&gt;
&lt;p&gt;一般PPID为0的，都是内核态进程。一般PPID为1的都是守护进程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;守护进程创建的标准流程&lt;br&gt;让WEB服务器进程变为守护进程，成为守护进程有几个标准的步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置文件创建掩码，一般设置为0，umask(0)&lt;/li&gt;
&lt;li&gt;pcntl_fork一个子进程，并马上退出，这样做的目的是让子进程继承进程组ID并获取一个新的进程ID，这样就可以确保子进程一定不是进程组组长，因为进程组组长不能创建新会话&lt;/li&gt;
&lt;li&gt;posix_setsid创建新会话和新进程组，并成为会话组长和进程组组长，并和原来的控制终端脱离关系，这样该进程就不会被原来终端的控制信号中断&lt;/li&gt;
&lt;li&gt;pcntl_fork，再fork一次并不是必须的，只是在基于System-V的系统上，有人建议再fork一次，避免打开终端设备，使程序的通用性更强。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;守护进程示例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;?php
  header(&amp;#39;Content-type:text/html;charset:utf-8&amp;#39;);
  //守护进程
  function daemon()&amp;#123;
      umask(0);
      //创建进程，并退出进程
      if(pcntl_fork())&amp;#123;
          exit(&amp;quot;退出进程\n&amp;quot;);
      &amp;#125;

      //创建新的会话和进程组,并退出原来的控制端
      posix_setsid();

      //再次创建进程，并退出
      if(pcntl_fork())&amp;#123;
          exit(&amp;quot;再次创建进程，并退出\n&amp;quot;);
      &amp;#125;
  &amp;#125;
  daemon();

  $address = &amp;#39;127.0.0.1&amp;#39;;
  $port = 8080;

  //创建句柄
  $data = &amp;quot;&amp;#123;&amp;#39;code&amp;#39;:100020,&amp;#39;msg&amp;#39;:&amp;#39;ok&amp;#39;,&amp;#39;data&amp;#39;:&amp;#123;&amp;#39;name&amp;#39;:&amp;#39;艾瑞可erik&amp;#39;,&amp;#39;url&amp;#39;:&amp;#39;https://erik.xyz&amp;#39;&amp;#125;&amp;#125;&amp;quot;;
  $write_buffer = &amp;quot;HTTP/1.0 200 OK\r\nServer: my_server\r\nContent-Type: text/html; charset=utf-8\r\n\r\n&amp;quot; . $data;
  $socket = @stream_socket_server(&amp;quot;tcp://&amp;quot; . $address . &amp;quot;:&amp;quot; . $port, $errno, $errstr);
  stream_set_blocking($socket, 0);
  //创建事件循环器
  $event_base = new EventBase();
  //创建事件，并指定事件监听的事件类型及注册事件处理器
  $event = new Event($event_base, $socket, Event::READ | Event::PERSIST, function ($socket) use (&amp;amp;$event_base, $write_buffer) &amp;#123;
      $conn = stream_socket_accept($socket);
      fwrite($conn, $write_buffer);
      fclose($conn);
  &amp;#125;, $socket);
  //向循环器中添加事件
  $event-&amp;gt;add();
  $event_base-&amp;gt;loop();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  运行结果&lt;/p&gt;
&lt;p&gt;  &lt;img src=&#34;/img/201909/2019-09-19_213853.jpg&#34; alt=&#34;守护进程运行结果&#34;&gt;&lt;/p&gt;
&lt;p&gt;  那么守护进程有了，如何重启、关闭呢。那就调用函数发送信号&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;posix_kill&lt;br&gt;函数原型: bool posix_kill ( int $pid , int $sig )&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pid: 进程ID&lt;/li&gt;
&lt;li&gt;sig: 系统预定义的信号常量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;pcntl_signal&lt;br&gt;函数原型: bool pcntl_signal ( int $signo , callback $handler [, bool $restart_syscalls = true ] )&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;signo: 系统预定义的信号常量&lt;/li&gt;
&lt;li&gt;handler: 信号处理器，一个回调函数&lt;/li&gt;
&lt;li&gt;restart_syscalls: 当进程在进行系统调用时，被信号中断时，系统调用是否重新调用，一般默认为true&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;  那么根据以上几个步骤，我做个整合。完整版的socket进程及多进程控制&lt;/p&gt;
&lt;p&gt; EventServer&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;?php

class EventServer
&amp;#123;
    public $event_base;
    public $events = [];

    public function __construct()
    &amp;#123;
        $this-&amp;gt;event_base = new EventBase();
    &amp;#125;

    public function add($fd, $what, $callback, $callback_arg)
    &amp;#123;
        $event = new Event($this-&amp;gt;event_base, $fd, $what, $callback, $callback_arg);
        $this-&amp;gt;events[intval($fd)] = $event;
        $event-&amp;gt;add();
    &amp;#125;

    public function remove($fb)
    &amp;#123;
        $event = $this-&amp;gt;events[intval($fb)];
        $event-&amp;gt;free();
    &amp;#125;

    public function loop()
    &amp;#123;
        $this-&amp;gt;event_base-&amp;gt;loop();
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;StreamServer&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php

require &amp;quot;EventServer.php&amp;quot;;

class StreamServer
&amp;#123;
    protected $ip = &amp;#39;127.0.0.1&amp;#39;;
    protected $port = 8080;
    protected $path = &amp;#39;./pid.txt&amp;#39;;
    protected $event;
    protected $data = &amp;quot;&amp;#123;&amp;#39;code&amp;#39;:100020,&amp;#39;msg&amp;#39;:&amp;#39;ok&amp;#39;,&amp;#39;data&amp;#39;:&amp;#123;&amp;#39;name&amp;#39;:&amp;#39;艾瑞可erik&amp;#39;,&amp;#39;url&amp;#39;:&amp;#39;https://erik.xyz&amp;#39;&amp;#125;&amp;#125;&amp;quot;;
    protected $write_buffer = &amp;quot;HTTP/1.0 200 OK\r\nServer: my_server\r\nContent-Type: text/html; charset=utf-8\r\n\r\n&amp;quot;;


    public static function daemon()
    &amp;#123;
        umask(0);

        $pid = pcntl_fork();

        if ($pid) &amp;#123;
            exit(0);
        &amp;#125; elseif ($pid &amp;lt; 0) &amp;#123;
            die(&amp;quot;进程启动失败\n&amp;quot;);
        &amp;#125;

        $sid = posix_setsid();

        $pid = pcntl_fork();

        if ($pid) &amp;#123;
            exit(0);
        &amp;#125; elseif ($pid &amp;lt; 0) &amp;#123;
            die(&amp;quot;进程启动失败\n&amp;quot;);
        &amp;#125;

        if ($sid &amp;lt; 0) &amp;#123;
            die(&amp;quot;创建服务失败\n&amp;quot;);
        &amp;#125;
    &amp;#125;

    public function __construct($ip, $port = 80)
    &amp;#123;
        $this-&amp;gt;ip = $ip;
        $this-&amp;gt;port = $port;
        $this-&amp;gt;event = new EventServer();
    &amp;#125;

    /**
     * 启动
     */
    public function run()
    &amp;#123;
        if ($GLOBALS[&amp;#39;argc&amp;#39;] &amp;gt; 1) &amp;#123;
            $this-&amp;gt;sendSignal();
            exit(0);
        &amp;#125; else &amp;#123;
            self::daemon();
        &amp;#125;

        $this-&amp;gt;installSignalHandler();
        $this-&amp;gt;recordPid();
        $this-&amp;gt;start();
    &amp;#125;

    //存储信号
    public function sendSignal()
    &amp;#123;
        if (posix_kill($this-&amp;gt;getPid(), 0)) &amp;#123;
            if (strpos($GLOBALS[&amp;#39;argv&amp;#39;][1], &amp;quot;stop&amp;quot;) !== false) &amp;#123;
                posix_kill($this-&amp;gt;getPid(), SIGUSR1);
            &amp;#125;
        &amp;#125;
    &amp;#125;

    //启动进程
    public function start()
    &amp;#123;
        $domain = sprintf(&amp;quot;tcp://%s:%d&amp;quot;, $this-&amp;gt;ip, $this-&amp;gt;port);

        $fd = stream_socket_server($domain, $errno, $errstr);

        if (!$fd) &amp;#123;
            die(&amp;quot;$errno $errstr\n&amp;quot;);
        &amp;#125;

        stream_set_blocking($fd, 0);

        $this-&amp;gt;event-&amp;gt;add($fd, Event::READ | Event::PERSIST, [$this, &amp;#39;requestHandler&amp;#39;], $fd);

        $this-&amp;gt;event-&amp;gt;loop();
    &amp;#125;

    /**响应信息
     * @param $fd
     */
    public function requestHandler($fd)
    &amp;#123;
        $write_buffer = $this-&amp;gt;write_buffer . $this-&amp;gt;data;
        $conn = stream_socket_accept($fd);
        fwrite($conn, $write_buffer);
        fclose($conn);
    &amp;#125;

    //添加信号
    public function installSignalHandler()
    &amp;#123;
        $this-&amp;gt;event-&amp;gt;add(SIGUSR1, Event::SIGNAL, [$this, &amp;quot;handler&amp;quot;], SIGUSR1);
    &amp;#125;

    /**终止信号
     * @param $signo
     */
    public function handler($signo)
    &amp;#123;
        switch ($signo) &amp;#123;
            default:
            case SIGUSR1:
                $this-&amp;gt;event-&amp;gt;remove($signo);
                $this-&amp;gt;stop();
                break;
        &amp;#125;
    &amp;#125;

    public function stop()
    &amp;#123;
        exit(&amp;quot;终止信号\n&amp;quot;);
    &amp;#125;

    public function getPid()
    &amp;#123;
        return file_get_contents($this-&amp;gt;path);
    &amp;#125;

    private function recordPid()
    &amp;#123;
        file_put_contents($this-&amp;gt;path, posix_getpid());
    &amp;#125;
&amp;#125;

$server = new StreamServer(&amp;quot;127.0.0.1&amp;quot;, 8080);
$server-&amp;gt;run();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/201909/2019-09-19_232908.jpg&#34; alt=&#34;最终执行结果&#34;&gt;&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>