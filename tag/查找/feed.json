{
    "version": "https://jsonfeed.org/version/1",
    "title": "艾瑞可erik • All posts by \"查找\" tag • All posts by \"undefined\" categories",
    "description": "一只PHP开发的程序猿，偶尔做做运维、Goland、Python、Java、摄影、画画、写作、顺便睡觉，反正整站都搞过。",
    "home_page_url": "https://erik.xyz",
    "items": [
        {
            "id": "https://erik.xyz/2020/02/11/data-lookup-algorithm/",
            "url": "https://erik.xyz/2020/02/11/data-lookup-algorithm/",
            "title": "查找与排序",
            "date_published": "2020-02-11T04:18:00.000Z",
            "content_html": "<h3 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h3><p>1.顺序查找</p>\n<ul>\n<li>思路：从线性表的第一个元素开始，逐个将线性表中的元素与被查元素进行比较，如果相等，则查找成功，停止查找；若整个线性表扫描完毕，仍未找到与被查元素相等的元素，则表示线性表中没有要查找的元素，查找失败。</li>\n<li>最好情况下，第一个元素就是要查找的元素，则比较次数为1次</li>\n<li>最坏情况下，最后一个元素才是要找的元素，或者在线性表中，没有要查找的元素，则需要与线性表中所有的元素比较，比较次数为n次</li>\n<li>平均情况下，大约需要比较n/2次<span id=\"more\"></span></li>\n<li>唯一选择：<ul>\n<li>线性表为无序表，则不管是顺序存储结构，还是链式存储结构，都只能用顺序查找</li>\n<li>即使线性表是有序的，如果采用链式存储结构，也只能用顺序查找<br>2.二分查找</li>\n</ul>\n</li>\n<li>满足条件<ul>\n<li>用顺序存储结构</li>\n<li>线性表是有序的，有序是指元素按非递减排列，即从小到大排列，且允许相邻元素相等</li>\n</ul>\n</li>\n<li>对于长度为n的有序线性表，利用二分查找元素X的过程<ul>\n<li>如果X的值与中间项的值相等，则查找成功，结束查找</li>\n<li>如果X小于中间项的值，则在线性表的前半部分以二分法继续查找</li>\n<li>如果X大于中间项的值，则在线性表的后半部分以二分法继续查找</li>\n</ul>\n</li>\n<li>顺序查找法每一次比较，只将查找范围减少1，而二分法查找，每比较一次，可将查找范围减少为原来的一半，效率大大提高。对于长度为n的有序线性表，在最坏情况下，二分法查找只需比较$log_{2}n$次</li>\n</ul>\n<h3 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h3><p>1.交换类排序</p>\n<ul>\n<li>冒泡排序<ul>\n<li>冒泡排序就是通过两两相邻数据元素之间的比较和交换，不断地消去逆序，直到所有数据元素有序为止</li>\n<li>最坏情况下，长度为n的线性表排序，冒泡排序需要比较的次数为n(n-1)/2</li>\n</ul>\n</li>\n<li>快速排序<ul>\n<li>快速排序就是在待排序的n个元素中取一个元素K,以元素K作为分割标准，把所有小于K元素的数据元素都移到K前面，把所有大于K元素的数据元素都移到K后面。这样，以K为分界线，把线性表分割为两个子表，这称为一趟排序。然后，对K前后的两个子表分别重复上述过程。继续下去，直到分割的子表的长度为1为止。</li>\n<li>快速排序最坏的情况需要进行n(n-1)/2次比较，实际效率比冒泡排序高</li>\n</ul>\n</li>\n</ul>\n<p>2.插入类排序</p>\n<ul>\n<li>插入排序是每次将一个待排序元素，按其元素值的大小插入到前面已经排好序的子表中的适当位置，直到全部元素插入完成为止</li>\n<li>简单插入排序<ul>\n<li>把n个待排序的元素看成是一个有序表和一个无序表，开始时，有序表只包含一个元素，而无序表包含另外n-1个元素，每次取无序表中的第一个元素插入到有序表中的正确位置，使之成为增加一个元素的新的有序表。插入元素时，插入位置及其后的记录依次向后移动。最后有序表的长度为n，而无序表为空，此时排序完成</li>\n<li>最坏情况，简单插入排序需要n(n-1)/2次比较</li>\n</ul>\n</li>\n<li>希尔排序<ul>\n<li>先取一个整数$d<em>{1} &lt; n$，把全部数据元素分成$d</em>{1}$个组，所有距离为$d<em>{1}$倍数的元素放在一组中，组成了一个子序列，对每个子序列分别进行简单插入排序。然后取$d</em>{2} &lt; d<em>{1}$重复上述分组和排序工作，直到$d</em>{i} = 1$，即所有记录在一组中为止</li>\n<li>希尔排序的效率与所选取的增量序列有关，最坏情况下，希尔排序需要比较的次数是$n ^{r}(1&lt;r&lt;2)$</li>\n</ul>\n</li>\n</ul>\n<p>3.选择类排序</p>\n<ul>\n<li>通过每一趟从待排序序列中选出值最小的元素，顺序放在已安排好序的有序子表的后面，直到全部序列满足排序要求为止</li>\n<li>简单选择排序<ul>\n<li>先从所有n个待排序的数据元素中选择最小的元素，将该元素与第1个元素交换，再从剩下的n-1个元素中选出最小的元素与第2个元素交换。重复这样的操作直到所有的元素有序为止</li>\n<li>简单选择排序法在最坏的情况下需要比较n(n-1)/2次</li>\n</ul>\n</li>\n<li>堆排序<ul>\n<li>若有n个元素的序列$(h<em>{1},h</em>{2},\\cdots h<em>{n})$，将元素按顺序组成一棵完全二叉树，当且仅当满足下列条件时称为堆。$ \\begin{cases} h</em>{i} \\geq h<em>{2i} \\newline h</em>{i} \\geq h<em>{2i+1} \\end{cases}$ 或者$ \\begin{cases} h</em>{i} \\leq h<em>{2i} \\newline h</em>{i} \\leq h_{2i+1} \\end{cases}$ 其中，$ i=1,2,3,\\cdots,n/2 $</li>\n<li>第一种情况称为大根堆，所有节点的值大于或等于左右子节点的值。第二种情况称为小根堆，所有节点的值小于或等于左右子节点的值</li>\n<li>堆排序最坏情况需要$ nlog_{2}n$次比较</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "查找",
                "排序",
                "快速排序",
                "冒泡排序",
                "二分查找"
            ]
        }
    ]
}