{
    "version": "https://jsonfeed.org/version/1",
    "title": "艾瑞可erik • All posts by \"php函数\" tag • All posts by \"undefined\" categories",
    "description": "一只PHP开发的程序猿，偶尔做做运维、Goland、Python、Java、摄影、画画、写作、顺便睡觉，反正整站都搞过。",
    "home_page_url": "https://erik.xyz",
    "items": [
        {
            "id": "https://erik.xyz/2019/10/15/php-math-han-shu/",
            "url": "https://erik.xyz/2019/10/15/php-math-han-shu/",
            "title": "php数学函数",
            "date_published": "2019-10-15T15:13:00.000Z",
            "content_html": "<ul>\n<li><p>bccomp — 比较两个任意精度的数字</p>\n<ul>\n<li>bccomp ( string $left_operand , string $right_operand [, int $scale = int ] ) : int</li>\n<li>参数解释<ul>\n<li>left_operand左边的运算数, 是一个字符串.</li>\n<li>right_operand右边的运算数, 是一个字符串.</li>\n<li>scale可选的scale参数被用作设置指示数字， 在使用来作比较的小数点部分.</li>\n</ul>\n</li>\n<li><p>如果两个数相等返回0, 左边的数left_operand比较右边的数right_operand大返回1, 否则返回-1.</p>\n</li>\n<li><p>已验证：如果参数是字符串，不论这个字符串是什么，这个字符串始终是0。参数可以为数字作比较。</p>\n<span id=\"more\"></span>\n</li>\n</ul>\n</li>\n<li><p>bcdiv2个任意精度的数字除法计算</p>\n<ul>\n<li>bcdiv ( string $left_operand , string $right_operand [, int $scale = int ] ) : string</li>\n<li>左操作数除以右操作数</li>\n<li><p>返回结果为字符串类型的结果，如果右操作数是0结果为null</p>\n</li>\n<li><p>已验证：除法结果始终取整，除非指定第三参数.，否则，只保留整数</p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>bcmod — 对一个任意精度数字取模</p>\n<ul>\n<li>bcmod ( string $left_operand , string $modulus ) : string</li>\n<li>对左操作数使用系数取模</li>\n<li>返回字符串类型取模后结果，如果系数为0则返回null</li>\n<li><p>取模运算实际就是=被除数-除数x(被除数/除数的整数值),例如 100%17 则 100=17<em>5+15 那么100%17=15。这里15就是100-17</em>5。也就是100%17取模的结果</p>\n<p>已验证：取模的结果始终是一个不包含小数点的数字</p>\n</li>\n</ul>\n</li>\n<li><p>bcmul — 2个任意精度数字乘法计算</p>\n<ul>\n<li>bcmul ( string $left_operand , string $right_operand [, int $scale = int ] ) : string</li>\n<li>左操作数乘以右操作数</li>\n<li><p>返回结果为字符串类型.</p>\n</li>\n<li><p>已验证：</p>\n<ul>\n<li>如果两个参数的第一位小数点之和大于等于2小于5，则结果值加1。</li>\n<li>如果两个参数的第一位小数点之和大于等于5小于8，则结果值加2。</li>\n<li>如果两个参数的第一位小数点之和大于等于8小于等于10，则结果值加3。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>bcpow — 任意精度数字的乘方</p>\n<ul>\n<li>bcpow ( string $left_operand , string $right_operand [, int $scale ] ) : string</li>\n<li>左操作数的右操作数次方运算.</li>\n<li>已验证：默认操作不保留小数点，第三参数指定保留小数点位数，才有小数点。</li>\n</ul>\n</li>\n<li><p>base_convert — 在任意进制之间转换数字</p>\n<ul>\n<li>base_convert ( string $number , int $frombase , int $tobase ) : string<ul>\n<li>number 要转换的数字</li>\n<li>frombase 当前进制</li>\n<li>tobase 要转换的进制</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>bindec — 二进制转换为十进制</p>\n<ul>\n<li>decbin ( int $number ) : string</li>\n</ul>\n</li>\n<li><p>decbin — 十进制转换为二进制</p>\n<ul>\n<li>decbin ( int $number ) : string</li>\n</ul>\n</li>\n<li><p>dechex — 十进制转换为十六进制</p>\n<ul>\n<li>dechex ( int $number ) : string</li>\n</ul>\n</li>\n<li><p>decoct — 十进制转换为八进制</p>\n<ul>\n<li>decoct ( int $number ) : string</li>\n</ul>\n</li>\n<li><p>floor — 舍去法取整</p>\n<ul>\n<li>注意：如果是负数取整的话负数存在小数点且小数点第一位大于等于1的话，结果值加1</li>\n</ul>\n</li>\n<li><p>fmod — 返回除法的浮点数余数</p>\n<ul>\n<li>fmod ( float $x , float $y ) : float</li>\n<li>除法计算返回值的余数，参数可为整数，返回结果始终是浮点</li>\n</ul>\n</li>\n<li><p>hexdec — 十六进制转换为十进制</p>\n<ul>\n<li>hexdec ( string $hex_string ) : number</li>\n</ul>\n</li>\n<li><p>intdiv — 对除法结果取整</p>\n<ul>\n<li>intdiv ( int $dividend , int $divisor ) : int</li>\n<li>dividend 除以 divisor 的商，对该商取整。</li>\n<li>如果 divisor 是 0，将抛出 DivisionByZeroError 异常。 如果 dividend 是 PHP_INT_MIN 并且 divisor 是 -1，将抛出 ArithmeticError 异常.</li>\n</ul>\n</li>\n<li><p>is_finite — 判断是否为有限值</p>\n<ul>\n<li>is_finite ( float $val ) : bool</li>\n<li>如果 val 是本机平台上 PHP 浮点数所允许范围中的一个合法的有限值，则返回 TRUE。</li>\n</ul>\n</li>\n<li><p>is_infinite — 判断是否为无限值</p>\n<ul>\n<li>如果 val 为无穷大返回 TRUE，否则返回 FALSE。、</li>\n</ul>\n</li>\n<li><p>is_nan — 判断是否为合法数值</p>\n<ul>\n<li>is_nan ( float $val ) : bool</li>\n<li>如果 val 不是一个数字（not a number）返回 TRUE，否则返回 FALSE。</li>\n<li>注：此处我懵逼了，这个函数竟然是—不是数字返回true。是数字返回false</li>\n</ul>\n</li>\n<li><p>lcg_value — 组合线性同余发生器</p>\n<ul>\n<li>lcg_value ( void ) : float</li>\n<li>范围为 (0, 1) 的伪随机数。</li>\n</ul>\n</li>\n<li><p>round — 对浮点数进行四舍五入</p>\n<ul>\n<li>返回将 val 根据指定精度 precision（十进制小数点后数字的数目）进行四舍五入的结果。precision 也可以是负数或零（默认值）。</li>\n<li>round ( float $val [, int $precision = 0 [, int $mode = PHP_ROUND_HALF_UP ]] ) : float<ul>\n<li>val要处理的值</li>\n<li>precision可选的十进制小数点后数字的数目。</li>\n<li>mode以下之一： PHP_ROUND_HALF_UP、 PHP_ROUND_HALF_DOWN PHP_ROUND_HALF_EVEN 或 PHP_ROUND_HALF_ODD</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>ctype_alnum — 做字母和数字字符检测</p>\n<ul>\n<li>如果text中所有的字符全部是字母和(或者)数字，返回 TRUE 否则返回FALSE</li>\n</ul>\n</li>\n<li><p>ctype_alpha — 做纯字符检测</p>\n<ul>\n<li>如果在当前语言环境中 text 里的每个字符都是一个字母，那么就返回TRUE，反之则返回FALSE。</li>\n</ul>\n</li>\n<li><p>ctype_cntrl — 做控制字符检测</p>\n<ul>\n<li>控制字符就是例如：换行、缩进、空格。</li>\n<li>如果在当前的语言环境下 text 里面的每个字符都是控制字符，就返回 TRUE ；反之就返回 FALSE 。</li>\n</ul>\n</li>\n<li><p>ctype_digit — 做纯数字检测</p>\n<ul>\n<li>如果 text 字符串是一个十进制数字，就返回 TRUE ；反之就返回 FALSE </li>\n</ul>\n</li>\n<li><p>ctype_graph — 做可打印字符串检测，空格除外</p>\n<ul>\n<li>如果 text 里面的每个字符都是输出可见的（没有空白），就返回 TRUE ；反之就返回 FALSE 。</li>\n</ul>\n</li>\n<li><p>ctype_lower — 做小写字符检测</p>\n<ul>\n<li>如果在当前的语言环境下 text 里面的每个字符都是小写字母，就返回 TRUE ；反之就返回 FALSE 。</li>\n</ul>\n</li>\n<li><p>ctype_print — 做可打印字符检测</p>\n<ul>\n<li>如果在当前的语言环境下 text 里面的每个字符都能被实际输出（包括空白），就返回 TRUE ；如果 text 里面包含控制字符或者那些根本不会有任何输出的字符串，就返回 FALSE 。</li>\n</ul>\n</li>\n<li><p>ctype_punct — 检测可打印的字符是不是不包含空白、数字和字母</p>\n<ul>\n<li>如果在 text 里面的每个字符都是能打印的，但不是字母、数字，也不是空白，那么就返回 TRUE ；反之则返回 FALSE 。</li>\n</ul>\n</li>\n<li><p>ctype_upper — 做大写字母检测</p>\n<ul>\n<li>在当前语言环境下，如果 text 里面的每个字符都是大写字母，就返回 TRUE。</li>\n</ul>\n</li>\n<li><p>ctype_xdigit — 检测字符串是否只包含十六进制字符</p>\n<ul>\n<li>如果 text 里面的每个字符都是十六进制字符。也就是只能包含十进制的树枝和 [A-Fa-f] 的字母。否则，返回 FALSE </li>\n</ul>\n</li>\n<li><p>filter_has_var — 检测是否存在指定类型的变量</p>\n<ul>\n<li>typeINPUT_GET、 INPUT_POST、 INPUT_COOKIE、 INPUT_SERVER、 INPUT_ENV 里的其中一个。</li>\n<li>variable_name要检查的变量名。</li>\n<li>成功时返回 TRUE， 或者在失败时返回 FALSE。</li>\n</ul>\n</li>\n<li><p>register_shutdown_function — 注册一个会在php中止时执行的函数</p>\n<ul>\n<li>callback待注册的中止回调</li>\n<li>中止回调是作为请求的一部分被执行的，因此可以在它们中进行输出或者读取输出缓冲区。</li>\n<li>parameter  可以通过传入额外的参数来将参数传给中止函数</li>\n<li>可以多次调用 register_shutdown_function() ，这些被注册的回调会按照他们注册时的顺序被依次调用。 如果你在注册的方法内部调用 exit()， 那么所有处理会被中止，并且其他注册的中止回调也不会再被调用。</li>\n<li>如果传入的callback不是可调用的，那么将会产生一个 E_WARNING 级别的错误。</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "php函数",
                "php数学函数"
            ]
        },
        {
            "id": "https://erik.xyz/2016/03/07/php-shu-zu-han-shu-zi-fu-chuan-de-chang-shi/",
            "url": "https://erik.xyz/2016/03/07/php-shu-zu-han-shu-zi-fu-chuan-de-chang-shi/",
            "title": "PHP数组、函数、字符串的常识",
            "date_published": "2016-03-07T14:34:00.000Z",
            "content_html": "<p>php数组排序 </p>\n<p>sort()根据数组所包含元素进行升序排列 sort()函数是区分大小写。</p>\n<p>所有大写字母都在小写字母后面。 </p>\n<p>asort()函数和ksort()函数对关联数组排序 </p>\n<p>例如：$a=array(‘name’=&gt;100,’user’=&gt;200,’title’=&gt;300); </p>\n<p>函数asort()是根据数组$a的每个元素值进行排序。在数组$a中元素值为数字。 <span id=\"more\"></span></p>\n<p>函数ksort()是按数组的关键字按字母顺序排列。 </p>\n<p>数组反向排序 </p>\n<p>函数rsort()将一个一维数字索引数组按降序排列</p>\n<p>函数arsort()将一个一维关联数组按每个元素值的降序排序。 </p>\n<p>函数krsort()将根据数组元素的关键字将一维数组按照降序排列。</p>\n<p>对数组进行重新排序 函数shuffle()将数组各元素进行随机排序。 </p>\n<p>函数array_reverse()给出一个原来数组的反向排序。</p>\n<p>数组中浏览排序 函数prev()将一维数组降序排列。 </p>\n<p>函数each()在指针前移一个位置之前返回当前元素（即，返回当前元素的同时，输出一个数组）。 </p>\n<p>函数next()是将指针前移，然后再返回新的当前元素（即，返回当前元素）。</p>\n<p>函数array_walk()以相同的方式使用或者修改数组中的每一个元素。</p>\n<p>统计元素个数 函数array_count_values()统计每个特定的值在数组中出现过的次数。会返回一个包含频率的关联数组。 函数count()和sizeof()用法相同。 </p>\n<p>函数extract()可以把一个非数字索引数组，且该数组又有许多关键字值对，便可以转换成一系列的标量变量。 </p>\n<p>输出函数 echo和print都是将字符串输出到浏览器，但print()有返回值true或false printf()函数是将一个格式化的字符串输出到浏览器 </p>\n<p>sprintf()函数是返回一个格式化的字符串。</p>\n<p>分割函数 explode()函数根据一个指定的分隔符字符串将字符串本身分割为小块，将分割后的小块返回到一个数组中。 </p>\n<p>implode()函数（别名join）返回由数组元素组合成的字符串。 </p>\n<p>strtok()函数是一次只从字符串中取出一些片段。 </p>\n<p>substr()函数是获取一个字符串给定起点和终点的间字符串。 </p>\n<p>改变字符串中字母大小写 strtoupper()函数将字符串转换为大写。 </p>\n<p>strtolower()函数将字符串转换成小写。</p>\n<p>ucfirst()函数把字符串第一个字符是字母，就将该字符串第一个字母转换成大写。</p>\n<p>ucwords()函数将字符串每个单词的第一个字母转换成大写。 </p>\n<p>字符串比较 strcmp(str1, str2)函数，如果两个字符串相等就返回0，如果按字典顺序str1在str2后面（大于str2）就返回一个正数， 如果str1小于str2就返回一个负数。 </p>\n<p>strcasecmp()函数除了不区分大小写，其他和strcmp()一样。</p>\n<p>strnatcmp()函数除了不区分大小写，其他和strcmp()一样，当时strnatcmp()函数将按自然排序比较字符串。</p>\n<p>strlen()函数检查字符串的长度。 </p>\n<p>在字符串中查找字符串 strstr()函数是在一个较长的字符串中查找匹配的字符串或字符。 strchr()函数和strstr()函数一样。 stristr()函数和strstr()函数一样，只是不区分字符大小写。 </p>\n<p>strrchr()函数和strstr()函数一样，但会从最后出现目标关键字的位置的前面返回被搜索字符串。 查找字符串的位置 </p>\n<p>strpos()函数返回目标关键字子字符串在被搜索字符串中的位置。strpos()函数比strstr()函数运行速度快。 strrpos()函数返回的是被搜索字符串中最后一次出现目标关键字子字符串的位置。 </p>\n<p>如果不存在返回false 替换字符串 mixed str_replace(mixed needle, mixed new_needle, mixed haystack[, int &amp; count]);把字符串的一部分替换为另一个字符串 neddle需要处理的字符串，new_needle需要插入的字符串，haystack字符串开始位置，起始位置为0，count执行的替换操作次数。 </p>\n<p>substr_replace()函数用来在给定位置中查找和替换字符串中特定的子字符串。</p>\n",
            "tags": [
                "php函数",
                "PHP数组",
                "字符串函数",
                "排序函数"
            ]
        },
        {
            "id": "https://erik.xyz/2014/12/19/shang-chuan-jin-du-zhi-chi-upload-progress-in-sessions/",
            "url": "https://erik.xyz/2014/12/19/shang-chuan-jin-du-zhi-chi-upload-progress-in-sessions/",
            "title": "上传进度支持(Upload progress in sessions)",
            "date_published": "2014-12-19T13:08:00.000Z",
            "content_html": "<ul>\n<li>作者: <a href=\"http://www.laruence.com\">Laruence</a></li>\n</ul>\n<p>文件上传进度反馈, 这个需求在当前是越来越普遍, 比如大附件邮件. 在PHP5.4以前, 我们可以通过<a href=\"http://www.php.net/manual/zh/apc.configuration.php#ini.apc.rfc1867\">APC</a>提供的功能来实现. 或者使用PECL扩展<a href=\"http://pecl.php.net/package/uploadprogress\">uploadprogress</a>来实现. 虽然说, 它们能很好的解决现在的问题, 但是也有很明显的不足:</p>\n<ul>\n<li>1. 他们都需要额外安装(我们并没有打算把APC加入PHP5.4)</li>\n<li><p>2. 它们都使用本地机制来存储这些信息, APC使用共享内存, 而uploadprogress使用文件系统(不考虑NFS), 这在多台前端机的时候会造成麻烦.</p>\n<span id=\"more\"></span>\n<p>从PHP的角度来说, 最好的储存这些信息的地方应该是SESSION, 首先它是PHP原生支持的机制. 其次, 它可以被配置到存放到任何地方(支持多机共享). 正因为此, Arnaud Le Blanc提出了针对Session报告上传进度的<a href=\"http://wiki.php.net/rfc/session_upload_progress\">RFC</a>, 并且现在实现也已经包含在了PHP5.4的主干中. 这个新特性, 提供了一些新的INI配置, 他们和APC的相关配置很类似:</p>\n</li>\n<li><p>session.upload_progress.enabled[=1] : 是否启用上传进度报告(默认开启)</p>\n</li>\n<li>session.upload_progress.cleanup[=1] : 是否在上传完成后及时删除进度数据(默认开启, 推荐开启).</li>\n<li>session.upload_progress.prefix[=upload_progress_] : 进度数据将存储在_SESSION[session.upload_progress.prefix . _POST[session.upload_progress.name]]</li>\n<li>session.upload_progress.name[=PHP_SESSION_UPLOAD_PROGRESS] : 如果_POST[session.upload_progress.name]没有被设置, 则不会报告进度.</li>\n<li>session.upload_progress.freq[=1%] : 更新进度的频率(已经处理的字节数), 也支持百分比表示’%’.</li>\n<li>session.upload_progress.min_freq[=1.0] : 更新进度的时间间隔(秒级)</li>\n</ul>\n<p>对于如下的上传表单:</p>\n<pre><code>&lt;form action=&quot;upload.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;\n &lt;input type=&quot;hidden&quot;\n     name=&quot;&lt;?php echo ini_get(&quot;session.upload_progress.name&quot;); ?&gt;&quot; value=&quot;laruence&quot; /&gt;\n &lt;input type=&quot;file&quot; name=&quot;file1&quot; /&gt;\n &lt;input type=&quot;file&quot; name=&quot;file2&quot; /&gt;\n &lt;input type=&quot;submit&quot; /&gt;\n&lt;/form&gt;\n</code></pre><p>如果我们上传一个足够大的文件(网速要是足够慢就更好:P), 我们就可以从_SESSION中, 得到类似下面的进度信息:</p>\n<pre><code> $_SESSION\\[&quot;upload\\_progress\\_laruence&quot;\\] = array(\n  &quot;start_time&quot; =&gt; 1234567890, // 请求时间\n  &quot;content_length&quot; =&gt; 57343257, // 上传文件总大小\n  &quot;bytes_processed&quot; =&gt; 453489, // 已经处理的大小\n  &quot;done&quot; =&gt; false, // 当所有上传处理完成后为TRUE\n  &quot;files&quot; =&gt; array(\n   0 =&gt; array(\n    &quot;field_name&quot; =&gt; &quot;file1&quot;, // 表单中上传框的名字\n    // The following 3 elements equals those in $_FILES\n     &quot;name&quot; =&gt; &quot;foo.avi&quot;,\n     &quot;tmp_name&quot; =&gt; &quot;/tmp/phpxxxxxx&quot;,\n     &quot;error&quot; =&gt; 0,\n     &quot;done&quot; =&gt; true, // 当这个文件处理完成后会变成TRUE\n     &quot;start_time&quot; =&gt; 1234567890, // 这个文件开始处理时间\n     &quot;bytes_processed&quot; =&gt; 57343250, // 这个文件已经处理的大小\n    ),\n    // An other file, not finished uploading, in the same request\n    1 =&gt; array(\n     &quot;field_name&quot; =&gt; &quot;file2&quot;,\n     &quot;name&quot; =&gt; &quot;bar.avi&quot;,\n     &quot;tmp_name&quot; =&gt; NULL,\n     &quot;error&quot; =&gt; 0,\n     &quot;done&quot; =&gt; false,\n     &quot;start_time&quot; =&gt; 1234567899,\n     &quot;bytes_processed&quot; =&gt; 54554,\n    ),\n   )\n  );\n</code></pre><p>这个是不是很方便呢? 但是还是要提醒一下, PHP 5.4还处于开发阶段, 在最终release之前, 任何新特性都可能被调整或者更改. 如果大家有任何建议, 也欢迎反馈, 帮助我们使得PHP变得更好. 谢谢</p>\n",
            "tags": [
                "php",
                "php服务器",
                "php函数"
            ]
        },
        {
            "id": "https://erik.xyz/2014/12/18/zai-yi-ci-bu-yao-shi-yong-include-require-once/",
            "url": "https://erik.xyz/2014/12/18/zai-yi-ci-bu-yao-shi-yong-include-require-once/",
            "title": "再一次, 不要使用(include/require)_once",
            "date_published": "2014-12-18T13:50:00.000Z",
            "content_html": "<ul>\n<li>作者: <a href=\"http://www.laruence.com\">Laruence</a></li>\n</ul>\n<p>最近关于apc.include_once_override的去留, 我们做了几次讨论, 这个APC的配置项一直一来就没有被很好的实现过. 在这里, 我想和大家在此分享下, 这个问题的原因, 以及对我们的一些启示. 关于使用include还是include_once(以下,都包含require_once), 这个讨论很长了, 结论也一直有, 就是尽量使用include, 而不是include_once, 以前最多的理由的是, include_once需要查询一遍已加载的文件列表, 确认是否存在, 然后再加载. 诚然, 这个理由是对的, 不过, 我今天要说的, 是另外一个的原因. 我们知道, PHP去判断一个文件是否被加载, 是需要得到这个文件的opened_path的, 意思是说, 比如:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\">set\\_include\\_path(&quot;/tmp/:/tmp2/&quot;);</span><br><span class=\"line\">include_once(&quot;2.php&quot;);</span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure><br><span id=\"more\"></span><br>当PHP看到include_once “2.php”的时候, 他并不知道这个文件的实际路径是什么, 也就无法从已加载的文件列表去判断是否已经加载, 所以在include_once的实现中, 会首先尝试解析这个文件的真实路径(对于普通文件这个解析仅仅类似是检查getcwd和文件路径, 所以如果是相对路径, 一般是不会成功), 如果解析成功, 则查找EG(include_files), 如果存在则说明包含过了, 返回, 否则open这个文件, 从而得到这个文件的opened_path. 比如上面的例子, 这个文件存在于 “/tmp2/2.php”. 然后, 得到了这个opened_path以后, PHP去已加载的文件列表去查找, 是否已经包含, 如果没有包含, 那么就直接compile, 不再需要open file了.</p>\n<ol>\n<li>尝试解析文件的绝对路径, 如果能解析成功, 则检查EG(included_files), 存在则返回, 不存在继续</li>\n<li>打开文件, 得到文件的打开路径(opened path)</li>\n<li>拿opened path去EG(included_files)查找, 是否存在, 如果存在则返回, 不存在继续</li>\n<li>编译文件(compile_file)</li>\n</ol>\n<p>这个在大多数情况下, 不是问题, 然而问题出在当你使用APC的时候… 在使用APC的时候, APC劫持了compile_file这个编译文件的指针, 从而直接从cache中得到编译结果, 避免了对实际文件的open, 避免了对open的system call. 然而, 当你在代码中使用include_once的时候, 在compile_file之前, PHP已经尝试去open file了, 然后才进入被APC劫持的compile file中, 这样一来, 就会产生一次额外的open操作. 而APC正是为了解决这个问题, 引入了include_once_override, 在include_once_override开启的情况下, APC会劫持PHP的ZEND_INCLUDE_OR_EVAL opcode handler, 通过stat来确定文件的绝对路径, 然后如果发现没有被加载, 就改写opcode为include, 做一个tricky解决方案. 但是, 很可惜, 如我所说, APC的include_once_override实现的一直不好, 会有一些未定义的问题, 比如:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\">set\\_include\\_path(&quot;/tmp&quot;);</span><br><span class=\"line\">function a($arg = array()) &#123;</span><br><span class=\"line\">    include_once(&quot;b.php&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">a();</span><br><span class=\"line\">a();</span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure><br>然后, 我们的b.php放置在”/tmp/b.php”, 内容如下:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\">  class B &#123;&#125;</span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure><br>那么在打开apc.include_once_override的情况下, 连续访问就会得到如下错误:</p>\n<p>  Fatal error - include() : Cannot redeclare class b</p>\n<p>(后记 2012-09-15 02:07:20: 这个APC的bug我已经修复: <a href=\"https://bugs.php.net/bug.php?id=63070\">#63070</a>) 排除这些技术因素, 我也一直认为, 我们应该使用include, 而不是include_once, 因为我们完全能做到自己规划, 一个文件只被加载一次. 还可以借助自动加载, 来做到这一点. 你使用include_once, 只能证明, 你对自己的代码没信心. 所以, 建议大家, 不要再使用include_once</p>\n",
            "tags": [
                "php",
                "php服务器",
                "php函数"
            ]
        },
        {
            "id": "https://erik.xyz/2014/11/14/php-mian-xiang-dui-xiang/",
            "url": "https://erik.xyz/2014/11/14/php-mian-xiang-dui-xiang/",
            "title": "php面向对象",
            "date_published": "2014-11-14T07:18:00.000Z",
            "content_html": "<p>__construct()构造函数，主要是通过关键字new生成实例的时候，它就会被调用执行。（构造函数不能返回值） __destructor()析构函数，它是在对象被销毁的时候被调用执行的。（对象被销毁时清空资源或者记录日志信息） __get(),__set()访问函数，类属性被访问和操作，访问函数都会被激发。oop思想不鼓励直接从类的外部访问类的属性，所以使用它们可以避免直接对类属性的访问。<span id=\"more\"></span> extends确认子类继承父类  格式class 子类 extends 父类{} final放在特定类前面，表示此类不能再被继承。如果放在某个类方法前面，表示此方法不能在继承后被“覆写”或重新定义。 implements指定使用接口 <a href=\"http://tietuku.com/cc26841c6b434585\" title=\"php接口示意图\"><img src=\"http://i2.tietuku.com/cc26841c6b434585.jpg\" alt=\"php接口示意图\"></a> interface可声明接口，并且单独设立接口方法 <a href=\"http://tietuku.com/9ce70457b5ef2e3b\" title=\"接口示意图\"><img src=\"http://i2.tietuku.com/9ce70457b5ef2e3b.jpg\" alt=\"接口示意图\"></a> 错误处理 <a href=\"http://tietuku.com/cce268d063bbd079\" title=\"错误处理\"><img src=\"http://i2.tietuku.com/cce268d063bbd079.jpg\" alt=\"错误处理\"></a></p>\n",
            "tags": [
                "php",
                "php函数",
                "php面向对象",
                "面向对象"
            ]
        },
        {
            "id": "https://erik.xyz/2014/11/13/php-shi-jian-han-shu/",
            "url": "https://erik.xyz/2014/11/13/php-shi-jian-han-shu/",
            "title": "php时间函数",
            "date_published": "2014-11-13T09:51:00.000Z",
            "content_html": "<p>date_default_timezone_set();设置默认时区时间 strtotime()函数，将任何英文文本的日期时间描述解析为 Unix 时间戳 getdate()函数，把生成的时间戳转化为一个数组，包含各个部分。 checkdate()函数，检查日期的有效性 格式  checkdate(月份,日期,年份) mktime()函数，取得一个日期的时间戳  格式 mktime(小时,分钟,秒,月份,日期,年份) strftime()函数，把时间戳格式化为日期和时间    格式 strftime(格式,时间戳) gmstrftime()函数和strftime()函数用法一致，只是gmstrftime()函数是显示标准的GMT时间 笔者遇到过日期和时间格式符，%Z显示的中文编码为GBK而我主体用的是utf8，所以只能转码用 iconv()函数 格式 iconv(原字符编码,要转换成的字符编码,转换目标) <a href=\"http://tietuku.com/580195791180cf87\" title=\"php时间函数\"><img src=\"http://i2.tietuku.com/580195791180cf87.jpg\" alt=\"php时间函数\"></a></p>\n",
            "tags": [
                "php",
                "php函数"
            ]
        },
        {
            "id": "https://erik.xyz/2014/11/12/php-kai-fa-zhong-shu-zu-han-shu/",
            "url": "https://erik.xyz/2014/11/12/php-kai-fa-zhong-shu-zu-han-shu/",
            "title": "php开发中数组函数",
            "date_published": "2014-11-12T08:42:00.000Z",
            "content_html": "<p>php开发中数组是经常性的用到 那就介绍一下一维数组中的排序函数 sort()函数，默认排序从低到高排列 asort()函数，根据数组元素的值升序排列 ksort()函数，根据数组元素的键值，也就是关键字的升序排列 rsort()函数正好和sort()函数相反 arsort()函数正好和asort()函数相反 krsort()函数正好和ksort()函数相反   array_unshift()函数，向数组中与添加元素   array_unshift(目标数组,要添加的元素) array_push()函数，向数组中添加元素，以实现先进先出  array_unshift(目标数组,要添加的元素) array_shift()函数，删除目标数组的头一个数组元素  array_shift(目标数组) array_pop()函数，删除目标数组的最后一个数组元素   array_pop(目标数组)   array_key_exists()函数专门针对联合数组的‘键名’进行查询 array_search()函数专门针对联合数组的‘元素值’进行查询 array_keys()函数是取得数组‘键值’ array_values()函数是取得数组‘元素值’   count()函数，为统计数组的元素个数 array_count_values()函数，为统计数组的元素值个数（只能用于一维数组） array_unique()函数实现数组中元素的唯一性，也就是去掉数组中重复的元素 array_flip()函数调换数组中的键值和元素值位置，如果有重复的键值则覆盖键值，显示最后一次赋值的键值   serialize()函数，数组序列化 unserialize()函数，数组反序列化</p>\n",
            "tags": [
                "php",
                "php函数",
                "数组函数",
                "数组排序函数"
            ]
        },
        {
            "id": "https://erik.xyz/2014/11/10/php-zhong-zi-fu-chuan-zheng-ze-han-shu/",
            "url": "https://erik.xyz/2014/11/10/php-zhong-zi-fu-chuan-zheng-ze-han-shu/",
            "title": "php中字符串、正则函数",
            "date_published": "2014-11-10T10:43:00.000Z",
            "content_html": "<h4 id=\"字符串统计\"><a href=\"#字符串统计\" class=\"headerlink\" title=\"字符串统计\"></a><strong>字符串统计</strong></h4><p>计算字符串长度在php开发中经常遇到，需要使用的函数是strlen() 字符串单词统计函数 str_word_count() (只对ASCII的英文单词起作用)</p>\n<h4 id=\"清除空格\"><a href=\"#清除空格\" class=\"headerlink\" title=\"清除空格\"></a><strong>清除空格</strong></h4><p>php开发在很多情况下要考虑客户使用便捷，比如输入用户名不小心多了一个空格，怎么办。那就用清楚空格函数 ltrim()函数是从左清除字符串头部的空格 rtrim()函数是从右清除字符串头部的空格 trim()函数是两边同时去除头部和尾部的空格 这三个函数大家可以找一下规律，trim是左右清楚，那么，ltrim中l就好比left左边，所以是左边清除。同理，右边也是。<span id=\"more\"></span></p>\n<h4 id=\"字符串切分\"><a href=\"#字符串切分\" class=\"headerlink\" title=\"字符串切分\"></a><strong>字符串切分</strong></h4><p>在php函数中常用到字符串切分，即explode()和strtok()函数。implode()函数是按照一定间隔标准组合成一个字符串。 implode()别名又用作join()功能都是一致的。在其中explode()函数用的较多，大部分是用作，邮箱、网址、文件等分割。strtok()函数与explode()相比能记住分割后的新字符串在原字符串中的位置，以便继续分割。  </p>\n<h4 id=\"字符串截取\"><a href=\"#字符串截取\" class=\"headerlink\" title=\"字符串截取\"></a><strong>字符串截取</strong></h4><p>注：每个中文占2个字符 在php开发中也会遇到截取字符串，那便用到substr()函数。其中目标字符串是某个字符串变量的变量名，起始位置和截取长度都是整数。如果都是正数，起始位置的整数必须小于街区长度的整数，否则函数返回值为假。如果截取长度为负数，则意味着，是从起始位置开始往后，除去从目标字符串结尾算起的长度的字符串以外的所有字符。 格式：substr(目标字符串,起始位置,截取长度)</p>\n<h4 id=\"字符串替换\"><a href=\"#字符串替换\" class=\"headerlink\" title=\"字符串替换\"></a><strong>字符串替换</strong></h4><p>通常在php实际开发中，往往有些部分的字符串相同，为了提高网站运行效率，我们需要替换一下，做个调用。那就是substr_replace()函数。 格式： substr_replace(目标字符串,替换字符串,起始位置,替换长度)</p>\n<h4 id=\"字符串查找\"><a href=\"#字符串查找\" class=\"headerlink\" title=\"字符串查找\"></a><strong>字符串查找</strong></h4><p>php在开发或者加密中会生成一大堆字符串，有时候我们需要定位一个字符串，就需要用到查找函数strstr()。 strstr()函数对字符大小写不敏感。 格式：strstr(目标字符串,需要查找的字符)</p>\n<h3 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a><strong>正则表达式</strong></h3><h4 id=\"正则替换字符串\"><a href=\"#正则替换字符串\" class=\"headerlink\" title=\"正则替换字符串\"></a>正则替换字符串</h4><p>在编写代码中，网站往往需要交换友情链接，为了方便我们一般都需要做个提取，是链接变得简便、好用。那就要用到php中的函数ereg_replace()和eregi_replace(),前者对大小写敏感，后者对大小写不敏感。 格式 ereg_replace(正则表达规范,欲取代字符串子串,目标字符串) <strong>正则切分字符串</strong> 大多数商城开发中，我们需要用到数组，来整合、输出不同界面的客户信息、产品信息，这就需要我们用数组来实现。在php函数中split()和spliti()函数就可以做到，把不同信息进行切分，重复调用，提高网站运行效率,前者对大小写敏感，后者对大小写不敏感。 格式 split(正则表达式,目标字符串)</p>\n",
            "tags": [
                "php",
                "lanmp",
                "php函数",
                "php字符串"
            ]
        },
        {
            "id": "https://erik.xyz/2014/11/07/php-han-shu/",
            "url": "https://erik.xyz/2014/11/07/php-han-shu/",
            "title": "php函数",
            "date_published": "2014-11-07T03:36:00.000Z",
            "content_html": "<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php </span><br><span class=\"line\">  $arr\\[0\\]\\[0\\]=10;</span><br><span class=\"line\">  $arr\\[0\\]\\[1\\]=22; </span><br><span class=\"line\">  $arr\\[1\\]\\[0\\]=1E+05; </span><br><span class=\"line\">  $arr\\[1\\]\\[1\\]=&quot;这不是来了&quot;; </span><br><span class=\"line\">  for($i=0;$i&lt;count($arr);$i++)&#123; </span><br><span class=\"line\">    for($k=0;$k&lt;count($arr\\[$i\\]);$k++)&#123;</span><br><span class=\"line\">      $arr1=each($arr\\[$i\\]); </span><br><span class=\"line\">      echo &quot;$arr1\\[value\\]&lt;br /&gt;&quot;; &#125; &#125;</span><br><span class=\"line\">      //php向函数传递参数 </span><br><span class=\"line\">      function totalneedtopay($days,$roomprice)&#123;</span><br><span class=\"line\">      $totalcost=$days*$roomprice; </span><br><span class=\"line\">      echo &quot;需要支付的总价：$totalcost&quot;.&quot;元&lt;br /&gt;&quot;;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    $rentdays=3; </span><br><span class=\"line\">    $roomprice=168; </span><br><span class=\"line\">    totalneedtopay($rentdays, $roomprice); </span><br><span class=\"line\">    totalneedtopay(5,198); //php向函数中传递参数引用 </span><br><span class=\"line\">    $fee=300; $serviceprice=50; function totalfee(&amp;$fee,$serviceprice)&#123;</span><br><span class=\"line\">    $fee=$fee+$serviceprice; echo &quot;需要支付的总价：$fee&quot;.&quot;元&lt;br /&gt;&quot;; </span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  totalfee($fee, $serviceprice); </span><br><span class=\"line\">  totalfee($fee, $serviceprice); //php从函数中返回值</span><br><span class=\"line\">  function totalneedtopay1($days1, $roomprice1)&#123; </span><br><span class=\"line\">  \treturn $days1*$roomprice1; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  $rentdays1=3; $roomprice1=168; </span><br><span class=\"line\">  echo totalneedtopay1($rentdays1, $roomprice1); </span><br><span class=\"line\">?&gt; </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>",
            "tags": [
                "php",
                "php函数"
            ]
        }
    ]
}