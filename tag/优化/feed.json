{
    "version": "https://jsonfeed.org/version/1",
    "title": "艾瑞可erik • All posts by \"优化\" tag • All posts by \"undefined\" categories",
    "description": "一只PHP开发的程序猿，偶尔做做运维、Goland、Python、Java、摄影、画画、写作、顺便睡觉，反正整站都搞过。",
    "home_page_url": "https://erik.xyz",
    "items": [
        {
            "id": "https://erik.xyz/2024/05/06/index-asynchrony-landing/",
            "url": "https://erik.xyz/2024/05/06/index-asynchrony-landing/",
            "title": "增加索引 + 异步 + 不落地后，从 12h 优化到 15 min",
            "date_published": "2024-05-06T03:44:00.000Z",
            "content_html": "<p>在开发中，我们经常会遇到这样的需求，将数据库中的图片导出到本地，再传给别人。</p>\n<h4 id=\"一、一般我会这样做：\"><a href=\"#一、一般我会这样做：\" class=\"headerlink\" title=\"一、一般我会这样做：\"></a>一、一般我会这样做：</h4><p>1.通过接口或者定时任务的形式</p>\n<p>2.读取Oracle或者MySQL数据库</p>\n<p>3.通过FileOutputStream将Base64解密后的byte[]存储到本地</p>\n<p>4.遍历本地文件夹，将图片通过FTP上传到第三方服务器<br><span id=\"more\"></span><br><img src=\"/img/2024/202405100.webp\" alt=\"erik.xyz\"></p>\n<p>现场炸锅了！</p>\n<p>实际的数据量非常大，据统计差不多有400G的图片需要导出。</p>\n<p><strong>现场人员的反馈是，已经跑了12个小时了，还在继续，不知道啥时候能导完。</strong></p>\n<p>停下来呢？之前的白导了，不停呢？不知道要等到啥时候才能导完。</p>\n<p>这不行啊，速度太慢了，一个简单的任务，不能被这东西耗死吧？<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Value(&quot;$&#123;months&#125;&quot;)</span><br><span class=\"line\">private String months;</span><br><span class=\"line\"></span><br><span class=\"line\">@Value(&quot;$&#123;imgDir&#125;&quot;)</span><br><span class=\"line\">private String imgDir;</span><br><span class=\"line\"></span><br><span class=\"line\">@Resource</span><br><span class=\"line\">private UserDao userDao;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">public void getUserInfoImg() &#123;</span><br><span class=\"line\"> try &#123;</span><br><span class=\"line\">  // 获取需要导出的月表</span><br><span class=\"line\">  String[] monthArr = months.split(&quot;,&quot;);</span><br><span class=\"line\">  for (int i = 0; i &lt; monthArr.length; i++) &#123;</span><br><span class=\"line\">   // 获取月表中的图片</span><br><span class=\"line\">   Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class=\"line\">   String tableName = &quot;USER_INFO_&quot; + monthArr[i];</span><br><span class=\"line\">   map.put(&quot;tableName&quot;, tableName);</span><br><span class=\"line\">   map.put(&quot;status&quot;, 1);</span><br><span class=\"line\">   </span><br><span class=\"line\">   List&lt;UserInfo&gt; userInfoList = userDao.getUserInfoImg(map);</span><br><span class=\"line\">   if (userInfoList == null || userInfoList.size() == 0) &#123;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   for (int j = 0; j &lt; userInfoList.size(); j++) &#123;</span><br><span class=\"line\">    UserInfo user = userInfoList.get(j);</span><br><span class=\"line\">    String userId = user.getUserId();</span><br><span class=\"line\">    String userName = user.getUserName();</span><br><span class=\"line\">    byte[] content = user.getImgContent;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 下载图片到本地</span><br><span class=\"line\">    FileUtil.dowmloadImage(imgDir + userId+&quot;-&quot;+userName+&quot;.png&quot;, content);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 将下载好的图片，通过FTP上传给第三方</span><br><span class=\"line\">    FileUtil.uploadByFtp(imgDir);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125; catch (Exception e) &#123;</span><br><span class=\"line\">  serviceLogger.error(&quot;获取图片异常：&quot;, e);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"二、谁写的？赶紧加班优化，会追责吗？\"><a href=\"#二、谁写的？赶紧加班优化，会追责吗？\" class=\"headerlink\" title=\"二、谁写的？赶紧加班优化，会追责吗？\"></a>二、谁写的？赶紧加班优化，会追责吗？</h4><p>经过1小时的深思熟虑，慢的原因可能有以下几点：</p>\n<p>1.查询数据库</p>\n<p>2.程序串行</p>\n<p>3.base64解密</p>\n<p>4.图片落地</p>\n<p>5.FTP上传到服务器</p>\n<p>优化1：数据库中添加对应的索引，提高查询速度</p>\n<p>优化2：采用增加索引+异步+多线程的方式进行导出</p>\n<p><img src=\"/img/2024/202405101.webp\" alt=\"erik.xyz\"></p>\n<p>优化3：不解密+图片不落地，直接通过FTP传给第三方</p>\n<p><img src=\"/img/2024/202405102.webp\" alt=\"erik.xyz\"></p>\n<p><strong>使用索引+异步+不解密+不落地 后，40G图片的导出上传，从12+小时 优化到15 分钟，你敢信？</strong></p>\n<p>差不多的代码，效率差距竟如此之大。</p>\n<p>下面贴出导出图片不落地的关键代码。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Resource</span><br><span class=\"line\">private UserAsyncService userAsyncService;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">public void getUserInfoImg() &#123;</span><br><span class=\"line\"> try &#123;</span><br><span class=\"line\">  // 获取需要导出的月表</span><br><span class=\"line\">  String[] monthArr = months.split(&quot;,&quot;);</span><br><span class=\"line\">  for (int i = 0; i &lt; monthArr.length; i++) &#123;</span><br><span class=\"line\">   userAsyncService.getUserInfoImgAsync(monthArr[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125; catch (Exception e) &#123;</span><br><span class=\"line\">  serviceLogger.error(&quot;获取图片异常：&quot;, e);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Value(&quot;$&#123;months&#125;&quot;)</span><br><span class=\"line\">private String months;</span><br><span class=\"line\"></span><br><span class=\"line\">@Resource</span><br><span class=\"line\">private UserDao userDao;</span><br><span class=\"line\"></span><br><span class=\"line\">@Async(&quot;async-executor&quot;)</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public void getUserInfoImgAsync(String month) &#123;</span><br><span class=\"line\"> try &#123;</span><br><span class=\"line\">  // 获取月表中的图片</span><br><span class=\"line\">  Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class=\"line\">  String tableName = &quot;USER_INFO_&quot; + month;</span><br><span class=\"line\">  map.put(&quot;tableName&quot;, tableName);</span><br><span class=\"line\">  map.put(&quot;status&quot;, 1);</span><br><span class=\"line\">  </span><br><span class=\"line\">  List&lt;UserInfo&gt; userInfoList = userDao.getUserInfoImg(map);</span><br><span class=\"line\">  if (userInfoList == null || userInfoList.size() == 0) &#123;</span><br><span class=\"line\">   return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  for (int i = 0; i &lt; userInfoList.size(); i++) &#123;</span><br><span class=\"line\">   UserInfo user = userInfoList.get(i);</span><br><span class=\"line\">   String userId = user.getUserId();</span><br><span class=\"line\">   String userName = user.getUserName();</span><br><span class=\"line\">   byte[] content = user.getImgContent;</span><br><span class=\"line\">   </span><br><span class=\"line\">   // 不落地，直接通过FTP上传给第三方</span><br><span class=\"line\">   FileUtil.uploadByFtp(content);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125; catch (Exception e) &#123;</span><br><span class=\"line\">  serviceLogger.error(&quot;获取图片异常：&quot;, e);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><strong>4、异步线程池工具类</strong></p>\n<p><strong>@Async的作用就是异步处理任务。</strong></p>\n<p>1.在方法上添加@Async，表示此方法是异步方法；</p>\n<p>2.在类上添加@Async，表示类中的所有方法都是异步方法；</p>\n<p>3.使用此注解的类，必须是Spring管理的类；</p>\n<p>4.需要在启动类或配置类中加入@EnableAsync注解，@Async才会生效；</p>\n<p>在使用@Async时，如果不指定线程池的名称，也就是不自定义线程池，@Async是有默认线程池的，使用的是Spring默认的线程池SimpleAsyncTaskExecutor。</p>\n<p>默认线程池的默认配置如下：</p>\n<p>1.默认核心线程数：8；</p>\n<p>2.最大线程数：Integet.MAX_VALUE；</p>\n<p>3.队列使用LinkedBlockingQueue；</p>\n<p>4.容量是：Integet.MAX_VALUE；</p>\n<p>5.空闲线程保留时间：60s；</p>\n<p>6.线程池拒绝策略：AbortPolicy；</p>\n<p>从最大线程数可以看出，在并发情况下，会无限制的创建线程，我勒个吗啊。</p>\n<p><strong>也可以通过yml重新配置：</strong><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring:</span><br><span class=\"line\">  task:</span><br><span class=\"line\">    execution:</span><br><span class=\"line\">      pool:</span><br><span class=\"line\">        max-size: 10</span><br><span class=\"line\">        core-size: 5</span><br><span class=\"line\">        keep-alive: 3s</span><br><span class=\"line\">        queue-capacity: 1000</span><br><span class=\"line\">        thread-name-prefix: my-executor</span><br></pre></td></tr></table></figure></p>\n<p>也可以自定义线程池，下面通过简单的代码来实现以下@Async自定义线程池。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@EnableAsync// 支持异步操作</span><br><span class=\"line\">@Configuration</span><br><span class=\"line\">public class AsyncTaskConfig &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * com.google.guava中的线程池</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Bean(&quot;my-executor&quot;)</span><br><span class=\"line\">    public Executor firstExecutor() &#123;</span><br><span class=\"line\">        ThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat(&quot;my-executor&quot;).build();</span><br><span class=\"line\">        // 获取CPU的处理器数量</span><br><span class=\"line\">        int curSystemThreads = Runtime.getRuntime().availableProcessors() * 2;</span><br><span class=\"line\">        ThreadPoolExecutor threadPool = new ThreadPoolExecutor(curSystemThreads, 100,</span><br><span class=\"line\">                200, TimeUnit.SECONDS,</span><br><span class=\"line\">                new LinkedBlockingQueue&lt;&gt;(), threadFactory);</span><br><span class=\"line\">        threadPool.allowsCoreThreadTimeOut();</span><br><span class=\"line\">        return threadPool;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Spring线程池</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Bean(&quot;async-executor&quot;)</span><br><span class=\"line\">    public Executor asyncExecutor() &#123;</span><br><span class=\"line\">        ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor();</span><br><span class=\"line\">        // 核心线程数</span><br><span class=\"line\">        taskExecutor.setCorePoolSize(24);</span><br><span class=\"line\">        // 线程池维护线程的最大数量，只有在缓冲队列满了之后才会申请超过核心线程数的线程</span><br><span class=\"line\">        taskExecutor.setMaxPoolSize(200);</span><br><span class=\"line\">        // 缓存队列</span><br><span class=\"line\">        taskExecutor.setQueueCapacity(50);</span><br><span class=\"line\">        // 空闲时间，当超过了核心线程数之外的线程在空闲时间到达之后会被销毁</span><br><span class=\"line\">        taskExecutor.setKeepAliveSeconds(200);</span><br><span class=\"line\">        // 异步方法内部线程名称</span><br><span class=\"line\">        taskExecutor.setThreadNamePrefix(&quot;async-executor-&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略</span><br><span class=\"line\">         * 通常有以下四种策略：</span><br><span class=\"line\">         * ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。</span><br><span class=\"line\">         * ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。</span><br><span class=\"line\">         * ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span><br><span class=\"line\">         * ThreadPoolExecutor.CallerRunsPolicy：重试添加当前的任务，自动重复调用 execute() 方法，直到成功</span><br><span class=\"line\">         */</span><br><span class=\"line\">        taskExecutor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class=\"line\">        taskExecutor.initialize();</span><br><span class=\"line\">        return taskExecutor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"三、告别劣质代码，优化从何入手？\"><a href=\"#三、告别劣质代码，优化从何入手？\" class=\"headerlink\" title=\"三、告别劣质代码，优化从何入手？\"></a>三、告别劣质代码，优化从何入手？</h4><p>我觉得优化有两个大方向：</p>\n<p>1.业务优化</p>\n<p>2.代码优化</p>\n<p><strong>1、业务优化业</strong></p>\n<p>务优化的影响力非常大，但它一般属于产品和项目经理的范畴，CRUD程序员很少能接触到。</p>\n<p>比如上面说的图片导出上传需求，经过产品经理和项目经理的不懈努力，这个需求不做了，这优化力度，史无前例啊。</p>\n<p><strong>2、代码优化</strong></p>\n<p>1.数据库优化</p>\n<p>2.复用优化</p>\n<p>3.并行优化</p>\n<p>4.算法优化<br><img src=\"/img/2024/202405103.webp\" alt=\"erik.xyz\"></p>\n<h4 id=\"四、数据库优化\"><a href=\"#四、数据库优化\" class=\"headerlink\" title=\"四、数据库优化\"></a>四、数据库优化</h4><p>1.inner join 、left join、right join，优先使用inner join</p>\n<p>2.表连接不宜太多，索引不宜太多，一般5个以内</p>\n<p>3.复合索引最左特性</p>\n<p>4.操作delete或者update语句，加个limit或者循环分批次删除</p>\n<p>5.使用explain分析你SQL执行计划</p>\n<p>SQL性能优化的47个小技巧，果断收藏！</p>\n<h4 id=\"五、复用优化\"><a href=\"#五、复用优化\" class=\"headerlink\" title=\"五、复用优化\"></a>五、复用优化</h4><p>写代码的时候，大家一般都会将重复性的代码提取出来，写成工具方法，在下次用的时候，就不用重新编码，直接调用就可以了。</p>\n<p>这个就是复用。</p>\n<p>数据库连接池、线程池、长连接也都是复用手段，这些对象的创建和销毁成本过高，复用之后，效率提升显著。</p>\n<p><strong>1、连接池</strong></p>\n<p>连接池是一种常见的优化网络连接复用性的方法。连接池管理着一定数量的网络连接，并且在需要时将这些连接分配给客户端，客户端使用完后将连接归还给连接池。这样可以避免每次通信都建立新的连接，减少了连接的建立和销毁过程，提高了系统的性能和效率。</p>\n<p>在Java开发中，常用的连接池技术有Apache Commons Pool、Druid等。使用连接池时，需要合理设置连接池的大小，并根据实际情况进行调优。连接池的大小过小会导致连接不够用，而过大则会占用过多的系统资源。</p>\n<p><strong>2、长连接</strong></p>\n<p>长连接是另一种优化网络连接复用性的方法。长连接指的是在一次通信后，保持网络连接不关闭，以便后续的通信继续复用该连接。与短连接相比，长连接在一定程度上减少了连接的建立和销毁过程，提高了网络连接的复用性和效率。</p>\n<p>在Java开发中，可以通过使用Socket编程实现长连接。客户端在建立连接后，通过设置Socket的Keep-Alive选项，使得连接保持活跃状态。这样可以避免频繁地建立新的连接，提高网络连接的复用性和效率。</p>\n<p><strong>3、缓存</strong></p>\n<p>缓存也是比较常用的复用，属于数据复用。</p>\n<p>缓存一般是将数据库中的数据缓存到内存或者Redis中，也就是缓存到相对高速的区域，下次查询时，直接访问缓存，就不用查询数据库了，缓存主要针对的是读操作。</p>\n<p><strong>4、缓冲</strong></p>\n<p>缓冲常见于对数据的暂存，然后批量传输或者写入。多使用顺序方式，用来缓解不同设备之间频繁地、缓慢地随机写，缓冲主要针对的是写操作。</p>\n<h4 id=\"六、并行优化\"><a href=\"#六、并行优化\" class=\"headerlink\" title=\"六、并行优化\"></a>六、并行优化</h4><p><strong>1、异步编程</strong></p>\n<p>上面的优化方式就是异步优化，充分利用多核处理器的性能，将串行的程序改为并行，大大提高了程序的执行效率。</p>\n<p>异步编程是一种编程模型，其中任务的执行不会阻塞当前线程的执行。通过将任务提交给其他线程或线程池来处理，当前线程可以继续执行其他操作，而不必等待任务完成。</p>\n<p><strong>2、异步编程的特点</strong></p>\n<p>1.非阻塞：异步任务的执行不会导致调用线程的阻塞，允许线程继续执行其他任务；</p>\n<p>2.回调机制：异步任务通常会注册回调函数，当任务完成时，会调用相应的回调函数进行后续处理；</p>\n<p>3.提高响应性：异步编程能够提高程序的响应性，尤其适用于处理IO密集型任务，如网络请求、数据库查询等；</p>\n<p>Java 8引入了CompletableFuture类，可以方便地进行异步编程。</p>\n<p><strong>3、并行编程</strong></p>\n<p>并行编程是一种利用多个线程或处理器同时执行多个任务的编程模型。它将大任务划分为多个子任务，并发地执行这些子任务，从而加速整体任务的完成时间。</p>\n<p><strong>4、并行编程的特点</strong></p>\n<p>1.分布式任务：并行编程将大任务划分为多个独立的子任务，每个子任务在不同的线程中并行执行；</p>\n<p>2..数据共享：并行编程需要考虑多个线程之间的数据共享和同步问题，以避免出现竞态条件和数据不一致的情况；</p>\n<p>3.提高性能：并行编程能够充分利用多核处理器的计算能力，加速程序的执行速度。</p>\n<p><strong>5、并行编程如何实现？</strong></p>\n<p>1.多线程：Java提供了Thread类和Runnable接口，用于创建和管理多个线程。通过创建多个线程并发执行任务，可以实现并行编程。</p>\n<p>2.线程池：Java的Executor框架提供了线程池的支持，可以方便地管理和调度多个线程。通过线程池，可以复用线程对象，减少线程创建和销毁的开销；</p>\n<p>3.并发集合：Java提供了一系列的并发集合类，如ConcurrentHashMap、ConcurrentLinkedQueue等，用于在并行编程中实现线程安全的数据共享。</p>\n<p>异步编程和并行编程是Java中处理任务并提高程序性能的两种重要方法。</p>\n<p>异步编程通过非阻塞的方式处理任务，提高程序的响应性，并适用于IO密集型任务。</p>\n<p>而并行编程则是通过多个线程或处理器并发执行任务，充分利用计算资源，加速程序的执行速度。</p>\n<p>在Java中，可以使用CompletableFuture和回调接口实现异步编程，使用多线程、线程池和并发集合实现并行编程。通过合理地运用异步和并行编程，我们可以在Java中高效地处理任务和提升程序的性能。</p>\n<p><strong>6、代码示例</strong><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    // 创建线程池</span><br><span class=\"line\">    ExecutorService executor = Executors.newFixedThreadPool(10);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 使用线程池创建CompletableFuture对象</span><br><span class=\"line\">    CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">        // 一些不为人知的操作</span><br><span class=\"line\">        return &quot;result&quot;; // 返回结果</span><br><span class=\"line\">    &#125;, executor);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 使用CompletableFuture对象执行任务</span><br><span class=\"line\">    CompletableFuture&lt;String&gt; result = future.thenApply(result -&gt; &#123;</span><br><span class=\"line\">        // 一些不为人知的操作</span><br><span class=\"line\">        return &quot;result&quot;; // 返回结果</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 处理任务结果</span><br><span class=\"line\">    String finalResult = result.join();</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 关闭线程池</span><br><span class=\"line\">    executor.shutdown();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>7、Java 8 parallel</strong></p>\n<p><strong>（1）parallel()是什么</strong></p>\n<p>Stream.parallel() 方法是 Java 8 中 Stream API 提供的一种并行处理方式。在处理大量数据或者耗时操作时，使用 Stream.parallel() 方法可以充分利用多核 CPU 的优势，提高程序的性能。</p>\n<p>Stream.parallel() 方法是将串行流转化为并行流的方法。通过该方法可以将大量数据划分为多个子任务交由多个线程并行处理，最终将各个子任务的计算结果合并得到最终结果。使用 Stream.parallel() 可以简化多线程编程，减少开发难度。</p>\n<p>需要注意的是，并行处理可能会引入线程安全等问题，需要根据具体情况进行选择。</p>\n<p><strong>（2）举一个简单的demo</strong></p>\n<p>定义一个list，然后通过parallel() 方法将集合转化为并行流，对每个元素进行i++，最后通过 collect(Collectors.toList()) 方法将结果转化为 List 集合。</p>\n<p>使用并行处理可以充分利用多核 CPU 的优势，加快处理速度。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">            list.add(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\">        List&lt;Integer&gt; result = list.stream().parallel().map(i -&gt; i++).collect(Collectors.toList());</span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>我勒个去，什么情况？<br><img src=\"/img/2024/202405104.webp\" alt=\"erik.xyz\"></p>\n<p><strong>（3）parallel()的优缺点</strong></p>\n<p><strong>①优点：</strong></p>\n<p>1.充分利用多核 CPU 的优势，提高程序的性能；</p>\n<p>2.可以简化多线程编程，减少开发难度。</p>\n<p><strong>②缺点：</strong></p>\n<p>1.并行处理可能会引入线程安全等问题，需要根据具体情况进行选择；</p>\n<p>2.并行处理需要付出额外的开销，例如线程池的创建和销毁、线程切换等，对于小数据量和简单计算而言，串行处理可能更快。</p>\n<p><strong>（4）何时使用parallel()？</strong></p>\n<p>在实际开发中，应该根据数据量、计算复杂度、硬件等因素综合考虑。</p>\n<p>比如：</p>\n<p>1.数据量较大，有1万个元素；</p>\n<p>2.计算复杂度过大，需要对每个元素进行复杂的计算；</p>\n<p>3.硬件够硬，比如多核CPU。</p>\n<h4 id=\"七、算法优化\"><a href=\"#七、算法优化\" class=\"headerlink\" title=\"七、算法优化\"></a>七、算法优化</h4><p>在上面的例子中，避免base64解密，就应该归类于算法优化。</p>\n<p>程序就是由数据结构和算法组成，一个优质的算法可以显著提高程序的执行效率，从而减少运行时间和资源消耗。相比之下，一个低效的算法就可能导致运行非常缓慢，并占用大量系统资源。</p>\n<p>很多问题都可以通过算法优化来解决，比如：</p>\n<p><strong>1、循环和递归</strong></p>\n<p>循环和递归是Java编程中常见的操作，然而，过于复杂的业务逻辑往往会带来多层循环套用，不必要的重复循环会大大降低程序的执行效率。</p>\n<p>递归是一种函数自我调用的技术，类似于循环，虽然递归可以解决很多问题，但是，递归的效率有待提高。</p>\n<p><strong>2、内存管理</strong></p>\n<p>Java自带垃圾收集器，开发人员不用手动释放内存。</p>\n<p>但是，不合理的内存使用可能导致内存泄漏和性能下降，确保及时释放不再使用的对象，避免创建过多的临时对象。</p>\n<p><strong>3、字符串</strong></p>\n<p>我觉得字符串是Java编程中使用频率最高的技术，很多程序员恨不得把所有的变量都定义成字符串。</p>\n<p>然而，由于字符串是不可变的，每次执行字符串拼接、替换时，都会创建一个新的字符串。这会占用大量的内存和处理时间。</p>\n<p>使用StringBuilder来处理字符串的拼接可以显著的提高性能。</p>\n<p><strong>4、IO操作</strong></p>\n<p>IO操作通常是最耗费性能和资源的操作。在处理大量数据IO操作时，务必注意优化IO代码，提高程序性能，比如上面提高的图片不落地就是彻底解决IO问题。</p>\n<p><strong>5、数据结构的选择</strong></p>\n<p>选择适当的数据结构对程序的性能至关重要。</p>\n<p>比如Java世界中用的第二多的Map，比较常用的有HashMap、HashTable、ConcurrentHashMap。</p>\n<p>HashMap，底层数组+链表实现，可以存储null键和null值，线程不安全；</p>\n<p>HashTable，底层数组+链表实现，无论key还是value都不能为null，线程安全，实现线程安全的方式是在修改数据时锁住整个HashTable，效率低，ConcurrentHashMap做了相关优化；</p>\n<p>ConcurrentHashMap，底层采用分段的数组+链表实现，线程安全，通过把整个Map分为N个Segment，可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。</p>\n<p>Hashtable的synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。</p>\n<p>转载自：<a href=\"https://mp.weixin.qq.com/s/V2p_p-KoDowlZxLN2by2Sg\">哪吒编程</a></p>\n",
            "tags": [
                "web",
                "优化"
            ]
        },
        {
            "id": "https://erik.xyz/2017/11/17/ru-he-chu-li-wang-zhan-xiang-ying-man-de-wen-ti/",
            "url": "https://erik.xyz/2017/11/17/ru-he-chu-li-wang-zhan-xiang-ying-man-de-wen-ti/",
            "title": "如何处理网站响应慢的问题",
            "date_published": "2017-11-17T13:19:00.000Z",
            "content_html": "<p>当一个网页请求量在10W+的时候出现慢或者很卡的情况如何解决呢？ 1.后台数据</p>\n<ul>\n<li>把所有的数据放进缓存，让服务器内存来处理。</li>\n<li>优化数据获取代码。</li>\n<li>减少接口的重复请求<span id=\"more\"></span>\n</li>\n</ul>\n<p>2.服务器</p>\n<ul>\n<li>开启服务器多线程服务。</li>\n<li>查看cpu负载和内存负载。</li>\n<li>检查服务器宽带。</li>\n<li>去掉重定向</li>\n</ul>\n<p>3.页面</p>\n<ul>\n<li>使用第三方cnd加载js公共文件。</li>\n<li>压缩图片和其他类型的文件（资源加载压缩）。</li>\n<li>优化js代码处理。</li>\n<li>预加载页面（延迟渲染），延迟执行js。</li>\n<li>把js/css/图片缓存至本地浏览器。</li>\n<li>优化js代码</li>\n</ul>\n",
            "tags": [
                "优化",
                "响应慢",
                "页面优化"
            ]
        },
        {
            "id": "https://erik.xyz/2015/01/10/ji-yu-sphinx-gou-jian-zhun-shi-shi-geng-xin-de-fen-bu-shi-tong-yong-sou-suo-yin-qing-ping-tai/",
            "url": "https://erik.xyz/2015/01/10/ji-yu-sphinx-gou-jian-zhun-shi-shi-geng-xin-de-fen-bu-shi-tong-yong-sou-suo-yin-qing-ping-tai/",
            "title": "基于Sphinx构建准实时更新的分布式通用搜索引擎平台",
            "date_published": "2015-01-10T13:21:00.000Z",
            "content_html": "<p>作者：张宴 前言： 2008年7月，我写过一篇文章《<a href=\"http://blog.zyan.cc/post/360/\">基于Sphinx+MySQL的千万级数据全文检索（搜索引擎）架构设计</a>》。有不少网友希望阅读全文，我将该文档整理了一下，分享出来。文档解压后大小为7.33M，共19页。 <strong>本站下载地址：</strong> <a href=\"http://blog.zyan.cc/book/sphinx/sphinx_mysql.zip\">http://blog.zyan.cc/book/sphinx/sphinx_mysql.zip</a> <strong>新浪下载分流：</strong> <a href=\"http://ishare.iask.sina.com.cn/f/6728201.html\">http://ishare.iask.sina.com.cn/f/6728201.html</a> 上述文档架构存在的局限，我在2008年12月的文章《<a href=\"http://blog.zyan.cc/post/385/\">亿级数据的高并发通用搜索引擎架构设计</a>》 中已经指出：一是MySQL本身的并发能力有限，在200～300个并发连接下，查询和更新就比较慢了；二是由于MySQL表的主键与Sphinx索引的 ID一一对应，从而无法跨多表建立整站查询，而且新增加类别还得修改配置文件，比较麻烦；三是因为和MySQL集成，无法发挥出Sphinx的优势。虽然 如此，但对于一些写入量不大的搜索应用，已经足够了，或许对很多人会有帮助。<br><span id=\"more\"></span></p>\n<hr>\n<p>正文： 在这之后，本人基于《<a href=\"http://blog.zyan.cc/post/385/\">亿级数据的高并发通用搜索引擎架构设计</a>》开发的Sphinx分布式通用站内搜索引擎平台，已经在生产环境运行9个月以上，经过运营中的不断完善与改进，目前已形成了一套可扩展的分布式通用站内搜索引擎框架。CMS、视频、论坛等产品发生的增、删、改操作，文本内容实时写入自行开发的 <a href=\"http://blog.zyan.cc/httpsqs\">HTTPSQS</a> 高性能简单消息队列服务，通过队列控制器更新索引和存储。提供支持XML、JSON的API查询接口，支持亿级数据的索引、分布式、中文分词、高亮显示、自动摘要、准实时（1分钟内）增量索引更新。</p>\n<p><a href=\"http://zyan.cc/attachment/201002/search_system.png\"><img src=\"http://zyan.cc/attachment/201002/search_system.png\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\"></a> </p>\n<p>下面是Sphinx新的搜索架构中技术关键点实现方式的一些介绍，与大家分享、交流一下： <strong>1、一元分词和中文分词的结合：</strong> ①、一元分词位于索引更新模块。Sphinx索引引擎对于CJK（中日韩）语言（必须是UTF-8编码）支持一元切分，假设【反恐行动是国产主视角射击 网络游戏】这段文字，Sphinx会将其切成【反 恐 行 动 是 国 产 主 视 角 射 击 网 络 游 戏】，然后对每个字建立反向索引。如果用这句话中包含的字组成一个不存在的词语，例如【恐动】，也会被搜索到，所以搜索时，需要加引号，例如搜索【”反恐 行动”】，就能完全匹配连在一起的四个字，不连续的【”恐动”】就不会被搜索到。但是，这样还有一个问题，搜索【”反恐行动游戏”】或【”国产网络游 戏”】就会搜索不到。对于这个问题，采用位于搜索查询模块的中文分词来处理。 sphinx.conf配置文件中关于UTF-8中文一元分词的配置如下：</p>\n<p>…省略… </p>\n<pre><code>    index t_source_main &#123; \n      source                  = t_source_main\n      path                    = /data0/search/sphinx/data/t_source_main \n      docinfo                 = extern\n      mlock                     = 0 \n      morphology              = none \n      min_word_len            = 1 \n      charset_type            = utf-8 \n      min_prefix_len          = 0 \n      html_strip              = 1 \n      charset_table           = 0..9, A..Z-&gt;a..z, \\_, a..z, U+410..U+42F-&gt;U+430..U+44F, U+430..U+44F \n      ngram_len               = 1 \n      ngram_chars             = U+3000..U+2FA1F \n    &#125;\n</code></pre><p>…省略…</p>\n<p>②、中文分词位于搜索查询模块。搜索“反恐行动游戏”、“国产网络游戏”，先调用独立的中文分词系统，分别切分为“反恐行动 游戏”、“国产 网络游戏”，这时候，再给以空格分隔的词语加上引号，去Sphinx搜索【”反恐行动” “游戏”】或【”国产” “网络游戏”】，就能搜索到这条记录了。中文分词词库发生增、删、改，无需重建整个Sphinx搜索索引。</p>\n<hr>\n<p><strong>2、使用自行开发的HTTPSQS（<a href=\"http://code.google.com/p/httpsqs\">http://code.google.com/p/httpsqs</a>）开源简单队列服务程序，来缓冲高并发数据写入</strong> 新闻、论坛帖子、客服公告、SNS社区等发生的增、删、改操作，文本内容通过更新接口实时写入HTTPSQS队列，再通过队列控制器更新到Sphinx搜索引擎索引中。</p>\n<hr>\n<p><strong>3、Sphinx不能严格按照字段排序的小问题</strong> 如果不想使用权重，只希望严格按照时间、主键等排序，而匹配模式（Matching modes）又为非SPH_MATCH_BOOLEAN时（比较常用的是SPH_MATCH_ALL、 SPH_MATCH_EXTENDED），Sphinx搜索结果在某一页中的排序会不太准确。例如：按照UNIX时间戳倒序排序，0,20为第一 页，20,40为第二页，第一页的最小时间戳一定会大于第二页的最大时间戳，但是，第一页中的0,20条记录却不会严格按照时间戳排序，第二页亦是如此。 因此，如果需要精确排序，用户翻到搜索结果的某一页，就需要对Sphinx在某一搜索结果页中的记录另行再排序，在我的这套搜索架构中，这一再排序操作由 search.php查询接口使用array_multisort()函数处理。一般情况下，一页只会显示5～30条记录，因此，只对几十条记录采用 PHP再排序，速度也是非常快的。</p>\n<hr>\n<p><strong>4、队列控制器中“时间控制”与“数量控制”相结合，实现搜索索引的1分钟内准实时更新：</strong> ①、Sphinx 0.9.9生产环境的建索引速度大约在5.5 Mbytes/秒、6400文档/秒。队列控制器可以设置10秒钟更新一次增量索引，只要Sphinx增量索引数据源的文档数在38万以内，就能保证增量 索引在1～60秒内得到更新，这是从“时间”上进行控制。 ②、为了避免增量索引数据源的文档数增长到38万，队列控制器在增量索引数据源的文档数超过1万时，还将激活增量索引合并入主索引的操作，合并完成的文档将从增量索引数据源中删除，这是从“数量”上进行控制。</p>\n<hr>\n<p><strong>5、自行编写的“搜索引擎查询API接口”调用说明：</strong></p>\n<p><a href=\"http://xxx.xxx.xxx.xxx/search.php?query=%E9%87%91%E5%B1%B1%C2%A0%C2%A0\">http://xxx.xxx.xxx.xxx/search.php?query=%E9%87%91%E5%B1%B1  </a>（搜索关键字。程序能够识别关键字是GBK编码还是UTF-8编码，能够识别关键字是否进行了URL编码） &amp;output=xml  （输出类型支持：xml 或 json） &amp;excerpts=1  （是否开启高亮显示与文本摘要，1开启 或 0关闭） &amp;excerpts_before=<font color=red>  （高亮显示与文本摘要，如果为空值则不进行高亮显示与文本摘要。在匹配的关键字前面插入的字符串。） &amp;excerpts_after=</font>  （高亮显示与文本摘要，如果为空值则不进行高亮显示与文本摘要。在匹配的关键字之后插入的字符串。） &amp;excerpts_limit=256  （高亮显示与文本摘要，如果为空值则不进行高亮显示与文本摘要。摘要最多包含的符号（码点）数。） &amp;excerpts_field=c1,c2,c3,c4,c5  （仅对指定的字段进行高亮显示，其余字段不进行高亮显示，如果此参数为空，则默认所有的字符型字段都进行高亮显示） &amp;offset=0&amp;limit=20  （相当于SQL语句中的limit 0,20） &amp;max_matches=30000  （最大搜索结果集数量） &amp;match_mode=SPH_MATCH_EXTENDED2 &amp;ranking_mode=SPH_RANK_PROXIMITY_BM25 &amp;sort_mode=SPH_SORT_EXTENDED&amp;sort_by=@relevance DESC,u1 ASC,@id DESC  （排序模式：@relevance和@id是内置变量，@relevance代表相关度权值，@id等于search_id，u1为字段名） &amp;field_weights=c1,7;c2,1  （权重设置：字段c1的权重为7，字段c2的权重为1） &amp;filter=u1:0_1_6,false;u2:4,true  （整数值过滤器：匹配字段u1等于0、1或6，并且字段u2不等于4的结果集。false表示等于，true表示不等于） &amp;filter_range=u1:0,100,false;u2:50,90,true  （整数范围过滤器：字段u1 &gt;= 0并且u1 &lt;= 100，字段u2 &lt; 50并且u2 &gt; 90） &amp;filter_range=u1:1.23,99.645,false; u2:1034.3,7834.56,true  （浮点数范围过滤器：字段u1 &gt;= 1.23并且u1 &lt;= 99.645，字段u2 &lt; 1034.3并且u2 &gt; 7834.56）</p>\n<hr>\n<p><strong>6、搜索结果前台页面示例：</strong></p>\n<p><a href=\"http://zyan.cc/attachment/201002/search_example.png\"><img src=\"http://zyan.cc/attachment/201002/search_example.png\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\"></a></p>\n<hr>\n<p><strong>7、同一套服务器平台与API接口，通用于各类产品：</strong> 示例： 金山游戏文章与视频搜索：<a href=\"http://s.xoyo.com/result.php?w=%E5%89%91%E7%BD%913\">http://s.xoyo.com/result.php?w=%E5%89%91%E7%BD%913</a> 金山游戏论坛帖子搜索：<a href=\"http://jx3.bbs.xoyo.com/search2.php?srchtxt=%E4%B8%83%E7%A7%80&amp;select=title\">http://jx3.bbs.xoyo.com/search2.php?srchtxt=%E4%B8%83%E7%A7%80&amp;select=title</a> 原文链接：<a href=\"http://blog.zyan.cc/sphinx_search/\">http://blog.zyan.cc/sphinx_search/</a></p>\n",
            "tags": [
                "web",
                "优化",
                "搜引擎ping服务器",
                "搜索引擎"
            ]
        },
        {
            "id": "https://erik.xyz/2014/10/25/bai-du-tong-ji-ce-shi-wang-zhan-xiang-ying-su-du-jiang-di/",
            "url": "https://erik.xyz/2014/10/25/bai-du-tong-ji-ce-shi-wang-zhan-xiang-ying-su-du-jiang-di/",
            "title": "百度统计测试网站响应速度降低",
            "date_published": "2014-10-25T02:27:00.000Z",
            "content_html": "<p><img src=\"http://img03.taobaocdn.com/imgextra/i1/809419769/TB2UVibaVXXXXbHXXXXXXXXXXXX_!!809419769.jpg\" alt=\"seo\"> <span id=\"more\"></span>前段时间用百度统计刚刚把网站响应速度跑个满分，过个2天却又降了下来，很是郁闷啊。到底是怎么回事呢，还得从头开始分析原因。从百度统计测试看有一大堆提示，什么图片过大，没有Gzip压缩…… <img src=\"http://img02.taobaocdn.com/imgextra/i2/809419769/TB2EV5aaVXXXXcnXXXXXXXXXXXX_!!809419769.jpg\" alt=\"优化详解\"> 先分析一下，我用wp super cache开启了预缓存才出现，没有Gzip压缩。关闭预缓存问题解决。 图片问题是由于我截图后直接上传而没有保存或者转换成web格式，导致图片比较大，加载自然会占时间。 还有，首页是跟着文章的更新而出现更新，因此响应速度慢也就没什么了。</p>\n",
            "tags": [
                "seo",
                "优化"
            ]
        },
        {
            "id": "https://erik.xyz/2014/10/24/wordpress-zhong-seo-you-hua-jian-yi/",
            "url": "https://erik.xyz/2014/10/24/wordpress-zhong-seo-you-hua-jian-yi/",
            "title": "wordpress中seo优化建议",
            "date_published": "2014-10-24T04:06:00.000Z",
            "content_html": "<p><a href=\"http://www.erik.xyz/seo_wpss\"><img src=\"http://img03.taobaocdn.com/imgextra/i1/809419769/TB2UVibaVXXXXbHXXXXXXXXXXXX_!!809419769.jpg\" alt=\"艾瑞可erik\"></a> 最近一直在弄网站优化这块，百度统计测试网站响应速度已100%跑满，只剩百度站长页面优化跑到92分卡住了。我对那些不愿意花时间来做优化的同行想说句“加油哦，我已经做到了”。大家遇到问题百度一下会发现好多贴吧或者博客说你没必要去管百度统计里面的优化，什么合并域名啊，合并js、css的都不行、没必要、影响不大。如果确实影响不大，百度难道自己有问题，故意个给你测评误导你。<span id=\"more\"></span> <a href=\"http://img03.taobaocdn.com/imgextra/i3/809419769/TB210F4aVXXXXa1XXXXXXXXXXXX_!!809419769.jpg\"><img src=\"http://img03.taobaocdn.com/imgextra/i3/809419769/TB210F4aVXXXXa1XXXXXXXXXXXX_!!809419769.jpg\" alt=\"艾瑞可erik\"></a> 说多了都是泪啊，百度统计网站响应测试，刚开始很让人头疼的。出现js、css要合并，外调的图片域名要合并，网站缓存响应时间要设置……问题多多啊 <a href=\"http://img03.taobaocdn.com/imgextra/i4/809419769/TB2eRx0aVXXXXXWXpXXXXXXXXXX_!!809419769.png\"><img src=\"http://img03.taobaocdn.com/imgextra/i4/809419769/TB2eRx0aVXXXXXWXpXXXXXXXXXX_!!809419769.png\" alt=\"木木夕\"></a> 既然有这么问题那就解决吧，干看着没用啊。先上百度找找，忙活了一阵子发现百度不靠谱，好多人都没弄。怎么办呢？ 先从合并css开始吧。百度统计提示的是你代码里面有多个css文件（我的是2个）,在后台外观-编辑-header.php文件里并没有这些css文件,查查资料才知道是&lt;?php  wp<em>head(); &gt;输出的。怎么办呢，反复想想有结果了。 我先去网站首页查看源文件 [![木木夕](<a href=\"http://img03.taobaocdn.com/imgextra/i4/809419769/TB2.V40aVXXXXXyXpXXXXXXXXXX\">http://img03.taobaocdn.com/imgextra/i4/809419769/TB2.V40aVXXXXXyXpXXXXXXXXXX</a></em>!!809419769.png)](<a href=\"http://img03.taobaocdn.com/imgextra/i4/809419769/TB2.V40aVXXXXXyXpXXXXXXXXXX_!!809419769.png\">http://img03.taobaocdn.com/imgextra/i4/809419769/TB2.V40aVXXXXXyXpXXXXXXXXXX_!!809419769.png</a>) 源文件把所有的代码都解析出来了这个好啊，我们回头把header.php文件中的&lt;?php  wp_head(); &gt;注释掉，根据上下代码寻找衔接，把源文件输出替换&lt;?php  wp_head(); &gt;的代码复制粘贴到header.php中相对应的位置。然后，就会找到对应要合并css文件，同时也找到对应要合并的js文件。我们先注释其中的一个，留另外一个做调用（script貌似注释不了，只能先粘贴复制到本地文件，以防出错好恢复。），更新文件header.php。用ftp链接服务器找到对应文件。例如，我这边是style.cc和960.css，jquery.js和jquery-migrate.min.js要合并，我先找到这写文件对应的地方，下载到本地先做备份（注意jquery所在的文件夹文件较多，看仔细些）。我把960.css里面的代码粘贴复制到style.css里面，同时，注释掉header.php文件的连接路径（注意960.css文件不要删掉，因为还有其他地方在调用）。同理也把js文件合并。最后清理一下网站缓存（如果你装了缓存插件就要清楚缓存），然后在清理一下浏览器缓存，然后用百度统计测评一下会发现响应速度加分了。 <a href=\"http://img03.taobaocdn.com/imgextra/i3/809419769/TB2LAx1aVXXXXcFXXXXXXXXXXXX_!!809419769.png\"><img src=\"http://img03.taobaocdn.com/imgextra/i3/809419769/TB2LAx1aVXXXXcFXXXXXXXXXXXX_!!809419769.png\" alt=\"木木夕\"></a> <a href=\"http://img03.taobaocdn.com/imgextra/i2/809419769/TB2bEV0aVXXXXXEXpXXXXXXXXXX_!!809419769.png\"><img src=\"http://img03.taobaocdn.com/imgextra/i2/809419769/TB2bEV0aVXXXXXEXpXXXXXXXXXX_!!809419769.png\" alt=\"木木夕\"></a> 接下来还没完，因为还有域名要合并。在百度上搜到的答案是说域名是没办法合并的，都是外调别人的。有的还说你得有顶级域名才能合并，反正我对这些人无语了。 <a href=\"http://img03.taobaocdn.com/imgextra/i4/809419769/TB2daR5aVXXXXa9XXXXXXXXXXXX_!!809419769.png\"><img src=\"http://img03.taobaocdn.com/imgextra/i4/809419769/TB2daR5aVXXXXa9XXXXXXXXXXXX_!!809419769.png\" alt=\"木木夕\"></a> 外调图片是没办法的，空间不大，图片占得容量太大了，只有外调。笔者在建站时一直考虑这个问题，后来解决了。因为有做过淘宝，便有个淘宝图片空间，可以调外链。百度统计提示域名合并就是img03.taobaocdn.com和img04.taobaocdn.com就前面的不一样，把前面的改成一样的试试，结果还真有效果，不影响图片输出。合并域名就这样解决了，同理我调用360的友情链接和安全检测验证也是用这样的方法，刷新缓存重新测试，就没有要合并域名的情况了。 <a href=\"http://img03.taobaocdn.com/imgextra/i2/809419769/TB2UIh1aVXXXXcVXXXXXXXXXXXX_!!809419769.jpg\"><img src=\"http://img03.taobaocdn.com/imgextra/i2/809419769/TB2UIh1aVXXXXcVXXXXXXXXXXXX_!!809419769.jpg\" alt=\"木木夕\"></a> 笔者在这是想说有些事真的是你自己去尝试了才知道有更好的办法解决，刚开始虽然是百度，但是你自己试试就知道结果会是怎么样的。</p>\n",
            "tags": [
                "seo",
                "优化",
                "域名合并"
            ]
        }
    ]
}