{
    "version": "https://jsonfeed.org/version/1",
    "title": "艾瑞可erik • All posts by \"spl手册\" tag • All posts by \"undefined\" categories",
    "description": "一只PHP开发的程序猿，偶尔做做运维、Goland、Python、Java、摄影、画画、写作、顺便睡觉，反正整站都搞过。",
    "home_page_url": "https://erik.xyz",
    "items": [
        {
            "id": "https://erik.xyz/2020/04/27/php-spl-info/",
            "url": "https://erik.xyz/2020/04/27/php-spl-info/",
            "title": "php的spl详解",
            "date_published": "2020-04-27T00:56:00.000Z",
            "content_html": "<ul>\n<li><h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><ul>\n<li>SplDoublyLinkedList （双向链表）<pre><code>SplDoublyLinkedList::add —在指定的索引处添加/插入新值\nSplDoublyLinkedList::bottom —从双向链表的开头偷看节点\nSplDoublyLinkedList::__ construct —构造一个新的双向链表\nSplDoublyLinkedList::count —计算双向链接列表中的元素数\nSplDoublyLinkedList::current —返回当前数组条目\nSplDoublyLinkedList::getIteratorMode —返回迭代模式\nSplDoublyLinkedList::isEmpty —检查双向链接列表是否为空\nSplDoublyLinkedList::key —返回当前节点索引\nSplDoublyLinkedList::next —移至下一个条目\nSplDoublyLinkedList::offsetExists —返回所请求的$ index是否存在\nSplDoublyLinkedList::offsetGet —返回指定的$ index处的值\nSplDoublyLinkedList::offsetSet —将指定的$ index处的值设置为$ newval\nSplDoublyLinkedList::offsetUnset —取消指定$ index处的值\nSplDoublyLinkedList::pop —从双向链接列表的末尾弹出一个节点\nSplDoublyLinkedList::prev —移至上一个条目\nSplDoublyLinkedList::push —将元素推入双向链接列表的末尾\nSplDoublyLinkedList::rewind —将迭代器倒回开始\nSplDoublyLinkedList::serialize —序列化存储\nSplDoublyLinkedList::setIteratorMode —设置迭代模式\nSplDoublyLinkedList::shift —从双链表的开头移出一个节点\nSplDoublyLinkedList::top —从双向链表末尾窥视节点\nSplDoublyLinkedList::unserialize —反序列化​​存储\nSplDoublyLinkedList::unshift —为双向链接列表添加一个元素\nSplDoublyLinkedList::valid —检查双向链表是否包含更多节点\n</code></pre><span id=\"more\"></span>        </li>\n<li><p>SplStack （栈）</p>\n<pre><code>  SplStack::__ construct —构造一个使用双链表实现的新堆栈\n  SplStack::setIteratorMode —设置迭代模式\n</code></pre></li>\n<li><p>SplQueue    （队列)</p>\n<pre><code>  SplQueue::__ construct —构造一个使用双链表实现的新队列\n  SplQueue::dequeue —使节点从队列中退出\n  SplQueue::enqueue —将元素添加到队列\n  SplQueue::setIteratorMode —设置迭代模式\n</code></pre></li>\n<li><p>SplHeap    (堆)</p>\n<pre><code>  SplHeap::compare —比较元素以便在筛选时将它们正确放置在堆中\n  SplHeap::__ construct —构造一个新的空堆\n  SplHeap::count —计算堆中元素的数量\n  SplHeap::current —返回迭代器指向的当前节点\n  SplHeap::extract —从堆的顶部提取一个节点并进行筛选\n  SplHeap::insert —通过筛选将元素插入堆中\n  SplHeap::isCorrupted —告诉堆是否处于损坏状态\n  SplHeap::isEmpty —检查堆是否为空\n  SplHeap::key —返回当前节点索引\n  SplHeap::next —移至下一个节点\n  SplHeap::recoverFromCorruption —从损坏的状态中恢复并允许对堆进行进一步的操作\n  SplHeap::rewind —将迭代器倒回开始（无操作）\n  SplHeap::top —窥视堆顶部的节点\n  SplHeap::valid —检查堆是否包含更多节点\n</code></pre></li>\n<li><p>SplMaxHeap (最大堆)</p>\n<pre><code>  SplMaxHeap::compare —比较元素以便在筛选时将它们正确放置在堆中\n</code></pre></li>\n<li><p>SplMinHeap (最小堆)</p>\n<pre><code>  SplMinHeap::compare —比较元素以便在筛选时将其正确放置在堆中\n</code></pre></li>\n<li><p>SplPriorityQueue    (优先级队列)</p>\n<pre><code>  SplPriorityQueue::比较—比较优先级以便在筛选时将元素正确放置在堆中\n  SplPriorityQueue::__construct —构造一个新的空队列\n  SplPriorityQueue::count —计算队列中的元素数\n  SplPriorityQueue::current —返回迭代器指向的当前节点\n  SplPriorityQueue::extract —从堆顶部提取一个节点并进行筛选\n  SplPriorityQueue::getExtractFlags —获取提取标志\n  SplPriorityQueue::insert —通过筛选将元素插入队列\n  SplPriorityQueue::isCorrupted —告诉优先级队列是否处于损坏状态\n  SplPriorityQueue::isEmpty —检查队列是否为空\n  SplPriorityQueue::key —返回当前节点索引\n  SplPriorityQueue::next —移动到下一个节点\n  SplPriorityQueue::recoverFromCorruption —从损坏的状态中恢复并允许对队列进行进一步的操作\n  SplPriorityQueue::rewind —将迭代器后退到开始（无操作）\n  SplPriorityQueue::setExtractFlags —设置提取模式\n  SplPriorityQueue::top —从队列顶部窥视节点\n  SplPriorityQueue::valid —检查队列是否包含更多节点\n</code></pre></li>\n<li><p>SplFixedArray     (处理数组相关的主要功能)</p>\n<pre><code>  SplFixedArray::__ construct —构造一个新的固定数组\n  SplFixedArray::count —返回数组的大小\n  SplFixedArray::current —返回当前数组条目\n  SplFixedArray::fromArray —在SplFixedArray实例中导入PHP数组\n  SplFixedArray::getSize —获取数组的大小\n  SplFixedArray::key —返回当前数组索引\n  SplFixedArray::next —移至下一个条目\n  SplFixedArray::offsetExists —返回所请求的索引是否存在\n  SplFixedArray::offsetGet —返回指定索引处的值\n  SplFixedArray::offsetSet —在指定的索引处设置一个新值\n  SplFixedArray::offsetUnset —取消设置指定$ index处的值\n  SplFixedArray::rewind —将迭代器倒回开始\n  SplFixedArray::setSize —更改数组的大小\n  SplFixedArray::toArray —从固定数组返回一个PHP数组\n  SplFixedArray::valid —检查数组是否包含更多元素\n  SplFixedArray::__ wakeup —在反序列化之后重新初始化数组\n</code></pre></li>\n<li><p>SplObjectStorage  (数据结构对象容器)</p>\n<pre><code>  SplObjectStorage::addAll —从另一个存储添加所有对象\n  SplObjectStorage::attach —在存储中添加一个对象\n  SplObjectStorage::contains —检查存储是否包含特定对象\n  SplObjectStorage::count —返回存储中的对象数\n  SplObjectStorage::current —返回当前的存储条目\n  SplObjectStorage::detach —从存储中删除对象\n  SplObjectStorage::getHash —计算所包含对象的唯一标识符\n  SplObjectStorage::getInfo —返回与当前迭代器条目关联的数据\n  SplObjectStorage::key —返回当前迭代器所在的索引\n  SplObjectStorage::next —移至下一个条目\n  SplObjectStorage::offsetExists —检查存储中是否存在对象\n  SplObjectStorage::offsetGet —返回与对象关联的数据\n  SplObjectStorage::offsetSet-将数据关联到存储中的对象\n  SplObjectStorage::offsetUnset —从存储中删除一个对象\n  SplObjectStorage::removeAll —从当前存储中删除另一个存储中包含的对象\n  SplObjectStorage::removeAllExcept-从当前存储中删除除另一个存储中包含的对象以外的所有对象\n  SplObjectStorage::rewind —将迭代器后退到第一个存储元素\n  SplObjectStorage::serialize —序列化存储\n  SplObjectStorage::setInfo —设置与当前迭代器条目关联的数据\n  SplObjectStorage::unserialize —从其字符串表示形式反序列化存储\n  SplObjectStorage::Valid —返回当前迭代器条目是否有效\n</code></pre></li>\n</ul>\n</li>\n<li><h2 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h2><ul>\n<li><p>AppendIterator    (陆续遍历几个迭代器)</p>\n<pre><code>  AppendIterator::append —附加一个迭代器\n  AppendIterator::__ construct —构造一个AppendIterator\n  AppendIterator::current —获取当前值\n  AppendIterator::getArrayIterator —获取ArrayIterator\n  AppendIterator::getInnerIterator —获取内部迭代器\n  AppendIterator::getIteratorIndex —获取迭代器的索引\n  AppendIterator::key —获取当前密钥\n  AppendIterator::next-移至下一个元素\n  AppendIterator::rewind —倒退Iterator\n  AppendIterator::valid —检查当前元素的有效性\n</code></pre></li>\n<li><p>ArrayIterator    (允许在遍历数组和对象时删除和更新值与键)</p>\n<pre><code>  ArrayIterator::append —追加元素\n  ArrayIterator::asort —按值对数组排序\n  ArrayIterator::__ construct —构造一个ArrayIterator\n  ArrayIterator::count —计数元素\n  ArrayIterator::current —返回当前数组条目\n  ArrayIterator::getArrayCopy —获取数组副本\n  ArrayIterator::getFlags —获取行为标志\n  ArrayIterator::key —返回当前的数组键\n  ArrayIterator::ksort —按键对数组排序\n  ArrayIterator::natcasesort —自然地对数组排序，不区分大小写\n  ArrayIterator::natsort —自然地对数组排序\n  ArrayIterator::next —移至下一个条目\n  ArrayIterator::offsetExists —检查偏移量是否存在\n  ArrayIterator::offsetGet —获取偏移量的值\n  ArrayIterator::offsetSet —设置偏移量的值\n  ArrayIterator::offsetUnset —偏移量的未设置值\n  ArrayIterator::rewind —将数组倒回开始\n  ArrayIterator::seek —寻求位置\n  ArrayIterator::serialize —序列化\n  ArrayIterator::setFlags —设置行为标志\n  ArrayIterator::uasort —使用用户定义的比较函数排序并维护索引关联\n  ArrayIterator::uksort —使用用户定义的比较功能按键排序\n  ArrayIterator::unserialize —反序列化\n  ArrayIterator::valid —检查数组是否包含更多条目\n</code></pre></li>\n<li><p>CachingIterator    (缓存迭代)</p>\n<pre><code>  CachingIterator::__ construct —为迭代器构造一个新的CachingIterator对象\n  CachingIterator::count —迭代器中的元素数\n  CachingIterator::current —返回当前元素\n  CachingIterator::getCache —检索缓存的内容\n  CachingIterator::getFlags —获取使用的标志\n  CachingIterator::getInnerIterator —返回内部迭代器\n  CachingIterator::hasNext —检查内部迭代器是否具有有效的next元素\n  CachingIterator::key —返回当前元素的密钥\n  CachingIterator::next —向前移动迭代器\n  CachingIterator::offsetExists — offsetExists目的\n  CachingIterator::offsetGet — offsetGet目的\n  CachingIterator::offsetSet — offsetSet的目的\n  CachingIterator::offsetUnset — offsetUnset用途\n  CachingIterator::rewind —倒退迭代器\n  CachingIterator::setFlags — setFlags的目的\n  CachingIterator::__ toString —返回当前元素的字符串表示形式\n  CachingIterator::valid —检查当前元素是否有效\n</code></pre></li>\n<li><p>CallbackFilterIterator    (迭代回调)</p>\n<pre><code>  CallbackFilterIterator::accept —以当前值，当前键和内部迭代器作为参数调用回调\n  CallbackFilterIterator::__ construct —从另一个迭代器创建一个过滤的迭代器\n</code></pre></li>\n<li><p>DirectoryIterator    (查看文件系统目录内容)</p>\n<pre><code>  DirectoryIterator::__ construct —从路径构造一个新的目录迭代器\n  DirectoryIterator::current —返回当前的DirectoryIterator项\n  DirectoryIterator::getATime —获取当前DirectoryIterator项的上次访问时间\n  DirectoryIterator::getBasename —获取当前DirectoryIterator项的基本名称\n  DirectoryIterator::getCTime —获取当前DirectoryIterator项的inode更改时间\n  DirectoryIterator::getExtension —获取文件扩展名\n  DirectoryIterator::getFilename —返回当前DirectoryIterator项的文件名\n  DirectoryIterator::getGroup —获取当前DirectoryIterator项的组\n  DirectoryIterator::getInode —获取当前DirectoryIterator项的inode\n  DirectoryIterator::getMTim​​e —获取当前DirectoryIterator项的最后修改时间\n  DirectoryIterator::getOwner —获取当前DirectoryIterator项的所有者\n  DirectoryIterator::getPath —获取没有文件名的当前Iterator项的路径\n  DirectoryIterator::getPathname —当前DirectoryIterator项的返回路径和文件名\n  DirectoryIterator::getPerms —获取当前DirectoryIterator项的权限\n  DirectoryIterator::getSize —获取当前DirectoryIterator项的大小\n  DirectoryIterator::getType —确定当前DirectoryIterator项的类型\n  DirectoryIterator::isDir —确定当前DirectoryIterator项是否为目录\n  DirectoryIterator::isDot —确定当前DirectoryIterator项是否为&#39;。要么 &#39;..&#39;\n  DirectoryIterator::isExecutable —确定当前DirectoryIterator项是否可执行\n  DirectoryIterator::isFile —确定当前DirectoryIterator项是否为常规文件\n  DirectoryIterator::isLink —确定当前DirectoryIterator项是否是符号链接\n  DirectoryIterator::isReadable —确定是否可以读取当前的DirectoryIterator项\n  DirectoryIterator::isWritable —确定是否可以将当前DirectoryIterator项写入\n  DirectoryIterator::key —返回当前DirectoryIterator项的密钥\n  DirectoryIterator::next-前进到下一个DirectoryIterator项\n  DirectoryIterator::rewind —将DirectoryIterator倒回开始\n  DirectoryIterator::seek —寻求DirectoryIterator项\n  DirectoryIterator::__ toString —以字符串形式获取文件名\n  DirectoryIterator::valid —检查当前DirectoryIterator位置是否为有效文件\n</code></pre></li>\n<li><p>EmptyIterator    (空迭代器)</p>\n<pre><code>  EmptyIterator::current — current()方法\n  EmptyIterator::key — key()方法\n  EmptyIterator::next — next()方法\n  EmptyIterator::rewind — rewind()方法\n  EmptyIterator::valid —valid(）方法\n</code></pre></li>\n<li><p>FilesystemIterator    (文件系统迭代器)</p>\n<pre><code>  FilesystemIterator::__ construct —构造一个新的文件系统迭代器\n  FilesystemIterator::current —当前文件\n  FilesystemIterator::getFlags —获取处理标志\n  FilesystemIterator::key —检索当前文件的密钥\n  FilesystemIterator::next-移至下一个文件\n  FilesystemIterator::rewind —回溯到开头\n  FilesystemIterator::setFlags —设置处理标志\n</code></pre></li>\n<li><p>FilterIterator    ()</p>\n<pre><code>  FilterIterator::accept —检查迭代器的当前元素是否可接受\n  FilterIterator::__ construct —构造一个filterIterator\n  FilterIterator::current —获取当前元素值\n  FilterIterator::getInnerIterator —获取内部迭代器\n  FilterIterator::key —获取当前密钥\n  FilterIterator::next —向前移动迭代器\n  FilterIterator::rewind —倒退迭代器\n  FilterIterator::valid —检查当前元素是否有效\n</code></pre></li>\n<li><p>GlobIterator    (遍历一个文件系统行为)</p>\n<pre><code>  GlobIterator::__ construct —使用glob构造目录\n  GlobIterator::count —获取目录和文件的数量\n</code></pre></li>\n<li><p>InfiniteIterator    (无限迭代)</p>\n<pre><code>  InfiniteIterator::__ construct —构造一个InfiniteIterator\n  InfiniteIterator::next-将内部Iterator向前或向后移动\n</code></pre></li>\n<li><p>IteratorIterator    (将可遍历的任何内容转换为迭代器)</p>\n<pre><code>  IteratorIterator::__ construct —从任何可遍历的东西创建一个迭代器\n  IteratorIterator::current —获取当前值\n  IteratorIterator::getInnerIterator —获取内部迭代器\n  IteratorIterator::key —获取当前元素的键\n  IteratorIterator::next —转发到下一个元素\n  IteratorIterator::rewind —倒退到第一个元素\n  IteratorIterator::valid —检查迭代器是否有效\n</code></pre></li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>LimitIterator    (遍历一个 Iterator 的限定子集的元素)</p>\n<pre><code>  LimitIterator::__ construct —构造一个LimitIterator\n  LimitIterator::current —获取当前元素\n  LimitIterator::getInnerIterator —获取内部迭代器\n  LimitIterator::getPosition —返回当前位置\n  LimitIterator::key —获取当前键\n  LimitIterator::next —向前移动迭代器\n  LimitIterator::rewind —将迭代器后退到指定的起始偏移量\n  LimitIterator::seek —寻求给定位置\n  LimitIterator::valid —检查当前元素是否有效\n</code></pre></li>\n<li><p>MultipleIterator    (依次迭代所有附加迭代器的迭代器)</p>\n<pre><code>  MultipleIterator::attachIterator —附加迭代器信息\n  MultipleIterator::__ construct —构造一个新的MultipleIterator\n  MultipleIterator::containsIterator —检查是否附加了迭代器\n  MultipleIterator::countIterators —获取附加的迭代器实例的数量\n  MultipleIterator::current —获取注册的迭代器实例\n  MultipleIterator::detachIterator —分离迭代器\n  MultipleIterator::getFlags —获取标志信息\n  MultipleIterator::key —获取注册的迭代器实例\n  MultipleIterator::next-将所有附加的迭代器实例向前移动\n  MultipleIterator::rewind —倒退所有附加的迭代器实例\n  MultipleIterator::setFlags —设置标志\n  MultipleIterator::valid —检查子迭代器的有效性\n</code></pre></li>\n<li><p>NoRewindIterator    (多个局部foreach循环中处理迭代器)</p>\n<pre><code>  NoRewindIterator::__ construct —构造一个NoRewindIterator\n  NoRewindIterator::current —获取当前值\n  NoRewindIterator::getInnerIterator —获取内部迭代器\n  NoRewindIterator::key —获取当前密钥\n  NoRewindIterator::next —转发到下一个元素\n  NoRewindIterator::rewind —防止在内部迭代器上进行倒带操作\n  NoRewindIterator::valid —验证迭代器\n</code></pre></li>\n<li><p>ParentIterator    (使用RecursiveIteratorIterator进行递归迭代)</p>\n<pre><code>  ParentIterator::accept —确定可接受性\n  ParentIterator::__ construct —构造一个ParentIterator\n  ParentIterator::getChildren —返回ParentIterator中包含的内部迭代器的子代\n  ParentIterator::hasChildren —检查内部迭代器的当前元素是否有子代\n  ParentIterator::next-向前移动迭代器\n  ParentIterator::rewind —倒退迭代器\n</code></pre></li>\n<li><p>RecursiveArrayIterator    (遍历Array和Object时取消设置和修改值和键)</p>\n<pre><code>  RecursiveArrayIterator::getChildren —返回当前项的迭代器（如果它是数组或对象）\n  RecursiveArrayIterator::hasChildren —返回当前条目是数组还是对象\n</code></pre></li>\n<li><p>RecursiveCachingIterator    ()</p>\n<pre><code>  RecursiveCachingIterator::__ construct —构造\n  RecursiveCachingIterator::getChildren —将内部迭代器的子级作为RecursiveCachingIterator返回\n  RecursiveCachingIterator::hasChildren —检查内部迭代器的当前元素是否有子代\n</code></pre></li>\n<li><p>RecursiveCallbackFilterIterator    ()</p>\n<pre><code>  RecursiveCallbackFilterIterator::__ construct —从RecursiveIterator创建一个RecursiveCallbackFilterIterator\n  RecursiveCallbackFilterIterator::getChildren —返回包含在RecursiveCallbackFilterIterator中的内部迭代器的子级\n  RecursiveCallbackFilterIterator::hasChildren —检查内部迭代器的当前元素是否有子代\n</code></pre></li>\n<li><p>RecursiveDirectoryIterator    (在文件系统目录上进行递归迭代的接口)</p>\n<pre><code>  RecursiveDirectoryIterator::__ construct —构造一个RecursiveDirectoryIterator\n  RecursiveDirectoryIterator::getChildren —返回当前条目的迭代器（如果它是目录）\n  RecursiveDirectoryIterator::getSubPath —获取子路径\n  RecursiveDirectoryIterator::getSubPathname —获取子路径和名称\n  RecursiveDirectoryIterator::hasChildren —返回当前条目是否是目录，而不是&#39;。 要么 &#39;..&#39;\n  RecursiveDirectoryIterator::key —当前目录条目的返回路径和文件名\n  RecursiveDirectoryIterator::next —移至下一个条目\n  RecursiveDirectoryIterator::rewind —将目录倒回开始\n</code></pre></li>\n<li><p>RecursiveFilterIterator    (自定义过滤器/必须在子类中实现)</p>\n<pre><code>  RecursiveFilterIterator::__ construct —从RecursiveIterator创建一个RecursiveFilterIterator\n  RecursiveFilterIterator::getChildren —返回RecursiveFilterIterator中包含的内部迭代器的子代\n  RecursiveFilterIterator::hasChildren —检查内部迭代器的当前元素是否有子代\n</code></pre></li>\n<li><p>RecursiveIteratorIterator    (通过递归迭代器进行迭代)</p>\n<pre><code>  RecursiveIteratorIterator::beginChildren —开始子级\n  RecursiveIteratorIterator::beginIteration —开始迭代\n  RecursiveIteratorIterator::callGetChildren —获取孩子\n  RecursiveIteratorIterator::callHasChildren —有孩子\n  RecursiveIteratorIterator::__ construct —构造一个RecursiveIteratorIterator\n  RecursiveIteratorIterator::current —访问当前元素值\n  RecursiveIteratorIterator::endChildren —结束子级\n  RecursiveIteratorIterator::endIteration —结束迭代\n  RecursiveIteratorIterator::getDepth —获取递归迭代的当前深度\n  RecursiveIteratorIterator::getInnerIterator —获取内部迭代器\n  RecursiveIteratorIterator::getMaxDepth —获取最大深度\n  RecursiveIteratorIterator::getSubIterator —当前的活动子迭代器\n  RecursiveIteratorIterator::key —访问当前密钥\n  RecursiveIteratorIterator::next —移至下一个元素\n  RecursiveIteratorIterator::nextElement —下一个元素\n  RecursiveIteratorIterator::rewind —将迭代器后退到顶级内部迭代器的第一个元素\n  RecursiveIteratorIterator::setMaxDepth —设置最大深度\n  RecursiveIteratorIterator::valid —检查当前位置是否有效\n</code></pre></li>\n<li><p>RecursiveRegexIterator    (通过正则表达式过滤另一个递归迭代器)</p>\n<pre><code>  RecursiveRegexIterator::__ construct —创建一个新的RecursiveRegexIterator\n  RecursiveRegexIterator::getChildren —返回当前条目的迭代器\n  RecursiveRegexIterator::hasChildren —返回是否可以为当前条目获取迭代器\n</code></pre></li>\n<li><p>RecursiveTreeIterator    (允许在RecursiveIterator上进行迭代以生成ASCII图形树)</p>\n<pre><code>  RecursiveTreeIterator::beginChildren —开始子级\n  RecursiveTreeIterator::beginIteration —开始迭代\n  RecursiveTreeIterator::callGetChildren —获取孩子\n  RecursiveTreeIterator::callHasChildren —有孩子\n  RecursiveTreeIterator::__ construct —构造一个RecursiveTreeIterator\n  RecursiveTreeIterator::current —获取当前元素\n  RecursiveTreeIterator::endChildren —结束子级\n  RecursiveTreeIterator::endIteration —结束迭代\n  RecursiveTreeIterator::getEntry —获取当前条目\n  RecursiveTreeIterator::getPostfix —获取后缀\n  RecursiveTreeIterator::getPrefix —获取前缀\n  RecursiveTreeIterator::key —获取当前元素的键\n  RecursiveTreeIterator::next —移至下一个元素\n  RecursiveTreeIterator::nextElement —下一个元素\n  RecursiveTreeIterator::rewind —倒退迭代器\n  RecursiveTreeIterator::setPostfix —设置后缀\n  RecursiveTreeIterator::setPrefixPart —设置前缀的一部分\n  RecursiveTreeIterator::valid —检查有效性\n</code></pre></li>\n<li><p>RegexIterator    (基于正则表达式过滤另一个迭代器)</p>\n<pre><code>  RegexIterator::accept —获取接受状态\n  RegexIterator::__ construct —创建一个新的RegexIterator\n  RegexIterator::getFlags —获取标志\n  RegexIterator::getMode —返回操作模式\n  RegexIterator::getPregFlags —返回正则表达式标志\n  RegexIterator::getRegex —返回当前的正则表达式\n  RegexIterator::setFlags —设置标志\n  RegexIterator::setMode-设置操作模式\n  RegexIterator::setPregFlags —设置正则表达式标志\n</code></pre></li>\n</ul>\n<ul>\n<li><h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><ul>\n<li><p>Countable (验证变量的内容是可计数的值)</p>\n<pre><code>  Countable::count — 统计一个对象的元素个数\n</code></pre></li>\n<li><p>OuterIterator (迭代迭代器)</p>\n<pre><code>  OuterIterator::getInnerIterator —返回当前条目的内部迭代器\n</code></pre></li>\n<li><p>RecursiveIterator (递归迭代迭代器)</p>\n<pre><code>RecursiveIterator::getChildren —返回当前条目的迭代器\nRecursiveIterator::hasChildren —返回是否可以为当前条目创建迭代器\n</code></pre></li>\n<li><p>SeekableIterator ()</p>\n</li>\n</ul>\n</li>\n<li><h2 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h2><ul>\n<li>BadFunctionCallException (如果回调引用未定义的函数或缺少某些参数，则抛出异常)</li>\n<li>BadMethodCallException (当一个回调方法是一个未定义的方法或缺失一些参数时会抛出该异常)</li>\n<li>DomainException (如果值不遵循定义的有效数据域，则抛出异常)</li>\n<li>InvalidArgumentException (如果参数不是期望的类型，则抛出异常)</li>\n<li>LengthException (如果长度无效，则抛出异常)</li>\n<li>LogicException (表示程序逻辑错误的异常。 这种异常应直接导致代码中的修复)</li>\n<li>OutOfBoundsException (如果值不是有效键，则抛出异常。 这表示在编译时无法检测到的错误)</li>\n<li>OutOfRangeException (请求非法索引时引发异常)</li>\n<li>OverflowException (将元素添加到完整容器中时引发异常)</li>\n<li>RangeException (引发异常以指示程序执行期间的范围错误。通常，这意味着除下溢/上溢外还存在算术错误。)</li>\n<li>RuntimeException (如果发生仅在运行时才能发现的错误，则引发异常。)</li>\n<li>UnderflowException (对空容器执行无效操作（例如删除元素）时引发的异常。)</li>\n<li>UnexpectedValueException (如果一个值与一组值不匹配，则抛出异常。通常，当一个函数调用另一个函数并期望返回值是某种类型或不包括与算术或缓冲区相关的错误的值时，就会发生这种情况。)</li>\n</ul>\n</li>\n<li><h2 id=\"SPL函数\"><a href=\"#SPL函数\" class=\"headerlink\" title=\"SPL函数\"></a>SPL函数</h2><ul>\n<li><a href=\"https://www.php.net/manual/zh/function.class-implements.php\">class_implements</a> — 返回指定的类实现的所有接口。</li>\n<li><a href=\"https://www.php.net/manual/zh/function.class-parents.php\">class_parents</a> — 返回指定类的父类。</li>\n<li><a href=\"https://www.php.net/manual/zh/function.class-uses.php\">class_uses</a> — 返回给定类使用的类型</li>\n<li><a href=\"https://www.php.net/manual/zh/function.iterator-apply.php\">iterator_apply</a> — 为迭代器中每个元素调用一个用户自定义函数</li>\n<li><a href=\"https://www.php.net/manual/zh/function.iterator-count.php\">iterator_count</a> — 计算迭代器中元素的个数</li>\n<li><a href=\"https://www.php.net/manual/zh/function.iterator-to-array.php\">iterator_to_array</a> — 将迭代器中的元素拷贝到数组</li>\n<li><a href=\"https://www.php.net/manual/zh/function.spl-autoload-call.php\">spl_autoload_call</a> — 尝试调用所有已注册的__autoload()函数来装载请求类</li>\n<li><a href=\"https://www.php.net/manual/zh/function.spl-autoload-extensions.php\">spl_autoload_extensions</a> — 注册并返回spl_autoload函数使用的默认文件扩展名。</li>\n<li><a href=\"https://www.php.net/manual/zh/function.spl-autoload-functions.php\">spl_autoload_functions</a> — 返回所有已注册的__autoload()函数。</li>\n<li><a href=\"https://www.php.net/manual/zh/function.spl-autoload-register.php\">spl_autoload_register</a> — 注册给定的函数作为 __autoload 的实现</li>\n<li><a href=\"https://www.php.net/manual/zh/function.spl-autoload-unregister.php\">spl_autoload_unregister</a> — 注销已注册的__autoload()函数</li>\n<li><a href=\"https://www.php.net/manual/zh/function.spl-autoload.php\">spl_autoload</a> — __autoload()函数的默认实现</li>\n<li><a href=\"https://www.php.net/manual/zh/function.spl-classes.php\">spl_classes</a> — 返回所有可用的SPL类</li>\n<li><a href=\"https://www.php.net/manual/zh/function.spl-object-hash.php\">spl_object_hash</a> — 返回指定对象的hash id</li>\n<li><a href=\"https://www.php.net/manual/zh/function.spl-object-id.php\">spl_object_id</a> — 返回给定对象的整数对象句柄</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><h2 id=\"文件处理\"><a href=\"#文件处理\" class=\"headerlink\" title=\"文件处理\"></a>文件处理</h2><ul>\n<li><p>SplFileInfo (单个文件的信息提供了一个高级的面向对象的接口)</p>\n<ul>\n<li>SplFileInfo::__ construct —构造一个新的SplFileInfo对象</li>\n<li>SplFileInfo::getATime —获取文件的最后访问时间</li>\n<li>SplFileInfo::getBasename —获取文件的基本名称</li>\n<li>SplFileInfo::getCTime —获取文件inode修改时间</li>\n<li>SplFileInfo::getExtension —获取文件扩展名</li>\n<li>SplFileInfo::getFileInfo —获取文件的SplFileInfo对象</li>\n<li>SplFileInfo::getFilename —获取文件名</li>\n<li>SplFileInfo::getGroup —获取文件组</li>\n<li>SplFileInfo::getInode —获取文件的索引节点</li>\n<li>SplFileInfo::getLinkTarget —获取链接的目标</li>\n<li>SplFileInfo::getMTim​​e —获取上次修改时间</li>\n<li>SplFileInfo::getOwner —获取文件的所有者</li>\n<li>SplFileInfo::getPath —获取不带文件名的路径</li>\n<li>SplFileInfo::getPathInfo —获取路径的SplFileInfo对象</li>\n<li>SplFileInfo::getPathname —获取文件的路径</li>\n<li>SplFileInfo::getPerms —获取文件权限</li>\n<li>SplFileInfo::getRealPath —获取文件的绝对路径</li>\n<li>SplFileInfo::getSize —获取文件大小</li>\n<li>SplFileInfo::getType —获取文件类型</li>\n<li>SplFileInfo::isDir —判断文件是否为目录</li>\n<li>SplFileInfo::isExecutable —告诉文件是否可执行</li>\n<li>SplFileInfo::isFile —告诉对象是否引用常规文件</li>\n<li>SplFileInfo::isLink —告诉文件是否是链接</li>\n<li>SplFileInfo::isReadable —告诉文件是否可读</li>\n<li>SplFileInfo::isWritable —告诉条目是否可写</li>\n<li>SplFileInfo::openFile —获取文件的SplFileObject对象</li>\n<li>SplFileInfo::setFileClass —设置与SplFileInfo::openFile一起使用的类</li>\n<li>SplFileInfo::setInfoClass —设置与SplFileInfo::getFileInfo和SplFileInfo::getPathInfo一起使用的类</li>\n<li>SplFileInfo::__ toString —以字符串形式返回文件的路径</li>\n</ul>\n</li>\n<li><p>SplFileObject (为文件提供了一个面向对象接口)</p>\n<ul>\n<li>SplFileObject::__construct —构造一个新的文件对象</li>\n<li>SplFileObject::current —检索文件的当前行</li>\n<li>SplFileObject::eof —文件结尾</li>\n<li>SplFileObject::fflush —将输出刷新到文件</li>\n<li>SplFileObject::fgetc —从文件中获取字符</li>\n<li>SplFileObject::fgetcsv —从文件中获取行并将其解析为CSV字段</li>\n<li>SplFileObject::fgets —从文件中获取行</li>\n<li>SplFileObject::fgetss —从文件和条带HTML标签获取行</li>\n<li>SplFileObject::flock —便携式文件锁定</li>\n<li>SplFileObject::fpassthru —在文件指针上输出所有剩余数据</li>\n<li>SplFileObject::fputcsv —将字段数组写为CSV行</li>\n<li>SplFileObject::fread —从文件读取</li>\n<li>SplFileObject::fscanf —根据格式分析文件中的输入</li>\n<li>SplFileObject::fseek —寻找位置</li>\n<li>SplFileObject::fstat —获取有关文件的信息</li>\n<li>SplFileObject::ftell —返回当前文件位置</li>\n<li>SplFileObject::ftruncate —将文件截断为给定的长度</li>\n<li>SplFileObject::fwrite-写入文件</li>\n<li>SplFileObject::getChildren —无目的</li>\n<li>SplFileObject::getCsvControl —获取CSV的分隔符，附件和转义符</li>\n<li>SplFileObject::getCurrentLine — SplFileObject::fgets的别名</li>\n<li>SplFileObject::getFlags —获取SplFileObject的标志</li>\n<li>SplFileObject::getMaxLineLen —获取最大行长</li>\n<li>SplFileObject::hasChildren — SplFileObject没有孩子</li>\n<li>SplFileObject::key —获取行号</li>\n<li>SplFileObject::next —阅读下一行</li>\n<li>SplFileObject::rewind —将文件倒退到第一行</li>\n<li>SplFileObject::seek —搜寻到指定的行</li>\n<li>SplFileObject::setCsvControl —设置CSV的分隔符，附件和转义符</li>\n<li>SplFileObject::setFlags —设置SplFileObject的标志</li>\n<li>SplFileObject::setMaxLineLen —设置最大行长</li>\n<li>SplFileObject::__ toString — SplFileObject::fgets的别名</li>\n<li>SplFileObject::valid —不在EOF</li>\n</ul>\n</li>\n<li><p>SplTempFileObject (为临时文件提供了一个面向对象的接口)</p>\n<ul>\n<li>SplTempFileObject::__ construct —构造一个新的临时文件对象</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><h2 id=\"各种类及接口\"><a href=\"#各种类及接口\" class=\"headerlink\" title=\"各种类及接口\"></a>各种类及接口</h2><ul>\n<li><p>ArrayObject (允许对象作为数组)</p>\n<ul>\n<li>ArrayObject::append —追加新的值作为最后一个元素。</li>\n<li>ArrayObject::asort —按值对条目进行排序</li>\n<li>ArrayObject::__ construct —构造一个新的数组对象</li>\n<li>ArrayObject::count —统计ArrayObject内公共属性的数量</li>\n<li>ArrayObject::exchangeArray —将阵列交换为另一个</li>\n<li>ArrayObject::getArrayCopy —创建ArrayObject的副本</li>\n<li>ArrayObject::getFlags —获取行为标志</li>\n<li>ArrayObject::getIterator —从ArrayObject实例创建一个新的迭代器</li>\n<li>ArrayObject::getIteratorClass —获取ArrayObject的迭代器类名</li>\n<li>ArrayObject::ksort —按键对条目进行排序</li>\n<li>ArrayObject::natcasesort —使用不区分大小写的“自然顺序”算法对数组进行排序</li>\n<li>ArrayObject::natsort —使用“自然顺序”算法对条目进行排序</li>\n<li>ArrayObject::offsetExists —返回所请求的索引是否存在</li>\n<li>ArrayObject::offsetGet —返回指定索引处的值</li>\n<li>ArrayObject::offsetSet —为指定索引设置新的值</li>\n<li>ArrayObject::offsetUnset —重置指定索引处的值</li>\n<li>ArrayObject::serialize —序列化ArrayObject</li>\n<li>ArrayObject::setFlags —设置行为标志</li>\n<li>ArrayObject::setIteratorClass —设置ArrayObject的迭代器类名</li>\n<li>ArrayObject::uasort —使用用户定义的比较函数对条目进行排序并维护键关联</li>\n<li>ArrayObject::uksort —使用用户定义的比较函数按键对条目进行排序</li>\n<li>ArrayObject::unserialize —反序列化​​ArrayObject</li>\n</ul>\n</li>\n<li><p>SplObserver (SplObserver接口与SplSubject一起使用以实现观察者设计模式)</p>\n<ul>\n<li>SplObserver::update —接收主题更新</li>\n</ul>\n</li>\n<li><p>SplSubject (SplSubject接口与SplObserver一起使用以实现观察者设计模式)</p>\n<ul>\n<li>SplSubject::attach —附加一个SplObserver</li>\n<li>SplSubject::detach —分离观察者</li>\n<li>SplSubject::notify —通知观察者</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "php",
                "php的SPL",
                "SPL手册"
            ]
        }
    ]
}