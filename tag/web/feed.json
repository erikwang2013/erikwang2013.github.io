{
    "version": "https://jsonfeed.org/version/1",
    "title": "艾瑞可erik • All posts by \"web\" tag • All posts by \"undefined\" categories",
    "description": "一只PHP开发的程序猿，偶尔做做运维、Goland、Python、Java、摄影、画画、写作、顺便睡觉，反正整站都搞过。",
    "home_page_url": "https://erik.xyz",
    "items": [
        {
            "id": "https://erik.xyz/2024/06/12/loading-zero-copy/",
            "url": "https://erik.xyz/2024/06/12/loading-zero-copy/",
            "title": "使用懒加载 + 零拷贝后，程序的秒开率提升至99.99%",
            "date_published": "2024-06-12T02:00:56.000Z",
            "content_html": "<h4 id=\"一、5秒钟加载一个页面的真相\"><a href=\"#一、5秒钟加载一个页面的真相\" class=\"headerlink\" title=\"一、5秒钟加载一个页面的真相\"></a>一、5秒钟加载一个页面的真相</h4><p>今天在修改前端页面的时候，发现程序中有一个页面的加载速度很慢，差不多需要5秒，这其实是难以接受的，我也不知道为什么上线这么长时间了，没人提过这个事儿。</p>\n<p>我记得有一个词儿，叫秒开率。<br><span id=\"more\"></span><br>秒开率是指能够在1秒内完成页面的加载。<br><img src=\"/img/2024/20240501.webp\" alt=\"erik.xyz\"></p>\n<p>查询的时候，会访问后台数据库，查询前20条数据，按道理来说，这应该很快才对。追踪代码，看看啥问题，最后发现问题有三：</p>\n<p>1.表中有一个BLOB大字段，存储着一个PDF模板，也就是上图中的运费模板；</p>\n<p>2.查询后会将这个PDF模板存储到本地磁盘点</p>\n<p>3.击线上显示，会读取本地的PDF模板，通过socket传到服务器。</p>\n<h5 id=\"大字段批量查询、批量文件落地、读取大文件并进行网络传输，不慢才怪，这一顿骚操作，5秒能加载完毕，已经烧高香了。\"><a href=\"#大字段批量查询、批量文件落地、读取大文件并进行网络传输，不慢才怪，这一顿骚操作，5秒能加载完毕，已经烧高香了。\" class=\"headerlink\" title=\"大字段批量查询、批量文件落地、读取大文件并进行网络传输，不慢才怪，这一顿骚操作，5秒能加载完毕，已经烧高香了。\"></a>大字段批量查询、批量文件落地、读取大文件并进行网络传输，不慢才怪，这一顿骚操作，5秒能加载完毕，已经烧高香了。</h5><p><img src=\"/img/2024/20240502.webp\" alt=\"erik.xyz\"></p>\n<h4 id=\"二、优化四步走\"><a href=\"#二、优化四步走\" class=\"headerlink\" title=\"二、优化四步走\"></a>二、优化四步走</h4><h5 id=\"1、“懒加载”\"><a href=\"#1、“懒加载”\" class=\"headerlink\" title=\"1、“懒加载”\"></a>1、“懒加载”</h5><p>经过调查发现，这个PDF模板只有在点击运费模板按钮时才会使用。</p>\n<ul>\n<li>优化1： 在点查询按钮时，不查询PDF模板；</li>\n<li>优化2： 点击运费模板时，根据uuid去查询，这样既能触发索引，也不用按时间排序，只是查询单条，速度快了很多很多，我愿称你为“懒加载”。</li>\n<li>优化3： 通过异步，将文件保存到磁盘中。</li>\n</ul>\n<p><img src=\"/img/2024/20240503.webp\" alt=\"erik.xyz\"></p>\n<p><strong>2、线上显示 = 就读取一个文件，为什么会慢呢？</strong></p>\n<p>打开代码一看，居然是通过FileReader读取的，我了个乖乖~这有什么问题吗？</p>\n<p>都是从百度拷贝过来的，百度还会有错吗？而且也测试了，没问题啊。</p>\n<p>嗯，对，是没问题，是可以实现需求，可是，为什么用这个？不知道。更别说效率问题了~</p>\n<p>优化4：通过缓冲流读取文件</p>\n<p><img src=\"/img/2024/20240504.webp\" alt=\"erik.xyz\"></p>\n<h4 id=\"三、先从上帝视角，了解一下啥子是IO流\"><a href=\"#三、先从上帝视角，了解一下啥子是IO流\" class=\"headerlink\" title=\"三、先从上帝视角，了解一下啥子是IO流\"></a>三、先从上帝视角，了解一下啥子是IO流</h4><p>Java I/O (Input/Output) 是对传统 I/O 操作的封装，它是以流的形式来操作数据的。</p>\n<p>1.InputStream代表一个输入流，它是一个抽象类，不能被实例化。InputStream定义了一些通用方法，如read()和skip()等，用于从输入流中读取数据；</p>\n<p>2.OutputStream代表一个输出流，它也是一个抽象类，不能被实例化。OutputStream定义了一些通用方法，如write()和flush()等，用于向输出流中写入数据；</p>\n<p>3.除了字节流，Java还提供字符流，字符流类似于字节流，不同之处在于字符流是按字符读写数据，而不是按字节。Java中最基本的字符流是Reader和Writer，它们是基于InputStream和OutputStream的转换类，用于完成字节流与字符流之间的转换。</p>\n<p>4.BufferedInputStream和BufferedOutputStream是I/O包中提供的缓冲输入输出流。它们可以提高I/O操作的效率，具有较好的缓存机制，能够减少磁盘操作，缩短文件传输时间。使用BufferedInputStream和 BufferedOutputStream进行读取和写入时，Java会自动调整缓冲区的大小，使其能够适应不同的数据传输速度。</p>\n<p>5.可以读取或写入 Java对象的流，比较典型的对象流包括ObjectInputStream 和ObjectOutputStream，将Java对象转换为字节流进行传输或存储；<br><img src=\"/img/2024/20240505.webp\" alt=\"erik.xyz\"></p>\n<p>在上一篇<a href=\"2024/05/06/index-asynchrony-landing/\">《增加索引+异步+不落地后，从12h优化到15min》</a>中，提到了4种优化方式，数据库优化、复用优化、并行优化、算法优化。</p>\n<p><strong>其中Buffered缓冲流就属于复用优化的一种，这个页面的查询完全可以通过复用优化优化一下。</strong></p>\n<h4 id=\"四、写个栗子，测试一下\"><a href=\"#四、写个栗子，测试一下\" class=\"headerlink\" title=\"四、写个栗子，测试一下\"></a>四、写个栗子，测试一下</h4><p><strong>1、通过字符输入流FileReader读取</strong></p>\n<p>FileReader连readLine()方法都没有，我也是醉了~</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static int readFileByReader(String filePath) &#123;</span><br><span class=\"line\">    int result = 0;</span><br><span class=\"line\">    try (Reader reader = new FileReader(filePath)) &#123;</span><br><span class=\"line\">        int value;</span><br><span class=\"line\">        while ((value = reader.read()) != -1) &#123;</span><br><span class=\"line\">            result += value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; catch (Exception e) &#123;</span><br><span class=\"line\">        System.out.println(&quot;readFileByReader异常：&quot; + e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>2、通过缓冲流BufferedReader读取</strong><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static String readFileByBuffer(String filePath) &#123;</span><br><span class=\"line\">    StringBuilder builder = new StringBuilder();</span><br><span class=\"line\">    try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) &#123;</span><br><span class=\"line\">        String data = null;</span><br><span class=\"line\">        while ((data = reader.readLine())!= null)&#123;</span><br><span class=\"line\">            builder.append(data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;catch (Exception e) &#123;</span><br><span class=\"line\">        System.out.println(&quot;readFileByReader异常：&quot; + e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return builder+&quot;&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>通过循环模拟了150000个文件进行测试，FileReader耗时8136毫秒，BufferedReader耗时6718毫秒，差不多相差1秒半的时间，差距还是相当大的，俗话说得好，水滴石穿。</p>\n<p>同样是read方法，只不过是包了一层，有啥不同呢？</p>\n<p>BufferedReader 是一个缓冲字符输入流，可以对 FileRead 进行包装，提供了一个缓存数组，将数据按照一定规则读取到缓存区中，输入流每次读取文件数据时都需要将数据进行字符编码，而 BufferedReader 的出现，降低了输入流访问数据源的次数，将一定大小的数据一次读取到缓存区并进行字符编码，从而提高 IO 的效率。</p>\n<p>如果没有缓冲，每次调用 read() 或 readLine() 都可能导致从文件中读取字节，转换为字符，然后返回，这可能非常低效。</p>\n<p><strong>就像取快递一样，在取快递的时候，肯定是想一次性的取完，避免再来一趟。</strong></p>\n<ul>\n<li><p>FileReader就相当于一件一件的取，乐此不疲；</p>\n</li>\n<li><p>BufferedReader就相当于，你尽可能多的拿你的快递，可是这也有个极限，比如你一次只能拿5件快递，这个 5 就相当于缓冲区，效率上，提升数倍。</p>\n</li>\n</ul>\n<p>对 FileRead 进行包装变成了BufferedReader缓冲字符输入流，其实，Java IO流就是最典型的装饰器模式，装饰器模式通过组合替代继承的方式在不改变原始类的情况下添加增强功能，主要解决继承关系过于复杂的问题，之前整理过一篇装饰器模式，这里就不论述了。</p>\n<p><strong>3、再点进源码瞧瞧。</strong></p>\n<p><strong>（1）FileReader.read()源码很简单，就是直接读取</strong><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public int read(char cbuf[], int off, int len) throws IOException &#123;</span><br><span class=\"line\">   return in.read(cbuf, off, len);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>（2）BufferedReader.read()的源码就较为复杂了，看一下它的核心方法</strong><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fill()private void fill() throws IOException &#123;</span><br><span class=\"line\">   int dst;</span><br><span class=\"line\">    if (markedChar &lt;= UNMARKED) &#123;</span><br><span class=\"line\">        /* No mark */</span><br><span class=\"line\">        dst = 0;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        /* Marked */</span><br><span class=\"line\">        int delta = nextChar - markedChar;</span><br><span class=\"line\">        if (delta &gt;= readAheadLimit) &#123;</span><br><span class=\"line\">            /* Gone past read-ahead limit: Invalidate mark */</span><br><span class=\"line\">            markedChar = INVALIDATED;</span><br><span class=\"line\">            readAheadLimit = 0;</span><br><span class=\"line\">            dst = 0;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            if (readAheadLimit &lt;= cb.length) &#123;</span><br><span class=\"line\">                /* Shuffle in the current buffer */</span><br><span class=\"line\">                System.arraycopy(cb, markedChar, cb, 0, delta);</span><br><span class=\"line\">                markedChar = 0;</span><br><span class=\"line\">                dst = delta;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                /* Reallocate buffer to accommodate read-ahead limit */</span><br><span class=\"line\">                char ncb[] = new char[readAheadLimit];</span><br><span class=\"line\">                System.arraycopy(cb, markedChar, ncb, 0, delta);</span><br><span class=\"line\">                cb = ncb;</span><br><span class=\"line\">                markedChar = 0;</span><br><span class=\"line\">                dst = delta;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            nextChar = nChars = delta;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    int n;</span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\">        n = in.read(cb, dst, cb.length - dst);</span><br><span class=\"line\">    &#125; while (n == 0);</span><br><span class=\"line\">    if (n &gt; 0) &#123;</span><br><span class=\"line\">        nChars = dst + n;</span><br><span class=\"line\">        nextChar = dst;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><strong>核心方法fill()：</strong></p>\n<p>1.字符缓冲输入流，底层有一个8192个元素的缓冲字符数组，当缓冲区的内容读完时，将使用 fill() 方法从硬盘中读取数据填充缓冲数组；</p>\n<p>2.字符缓冲输出流，底层有一个8192个元素的缓冲字符数组，使用flush方法将缓冲数组中的内容写入到硬盘当中；</p>\n<p>3.使用缓冲数组之后，程序在运行的大部分时间内都是内存和内存直接的数据交互过程。内存直接的操作效率是比较高的。并且降低了CPU通过内存操作硬盘的次数；</p>\n<p>4.关闭字符缓冲流，都会首先释放对应的缓冲数组空间，并且关闭创建对应的字符输入流和字符输出流。</p>\n<p>既然缓冲这么好用，为啥jdk将缓冲字符数组设置的这么小，才8192个字节？这是一个比较折中的方案，如果缓冲区太大的话，就会增加单次读写的时间，同样内存的大小也是有限制的，不可能都让你来干这个一件事。</p>\n<p>很多小伙伴也肯定用过它的read(char[] cbuf)，它内部维护了一个char数组，每次写/读数据时，操作的是数组，这样可以减少IO次数。<br><img src=\"/img/2024/20240506.webp\" alt=\"erik.xyz\"></p>\n<p><strong>（3）buffer四大属性</strong></p>\n<p>1.mark：标记</p>\n<p>2.position：位置，下一个要被读或写的元素的索引， 每次读写缓冲区数据时都会改变改值， 为下次读写作准备</p>\n<p>3.limit：表示缓冲区的当前终点，不能对缓冲区 超过极限的位置进行读写操作。且极限 是可以修改的</p>\n<p>4.capacity：容量，即可以容纳的最大数据量；在缓 冲区创建时被设定并且不能改变。</p>\n<p><strong>4、缓冲流：4次上下文切换+4次拷贝</strong></p>\n<p>传统IO执行的话需要4次上下文切换（用户态-&gt;内核态-&gt;用户态-&gt;内核态-&gt;用户态）和4次拷贝。</p>\n<p>1.磁盘文件DMA拷贝到内核缓冲区</p>\n<p>2.内核缓冲区CPU拷贝到用户缓冲区</p>\n<p>3.用户缓冲区CPU拷贝到Socket缓冲区</p>\n<p>4.Socket缓冲区DMA拷贝到协议引擎。<br><img src=\"/img/2024/20240508.webp\" alt=\"erik.xyz\"></p>\n<h4 id=\"五、NIO之FileChannel\"><a href=\"#五、NIO之FileChannel\" class=\"headerlink\" title=\"五、NIO之FileChannel\"></a>五、NIO之FileChannel</h4><p>NIO中比较常用的是FileChannel，主要用来对本地文件进行 IO 操作。</p>\n<p><strong>1、FileChannel 常见的方法有</strong></p>\n<p>1.read，从通道读取数据并放到缓冲区中；</p>\n<p>2.write，把缓冲区的数据写到通道中；</p>\n<p>3.transferFrom，从目标通道 中复制数据到当前通道；</p>\n<p>4,transferTo，把数据从当 前通道复制给目标通道。</p>\n<p><strong>2、关于Buffer 和 Channel的注意事项和细节</strong></p>\n<p>1.ByteBuffer支持类型化的put和get, put放入的是什么数据类型，get就应该使用 相应的数据类型来取出，否则可能有 BufferUnderflowException 异常；</p>\n<p>2.可以将一个普通Buffer 转成只读Buffer；</p>\n<p>3.NIO 还提供了 MappedByteBuffer， 可以让文件直接在内存（堆外的内存）中进 行修改， 而如何同步到文件由NIO 来完成；</p>\n<p>4.NIO 还支持 通过多个 Buffer (即 Buffer 数组) 完成读写操作，即 Scattering 和 Gathering。</p>\n<p><strong>3、Selector(选择器)</strong></p>\n<p>1.Java的NIO，用非阻塞的IO方式。可以用一个线程，处理多个的客户端连 接，就会使用到Selector(选择器)；</p>\n<p>2.Selector 能够检测多个注册的通道上是否有事件发生，如果有事件发生，便获取事件然 后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个 通道，也就是管理多个连接和请求。</p>\n<p>3.只有在 连接/通道 真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程。</p>\n<p>4,避免了多线程之间的上下文切换导致的开销。</p>\n<p><strong>4、selector的相关方法</strong></p>\n<p>1.open();//得到一个选择器对象</p>\n<p>2.select(long timeout);//监控所有注册的通道，当其中有IO操作可以进行时，将 对应的SelectionKey加入到内部集合中并返回，参数用来设置超时时间</p>\n<p>3.selectedKeys();//从内部集合中得到所有的SelectionKey。</p>\n<h4 id=\"六、内存映射技术mmap\"><a href=\"#六、内存映射技术mmap\" class=\"headerlink\" title=\"六、内存映射技术mmap\"></a>六、内存映射技术mmap</h4><p><strong>1、文件映射</strong></p>\n<p>传统的文件I/O操作可能会变得很慢，这时候mmap就闪亮登场了。</p>\n<p><strong>mmap（Memory-mapped files）是一种在内存中创建映射文件的机制，它可以使我们像访问内存一样访问文件，从而避免频繁的文件I/O操作。</strong></p>\n<p>使用mmap的方式是在内存中创建一个虚拟地址，然后将文件映射到这个虚拟地址上，这个映射的过程是由操作系统完成的。</p>\n<p>实现映射后，进程就可以采用指针的方式读写操作这一段内存，系统会自动回写到对应的文件磁盘上，这样就完成了对文件的读取操作，而不用调用 read、write 等系统函数。</p>\n<p>内核空间对这段区域的修改也会直接反映用户空间，从而可以实现不同进程间的文件共享。<br><img src=\"/img/2024/20240509.webp\" alt=\"erik.xyz\"></p>\n<p><strong>2、Java中使用mmap</strong></p>\n<p>在Java中，mmap技术主要使用了JavaNIO（New IO）库中的FileChannel 类，它提供了一种将文件映射到内存的方法，称为MappedByteBuffer。MappedByteBuffe是ByteBuffer的一个子类，它扩展了ByteBuffer的功能，可以直接将文件映射到内存中。</p>\n<p>根据文件地址创建了一层缓存当作索引，放在虚拟内存中，使用时会根据的地址，直接找到磁盘中文件的位置，把数据分段load到系统内存(pagecache)中。<br><img src=\"/img/2024/20240510.webp\" alt=\"erik.xyz\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static String readFileByMmap(String filePath) &#123;</span><br><span class=\"line\">    File file = new File(filePath);</span><br><span class=\"line\">    String ret = &quot;&quot;;</span><br><span class=\"line\">    StringBuilder builder = new StringBuilder();</span><br><span class=\"line\">    try (FileChannel channel = new RandomAccessFile(file, &quot;r&quot;).getChannel()) &#123;</span><br><span class=\"line\">        long size = channel.size();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建一个与文件大小相同的字节数组</span><br><span class=\"line\">        ByteBuffer buffer = ByteBuffer.allocate((int) size);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 将通道上的所有数据都读入到buffer中</span><br><span class=\"line\">        while (channel.read(buffer) != -1) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 切换为只读模式</span><br><span class=\"line\">        buffer.flip();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 从buffer中获取数据并处理</span><br><span class=\"line\">        byte[] data = new byte[buffer.remaining()];</span><br><span class=\"line\">        buffer.get(data);</span><br><span class=\"line\"></span><br><span class=\"line\">        ret = new String(data);</span><br><span class=\"line\">    &#125; catch (IOException e) &#123;</span><br><span class=\"line\">        System.out.println(&quot;readFileByMmap异常：&quot; + e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>3、内存映射技术mmap：4次上下文切换+3次拷贝</strong></p>\n<p><strong>mmap是一种内存映射技术，mmap相比于传统的缓冲流来说，其实就是少了1次CPU 拷贝，变成了数据共享。</strong></p>\n<p>虽然减少了一次拷贝，但是上下文切换的次数还是没变。</p>\n<p>因为存在一次CPU拷贝，因此mmap并不是严格意义上的零拷贝。</p>\n<p>RocketMQ 中就是使用的 mmap 来提升磁盘文件的读写性能。<br><img src=\"/img/2024/20240511.webp\" alt=\"erik.xyz\"></p>\n<h4 id=\"七、sendFile零拷贝\"><a href=\"#七、sendFile零拷贝\" class=\"headerlink\" title=\"七、sendFile零拷贝\"></a>七、sendFile零拷贝</h4><p>零拷贝将上下文切换和拷贝的次数压缩到了极致。</p>\n<p><strong>1、传统IO流</strong></p>\n<p>1.将磁盘中的文件拷贝到内核空间内存；</p>\n<p>2.将内核空间的内容拷贝到用户空间内存；</p>\n<p>3.用户空间将内容写入到内核空间内存；</p>\n<p>4.socket读取内核空间内存，将内容发送给第三方服务器。<br><img src=\"/img/2024/20240512.webp\" alt=\"erik.xyz\"></p>\n<p><strong>2、sendFile零拷贝</strong></p>\n<p>在内核的支持下，零拷贝少了一个步骤，那就是内核缓存向用户空间的拷贝，这样既节省了内存，也节省了 CPU 的调度时间，让效率更高。<br><img src=\"/img/2024/20240513.webp\" alt=\"erik.xyz\"></p>\n<p><strong>3、sendFile零拷贝：2 次上下文切换 + 2次拷贝</strong></p>\n<p><strong>直接将用户缓冲区干掉，而且没有CPU拷贝，故得名零拷贝。</strong><br><img src=\"/img/2024/20240514.webp\" alt=\"erik.xyz\"></p>\n<p><strong>重置优化4：通过零拷贝读取文件</strong><br><img src=\"/img/2024/20240515.webp\" alt=\"erik.xyz\"></p>\n<h4 id=\"八、总结经过\"><a href=\"#八、总结经过\" class=\"headerlink\" title=\"八、总结经过\"></a>八、总结经过</h4><p><strong>4次优化，将页面的加载时间控制在了1秒以内，实打实的提升了程序的秒开率。</strong></p>\n<p>1.批量查询时，不查询BLOB大字段；</p>\n<p>2.点击运费查询时，单独查询+触发索引，实现“懒加载”；</p>\n<p>3.异步存储文件</p>\n<p>4.通过缓冲流-&gt;内存映射技术mmap-&gt; sendFile零拷贝读取本地文件；</p>\n<p><strong>通过一次页面优化，收获颇丰：</strong></p>\n<p>1.通过业务优化，将BLOB大字段进行“懒加载”；</p>\n<p>2.异步存储文件；</p>\n<p>3.系统的学习了Java IO流，输入输出流、字符流、字符流、转换流；</p>\n<p>4.通过NIO的FileChannel读取文件时，较于缓冲流性能上显著提升；</p>\n<p>5.内存映射技术mmap 相比于传统的 缓冲流 来说，其实就是少了1次内核缓冲区到用户缓冲区的CPU拷贝，将其变成了数据共享；</p>\n<p>6.sendFile零拷贝，舍弃了用户空间内存，舍弃了CUP拷贝，完美的零拷贝方案。</p>\n<p>7.通过代码实例，横向对比了FileReader、BufferedReader、NIO之FileChannel、内存映射技术mmap、sendFile零拷贝之间的性能差距；</p>\n<p>转载自：<a href=\"https://mp.weixin.qq.com/s/kaogMK5qz5vkfs9-BYu0Mg\">哪吒编程</a></p>\n",
            "tags": [
                "web",
                "web前端",
                "web优化"
            ]
        },
        {
            "id": "https://erik.xyz/2024/05/06/index-asynchrony-landing/",
            "url": "https://erik.xyz/2024/05/06/index-asynchrony-landing/",
            "title": "增加索引 + 异步 + 不落地后，从 12h 优化到 15 min",
            "date_published": "2024-05-06T03:44:00.000Z",
            "content_html": "<p>在开发中，我们经常会遇到这样的需求，将数据库中的图片导出到本地，再传给别人。</p>\n<h4 id=\"一、一般我会这样做：\"><a href=\"#一、一般我会这样做：\" class=\"headerlink\" title=\"一、一般我会这样做：\"></a>一、一般我会这样做：</h4><p>1.通过接口或者定时任务的形式</p>\n<p>2.读取Oracle或者MySQL数据库</p>\n<p>3.通过FileOutputStream将Base64解密后的byte[]存储到本地</p>\n<p>4.遍历本地文件夹，将图片通过FTP上传到第三方服务器<br><span id=\"more\"></span><br><img src=\"/img/2024/202405100.webp\" alt=\"erik.xyz\"></p>\n<p>现场炸锅了！</p>\n<p>实际的数据量非常大，据统计差不多有400G的图片需要导出。</p>\n<p><strong>现场人员的反馈是，已经跑了12个小时了，还在继续，不知道啥时候能导完。</strong></p>\n<p>停下来呢？之前的白导了，不停呢？不知道要等到啥时候才能导完。</p>\n<p>这不行啊，速度太慢了，一个简单的任务，不能被这东西耗死吧？<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Value(&quot;$&#123;months&#125;&quot;)</span><br><span class=\"line\">private String months;</span><br><span class=\"line\"></span><br><span class=\"line\">@Value(&quot;$&#123;imgDir&#125;&quot;)</span><br><span class=\"line\">private String imgDir;</span><br><span class=\"line\"></span><br><span class=\"line\">@Resource</span><br><span class=\"line\">private UserDao userDao;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">public void getUserInfoImg() &#123;</span><br><span class=\"line\"> try &#123;</span><br><span class=\"line\">  // 获取需要导出的月表</span><br><span class=\"line\">  String[] monthArr = months.split(&quot;,&quot;);</span><br><span class=\"line\">  for (int i = 0; i &lt; monthArr.length; i++) &#123;</span><br><span class=\"line\">   // 获取月表中的图片</span><br><span class=\"line\">   Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class=\"line\">   String tableName = &quot;USER_INFO_&quot; + monthArr[i];</span><br><span class=\"line\">   map.put(&quot;tableName&quot;, tableName);</span><br><span class=\"line\">   map.put(&quot;status&quot;, 1);</span><br><span class=\"line\">   </span><br><span class=\"line\">   List&lt;UserInfo&gt; userInfoList = userDao.getUserInfoImg(map);</span><br><span class=\"line\">   if (userInfoList == null || userInfoList.size() == 0) &#123;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   for (int j = 0; j &lt; userInfoList.size(); j++) &#123;</span><br><span class=\"line\">    UserInfo user = userInfoList.get(j);</span><br><span class=\"line\">    String userId = user.getUserId();</span><br><span class=\"line\">    String userName = user.getUserName();</span><br><span class=\"line\">    byte[] content = user.getImgContent;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 下载图片到本地</span><br><span class=\"line\">    FileUtil.dowmloadImage(imgDir + userId+&quot;-&quot;+userName+&quot;.png&quot;, content);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 将下载好的图片，通过FTP上传给第三方</span><br><span class=\"line\">    FileUtil.uploadByFtp(imgDir);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125; catch (Exception e) &#123;</span><br><span class=\"line\">  serviceLogger.error(&quot;获取图片异常：&quot;, e);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"二、谁写的？赶紧加班优化，会追责吗？\"><a href=\"#二、谁写的？赶紧加班优化，会追责吗？\" class=\"headerlink\" title=\"二、谁写的？赶紧加班优化，会追责吗？\"></a>二、谁写的？赶紧加班优化，会追责吗？</h4><p>经过1小时的深思熟虑，慢的原因可能有以下几点：</p>\n<p>1.查询数据库</p>\n<p>2.程序串行</p>\n<p>3.base64解密</p>\n<p>4.图片落地</p>\n<p>5.FTP上传到服务器</p>\n<p>优化1：数据库中添加对应的索引，提高查询速度</p>\n<p>优化2：采用增加索引+异步+多线程的方式进行导出</p>\n<p><img src=\"/img/2024/202405101.webp\" alt=\"erik.xyz\"></p>\n<p>优化3：不解密+图片不落地，直接通过FTP传给第三方</p>\n<p><img src=\"/img/2024/202405102.webp\" alt=\"erik.xyz\"></p>\n<p><strong>使用索引+异步+不解密+不落地 后，40G图片的导出上传，从12+小时 优化到15 分钟，你敢信？</strong></p>\n<p>差不多的代码，效率差距竟如此之大。</p>\n<p>下面贴出导出图片不落地的关键代码。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Resource</span><br><span class=\"line\">private UserAsyncService userAsyncService;</span><br><span class=\"line\"></span><br><span class=\"line\">@Override</span><br><span class=\"line\">public void getUserInfoImg() &#123;</span><br><span class=\"line\"> try &#123;</span><br><span class=\"line\">  // 获取需要导出的月表</span><br><span class=\"line\">  String[] monthArr = months.split(&quot;,&quot;);</span><br><span class=\"line\">  for (int i = 0; i &lt; monthArr.length; i++) &#123;</span><br><span class=\"line\">   userAsyncService.getUserInfoImgAsync(monthArr[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125; catch (Exception e) &#123;</span><br><span class=\"line\">  serviceLogger.error(&quot;获取图片异常：&quot;, e);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Value(&quot;$&#123;months&#125;&quot;)</span><br><span class=\"line\">private String months;</span><br><span class=\"line\"></span><br><span class=\"line\">@Resource</span><br><span class=\"line\">private UserDao userDao;</span><br><span class=\"line\"></span><br><span class=\"line\">@Async(&quot;async-executor&quot;)</span><br><span class=\"line\">@Override</span><br><span class=\"line\">public void getUserInfoImgAsync(String month) &#123;</span><br><span class=\"line\"> try &#123;</span><br><span class=\"line\">  // 获取月表中的图片</span><br><span class=\"line\">  Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class=\"line\">  String tableName = &quot;USER_INFO_&quot; + month;</span><br><span class=\"line\">  map.put(&quot;tableName&quot;, tableName);</span><br><span class=\"line\">  map.put(&quot;status&quot;, 1);</span><br><span class=\"line\">  </span><br><span class=\"line\">  List&lt;UserInfo&gt; userInfoList = userDao.getUserInfoImg(map);</span><br><span class=\"line\">  if (userInfoList == null || userInfoList.size() == 0) &#123;</span><br><span class=\"line\">   return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  for (int i = 0; i &lt; userInfoList.size(); i++) &#123;</span><br><span class=\"line\">   UserInfo user = userInfoList.get(i);</span><br><span class=\"line\">   String userId = user.getUserId();</span><br><span class=\"line\">   String userName = user.getUserName();</span><br><span class=\"line\">   byte[] content = user.getImgContent;</span><br><span class=\"line\">   </span><br><span class=\"line\">   // 不落地，直接通过FTP上传给第三方</span><br><span class=\"line\">   FileUtil.uploadByFtp(content);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125; catch (Exception e) &#123;</span><br><span class=\"line\">  serviceLogger.error(&quot;获取图片异常：&quot;, e);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><strong>4、异步线程池工具类</strong></p>\n<p><strong>@Async的作用就是异步处理任务。</strong></p>\n<p>1.在方法上添加@Async，表示此方法是异步方法；</p>\n<p>2.在类上添加@Async，表示类中的所有方法都是异步方法；</p>\n<p>3.使用此注解的类，必须是Spring管理的类；</p>\n<p>4.需要在启动类或配置类中加入@EnableAsync注解，@Async才会生效；</p>\n<p>在使用@Async时，如果不指定线程池的名称，也就是不自定义线程池，@Async是有默认线程池的，使用的是Spring默认的线程池SimpleAsyncTaskExecutor。</p>\n<p>默认线程池的默认配置如下：</p>\n<p>1.默认核心线程数：8；</p>\n<p>2.最大线程数：Integet.MAX_VALUE；</p>\n<p>3.队列使用LinkedBlockingQueue；</p>\n<p>4.容量是：Integet.MAX_VALUE；</p>\n<p>5.空闲线程保留时间：60s；</p>\n<p>6.线程池拒绝策略：AbortPolicy；</p>\n<p>从最大线程数可以看出，在并发情况下，会无限制的创建线程，我勒个吗啊。</p>\n<p><strong>也可以通过yml重新配置：</strong><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring:</span><br><span class=\"line\">  task:</span><br><span class=\"line\">    execution:</span><br><span class=\"line\">      pool:</span><br><span class=\"line\">        max-size: 10</span><br><span class=\"line\">        core-size: 5</span><br><span class=\"line\">        keep-alive: 3s</span><br><span class=\"line\">        queue-capacity: 1000</span><br><span class=\"line\">        thread-name-prefix: my-executor</span><br></pre></td></tr></table></figure></p>\n<p>也可以自定义线程池，下面通过简单的代码来实现以下@Async自定义线程池。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@EnableAsync// 支持异步操作</span><br><span class=\"line\">@Configuration</span><br><span class=\"line\">public class AsyncTaskConfig &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * com.google.guava中的线程池</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Bean(&quot;my-executor&quot;)</span><br><span class=\"line\">    public Executor firstExecutor() &#123;</span><br><span class=\"line\">        ThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat(&quot;my-executor&quot;).build();</span><br><span class=\"line\">        // 获取CPU的处理器数量</span><br><span class=\"line\">        int curSystemThreads = Runtime.getRuntime().availableProcessors() * 2;</span><br><span class=\"line\">        ThreadPoolExecutor threadPool = new ThreadPoolExecutor(curSystemThreads, 100,</span><br><span class=\"line\">                200, TimeUnit.SECONDS,</span><br><span class=\"line\">                new LinkedBlockingQueue&lt;&gt;(), threadFactory);</span><br><span class=\"line\">        threadPool.allowsCoreThreadTimeOut();</span><br><span class=\"line\">        return threadPool;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * Spring线程池</span><br><span class=\"line\">     * @return</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @Bean(&quot;async-executor&quot;)</span><br><span class=\"line\">    public Executor asyncExecutor() &#123;</span><br><span class=\"line\">        ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor();</span><br><span class=\"line\">        // 核心线程数</span><br><span class=\"line\">        taskExecutor.setCorePoolSize(24);</span><br><span class=\"line\">        // 线程池维护线程的最大数量，只有在缓冲队列满了之后才会申请超过核心线程数的线程</span><br><span class=\"line\">        taskExecutor.setMaxPoolSize(200);</span><br><span class=\"line\">        // 缓存队列</span><br><span class=\"line\">        taskExecutor.setQueueCapacity(50);</span><br><span class=\"line\">        // 空闲时间，当超过了核心线程数之外的线程在空闲时间到达之后会被销毁</span><br><span class=\"line\">        taskExecutor.setKeepAliveSeconds(200);</span><br><span class=\"line\">        // 异步方法内部线程名称</span><br><span class=\"line\">        taskExecutor.setThreadNamePrefix(&quot;async-executor-&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        /**</span><br><span class=\"line\">         * 当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略</span><br><span class=\"line\">         * 通常有以下四种策略：</span><br><span class=\"line\">         * ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。</span><br><span class=\"line\">         * ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。</span><br><span class=\"line\">         * ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span><br><span class=\"line\">         * ThreadPoolExecutor.CallerRunsPolicy：重试添加当前的任务，自动重复调用 execute() 方法，直到成功</span><br><span class=\"line\">         */</span><br><span class=\"line\">        taskExecutor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class=\"line\">        taskExecutor.initialize();</span><br><span class=\"line\">        return taskExecutor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"三、告别劣质代码，优化从何入手？\"><a href=\"#三、告别劣质代码，优化从何入手？\" class=\"headerlink\" title=\"三、告别劣质代码，优化从何入手？\"></a>三、告别劣质代码，优化从何入手？</h4><p>我觉得优化有两个大方向：</p>\n<p>1.业务优化</p>\n<p>2.代码优化</p>\n<p><strong>1、业务优化业</strong></p>\n<p>务优化的影响力非常大，但它一般属于产品和项目经理的范畴，CRUD程序员很少能接触到。</p>\n<p>比如上面说的图片导出上传需求，经过产品经理和项目经理的不懈努力，这个需求不做了，这优化力度，史无前例啊。</p>\n<p><strong>2、代码优化</strong></p>\n<p>1.数据库优化</p>\n<p>2.复用优化</p>\n<p>3.并行优化</p>\n<p>4.算法优化<br><img src=\"/img/2024/202405103.webp\" alt=\"erik.xyz\"></p>\n<h4 id=\"四、数据库优化\"><a href=\"#四、数据库优化\" class=\"headerlink\" title=\"四、数据库优化\"></a>四、数据库优化</h4><p>1.inner join 、left join、right join，优先使用inner join</p>\n<p>2.表连接不宜太多，索引不宜太多，一般5个以内</p>\n<p>3.复合索引最左特性</p>\n<p>4.操作delete或者update语句，加个limit或者循环分批次删除</p>\n<p>5.使用explain分析你SQL执行计划</p>\n<p>SQL性能优化的47个小技巧，果断收藏！</p>\n<h4 id=\"五、复用优化\"><a href=\"#五、复用优化\" class=\"headerlink\" title=\"五、复用优化\"></a>五、复用优化</h4><p>写代码的时候，大家一般都会将重复性的代码提取出来，写成工具方法，在下次用的时候，就不用重新编码，直接调用就可以了。</p>\n<p>这个就是复用。</p>\n<p>数据库连接池、线程池、长连接也都是复用手段，这些对象的创建和销毁成本过高，复用之后，效率提升显著。</p>\n<p><strong>1、连接池</strong></p>\n<p>连接池是一种常见的优化网络连接复用性的方法。连接池管理着一定数量的网络连接，并且在需要时将这些连接分配给客户端，客户端使用完后将连接归还给连接池。这样可以避免每次通信都建立新的连接，减少了连接的建立和销毁过程，提高了系统的性能和效率。</p>\n<p>在Java开发中，常用的连接池技术有Apache Commons Pool、Druid等。使用连接池时，需要合理设置连接池的大小，并根据实际情况进行调优。连接池的大小过小会导致连接不够用，而过大则会占用过多的系统资源。</p>\n<p><strong>2、长连接</strong></p>\n<p>长连接是另一种优化网络连接复用性的方法。长连接指的是在一次通信后，保持网络连接不关闭，以便后续的通信继续复用该连接。与短连接相比，长连接在一定程度上减少了连接的建立和销毁过程，提高了网络连接的复用性和效率。</p>\n<p>在Java开发中，可以通过使用Socket编程实现长连接。客户端在建立连接后，通过设置Socket的Keep-Alive选项，使得连接保持活跃状态。这样可以避免频繁地建立新的连接，提高网络连接的复用性和效率。</p>\n<p><strong>3、缓存</strong></p>\n<p>缓存也是比较常用的复用，属于数据复用。</p>\n<p>缓存一般是将数据库中的数据缓存到内存或者Redis中，也就是缓存到相对高速的区域，下次查询时，直接访问缓存，就不用查询数据库了，缓存主要针对的是读操作。</p>\n<p><strong>4、缓冲</strong></p>\n<p>缓冲常见于对数据的暂存，然后批量传输或者写入。多使用顺序方式，用来缓解不同设备之间频繁地、缓慢地随机写，缓冲主要针对的是写操作。</p>\n<h4 id=\"六、并行优化\"><a href=\"#六、并行优化\" class=\"headerlink\" title=\"六、并行优化\"></a>六、并行优化</h4><p><strong>1、异步编程</strong></p>\n<p>上面的优化方式就是异步优化，充分利用多核处理器的性能，将串行的程序改为并行，大大提高了程序的执行效率。</p>\n<p>异步编程是一种编程模型，其中任务的执行不会阻塞当前线程的执行。通过将任务提交给其他线程或线程池来处理，当前线程可以继续执行其他操作，而不必等待任务完成。</p>\n<p><strong>2、异步编程的特点</strong></p>\n<p>1.非阻塞：异步任务的执行不会导致调用线程的阻塞，允许线程继续执行其他任务；</p>\n<p>2.回调机制：异步任务通常会注册回调函数，当任务完成时，会调用相应的回调函数进行后续处理；</p>\n<p>3.提高响应性：异步编程能够提高程序的响应性，尤其适用于处理IO密集型任务，如网络请求、数据库查询等；</p>\n<p>Java 8引入了CompletableFuture类，可以方便地进行异步编程。</p>\n<p><strong>3、并行编程</strong></p>\n<p>并行编程是一种利用多个线程或处理器同时执行多个任务的编程模型。它将大任务划分为多个子任务，并发地执行这些子任务，从而加速整体任务的完成时间。</p>\n<p><strong>4、并行编程的特点</strong></p>\n<p>1.分布式任务：并行编程将大任务划分为多个独立的子任务，每个子任务在不同的线程中并行执行；</p>\n<p>2..数据共享：并行编程需要考虑多个线程之间的数据共享和同步问题，以避免出现竞态条件和数据不一致的情况；</p>\n<p>3.提高性能：并行编程能够充分利用多核处理器的计算能力，加速程序的执行速度。</p>\n<p><strong>5、并行编程如何实现？</strong></p>\n<p>1.多线程：Java提供了Thread类和Runnable接口，用于创建和管理多个线程。通过创建多个线程并发执行任务，可以实现并行编程。</p>\n<p>2.线程池：Java的Executor框架提供了线程池的支持，可以方便地管理和调度多个线程。通过线程池，可以复用线程对象，减少线程创建和销毁的开销；</p>\n<p>3.并发集合：Java提供了一系列的并发集合类，如ConcurrentHashMap、ConcurrentLinkedQueue等，用于在并行编程中实现线程安全的数据共享。</p>\n<p>异步编程和并行编程是Java中处理任务并提高程序性能的两种重要方法。</p>\n<p>异步编程通过非阻塞的方式处理任务，提高程序的响应性，并适用于IO密集型任务。</p>\n<p>而并行编程则是通过多个线程或处理器并发执行任务，充分利用计算资源，加速程序的执行速度。</p>\n<p>在Java中，可以使用CompletableFuture和回调接口实现异步编程，使用多线程、线程池和并发集合实现并行编程。通过合理地运用异步和并行编程，我们可以在Java中高效地处理任务和提升程序的性能。</p>\n<p><strong>6、代码示例</strong><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    // 创建线程池</span><br><span class=\"line\">    ExecutorService executor = Executors.newFixedThreadPool(10);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 使用线程池创建CompletableFuture对象</span><br><span class=\"line\">    CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">        // 一些不为人知的操作</span><br><span class=\"line\">        return &quot;result&quot;; // 返回结果</span><br><span class=\"line\">    &#125;, executor);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 使用CompletableFuture对象执行任务</span><br><span class=\"line\">    CompletableFuture&lt;String&gt; result = future.thenApply(result -&gt; &#123;</span><br><span class=\"line\">        // 一些不为人知的操作</span><br><span class=\"line\">        return &quot;result&quot;; // 返回结果</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 处理任务结果</span><br><span class=\"line\">    String finalResult = result.join();</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 关闭线程池</span><br><span class=\"line\">    executor.shutdown();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>7、Java 8 parallel</strong></p>\n<p><strong>（1）parallel()是什么</strong></p>\n<p>Stream.parallel() 方法是 Java 8 中 Stream API 提供的一种并行处理方式。在处理大量数据或者耗时操作时，使用 Stream.parallel() 方法可以充分利用多核 CPU 的优势，提高程序的性能。</p>\n<p>Stream.parallel() 方法是将串行流转化为并行流的方法。通过该方法可以将大量数据划分为多个子任务交由多个线程并行处理，最终将各个子任务的计算结果合并得到最终结果。使用 Stream.parallel() 可以简化多线程编程，减少开发难度。</p>\n<p>需要注意的是，并行处理可能会引入线程安全等问题，需要根据具体情况进行选择。</p>\n<p><strong>（2）举一个简单的demo</strong></p>\n<p>定义一个list，然后通过parallel() 方法将集合转化为并行流，对每个元素进行i++，最后通过 collect(Collectors.toList()) 方法将结果转化为 List 集合。</p>\n<p>使用并行处理可以充分利用多核 CPU 的优势，加快处理速度。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">            list.add(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(list);</span><br><span class=\"line\">        List&lt;Integer&gt; result = list.stream().parallel().map(i -&gt; i++).collect(Collectors.toList());</span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>我勒个去，什么情况？<br><img src=\"/img/2024/202405104.webp\" alt=\"erik.xyz\"></p>\n<p><strong>（3）parallel()的优缺点</strong></p>\n<p><strong>①优点：</strong></p>\n<p>1.充分利用多核 CPU 的优势，提高程序的性能；</p>\n<p>2.可以简化多线程编程，减少开发难度。</p>\n<p><strong>②缺点：</strong></p>\n<p>1.并行处理可能会引入线程安全等问题，需要根据具体情况进行选择；</p>\n<p>2.并行处理需要付出额外的开销，例如线程池的创建和销毁、线程切换等，对于小数据量和简单计算而言，串行处理可能更快。</p>\n<p><strong>（4）何时使用parallel()？</strong></p>\n<p>在实际开发中，应该根据数据量、计算复杂度、硬件等因素综合考虑。</p>\n<p>比如：</p>\n<p>1.数据量较大，有1万个元素；</p>\n<p>2.计算复杂度过大，需要对每个元素进行复杂的计算；</p>\n<p>3.硬件够硬，比如多核CPU。</p>\n<h4 id=\"七、算法优化\"><a href=\"#七、算法优化\" class=\"headerlink\" title=\"七、算法优化\"></a>七、算法优化</h4><p>在上面的例子中，避免base64解密，就应该归类于算法优化。</p>\n<p>程序就是由数据结构和算法组成，一个优质的算法可以显著提高程序的执行效率，从而减少运行时间和资源消耗。相比之下，一个低效的算法就可能导致运行非常缓慢，并占用大量系统资源。</p>\n<p>很多问题都可以通过算法优化来解决，比如：</p>\n<p><strong>1、循环和递归</strong></p>\n<p>循环和递归是Java编程中常见的操作，然而，过于复杂的业务逻辑往往会带来多层循环套用，不必要的重复循环会大大降低程序的执行效率。</p>\n<p>递归是一种函数自我调用的技术，类似于循环，虽然递归可以解决很多问题，但是，递归的效率有待提高。</p>\n<p><strong>2、内存管理</strong></p>\n<p>Java自带垃圾收集器，开发人员不用手动释放内存。</p>\n<p>但是，不合理的内存使用可能导致内存泄漏和性能下降，确保及时释放不再使用的对象，避免创建过多的临时对象。</p>\n<p><strong>3、字符串</strong></p>\n<p>我觉得字符串是Java编程中使用频率最高的技术，很多程序员恨不得把所有的变量都定义成字符串。</p>\n<p>然而，由于字符串是不可变的，每次执行字符串拼接、替换时，都会创建一个新的字符串。这会占用大量的内存和处理时间。</p>\n<p>使用StringBuilder来处理字符串的拼接可以显著的提高性能。</p>\n<p><strong>4、IO操作</strong></p>\n<p>IO操作通常是最耗费性能和资源的操作。在处理大量数据IO操作时，务必注意优化IO代码，提高程序性能，比如上面提高的图片不落地就是彻底解决IO问题。</p>\n<p><strong>5、数据结构的选择</strong></p>\n<p>选择适当的数据结构对程序的性能至关重要。</p>\n<p>比如Java世界中用的第二多的Map，比较常用的有HashMap、HashTable、ConcurrentHashMap。</p>\n<p>HashMap，底层数组+链表实现，可以存储null键和null值，线程不安全；</p>\n<p>HashTable，底层数组+链表实现，无论key还是value都不能为null，线程安全，实现线程安全的方式是在修改数据时锁住整个HashTable，效率低，ConcurrentHashMap做了相关优化；</p>\n<p>ConcurrentHashMap，底层采用分段的数组+链表实现，线程安全，通过把整个Map分为N个Segment，可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。</p>\n<p>Hashtable的synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。</p>\n<p>转载自：<a href=\"https://mp.weixin.qq.com/s/V2p_p-KoDowlZxLN2by2Sg\">哪吒编程</a></p>\n",
            "tags": [
                "web",
                "优化"
            ]
        },
        {
            "id": "https://erik.xyz/2019/07/18/http1-1-and-http2-0/",
            "url": "https://erik.xyz/2019/07/18/http1-1-and-http2-0/",
            "title": "http1.1和http2.0的知识点",
            "date_published": "2019-07-17T16:20:00.000Z",
            "content_html": "<h3 id=\"Http1-1\"><a href=\"#Http1-1\" class=\"headerlink\" title=\"Http1.1\"></a><a href=\"#Http1-1\" title=\"Http1.1\"></a>Http1.1</h3><ul>\n<li><p>缓存处理</p>\n<p> 引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</p>\n</li>\n<li><p>带宽优化及网络连接的使用</p>\n<p>  在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。<span id=\"more\"></span></p>\n</li>\n<li><p>错误通知的管理</p>\n<p> 新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p>\n</li>\n<li><p>Host头处理</p>\n<p>  Http1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</p>\n</li>\n<li><p>长连接</p>\n<p>  Http1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</p>\n</li>\n</ul>\n<h3 id=\"Http2-0\"><a href=\"#Http2-0\" class=\"headerlink\" title=\"Http2.0\"></a>Http2.0</h3><ul>\n<li>完全采用二进制格式</li>\n<li><p>多路复用</p>\n<p>   根据request的 id将request再归属到各自不同的服务端请求里面。</p>\n</li>\n<li><p>header压缩</p>\n<p>   使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</p>\n</li>\n<li><p>服务端推送</p>\n<p>   server push功能。</p>\n</li>\n</ul>\n<h5 id=\"Http2-0的多路复用和Http1-X中的长连接复用有什么区别？\"><a href=\"#Http2-0的多路复用和Http1-X中的长连接复用有什么区别？\" class=\"headerlink\" title=\"Http2.0的多路复用和Http1.X中的长连接复用有什么区别？\"></a><a href=\"#Http2-0的多路复用和Http1-X中的长连接复用有什么区别？\" title=\"Http2.0的多路复用和Http1.X中的长连接复用有什么区别？\"></a>Http2.0的多路复用和Http1.X中的长连接复用有什么区别？</h5><ul>\n<li>Http/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；</li>\n<li>Http/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；</li>\n<li>Http/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；</li>\n</ul>\n<h5 id=\"服务器推送到底是什么？\"><a href=\"#服务器推送到底是什么？\" class=\"headerlink\" title=\"服务器推送到底是什么？\"></a><a href=\"#服务器推送到底是什么？\" title=\"服务器推送到底是什么？\"></a>服务器推送到底是什么？</h5><p>服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。</p>\n<h5 id=\"为什么需要头部压缩？\"><a href=\"#为什么需要头部压缩？\" class=\"headerlink\" title=\"为什么需要头部压缩？\"></a><a href=\"#为什么需要头部压缩？\" title=\"为什么需要头部压缩？\"></a>为什么需要头部压缩？</h5><p>假定一个页面有100个资源需要加载（这个数量对于今天的Web而言还是挺保守的）, 而每一次请求都有1kb的消息头（这同样也并不少见，因为Cookie和引用等东西的存在）, 则至少需要多消耗100kb来获取这些消息头。HTTP2.0可以维护一个字典，差量更新HTTP头部，大大降低因头部传输产生的流量</p>\n<h5 id=\"Http2-0多路复用有多好\"><a href=\"#Http2-0多路复用有多好\" class=\"headerlink\" title=\"Http2.0多路复用有多好\"></a><a href=\"#Http2-0多路复用有多好\" title=\"Http2.0多路复用有多好\"></a>Http2.0多路复用有多好</h5><ul>\n<li>Http性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。</li>\n<li>Http/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。</li>\n</ul>\n",
            "tags": [
                "web",
                "http",
                "http1.1",
                "http2.0"
            ]
        },
        {
            "id": "https://erik.xyz/2015/06/18/xiang-ying-shi-bu-ju-ru-he-ce-shi-bu-tong-fen-bian-lv/",
            "url": "https://erik.xyz/2015/06/18/xiang-ying-shi-bu-ju-ru-he-ce-shi-bu-tong-fen-bian-lv/",
            "title": "响应式布局如何测试不同分辨率",
            "date_published": "2015-06-17T16:04:00.000Z",
            "content_html": "<p>最近在做响应式布局适应不同分辨率的屏幕，太痛苦了，摸着石头过河。之前没有做过这块，手机端又不是很在行，ipad/iphone/三星……一大堆不同的屏幕，如何测试呢，总不能买一大堆设备吧。</p>\n<p>偶然间发现谷歌浏览器(最新版)可以缩小来实现，这样又有问题了，分辨率是多少呢？发现新方法了，废话不多说了，直接上教程。 1.在谷歌浏览器打开你要测试的网页按键盘F12，打开网页调试   2.点击调试工具右上角形似菜单的图标   3.这时候你会发现紧挨着浏览器底部有一排英文菜单   4.把菜单往上拉出来，点击第三个菜单   5.点击打开菜单下面的手机标示   6.如此便是手机设计效果   7.有2个地方可以选择不同的分辨率及屏幕对应的像素   8.下次打开就直接点击F12，然后左上角的手机标示就可以切换</p>\n",
            "tags": [
                "css",
                "web",
                "html",
                "响应式分辨率",
                "响应式调试",
                "自适应屏幕"
            ]
        },
        {
            "id": "https://erik.xyz/2015/01/29/display-inline-block-text-align-justify-xia-lie-biao-de-liang-duan-dui-qi-bu-ju/",
            "url": "https://erik.xyz/2015/01/29/display-inline-block-text-align-justify-xia-lie-biao-de-liang-duan-dui-qi-bu-ju/",
            "title": "display:inline-block/text-align:justify下列表的两端对齐布局",
            "date_published": "2015-01-29T14:06:00.000Z",
            "content_html": "<p>by <a href=\"http://www.zhangxinxu.com/\">zhangxinxu</a></p>\n<h3 id=\"一、何为列表元素的两端对齐布局\"><a href=\"#一、何为列表元素的两端对齐布局\" class=\"headerlink\" title=\"一、何为列表元素的两端对齐布局\"></a>一、何为列表元素的两端对齐布局</h3><p>首先说说何为两端对齐。下面这个截图是word中一段英文左对齐的右边缘截图：<br><img src=\"http://image.zhangxinxu.com/image/blog/201103/2011-03-12_214827.png\" alt=\"word中文字左对齐截图 张鑫旭-鑫空间-鑫生活\" title=\"word中文字左对齐截图 张鑫旭-鑫空间-鑫生活\"> </p>\n<p>可以看到右侧是参差不起的，现在，选中文字，点击word上方的两端对齐按钮，如下图：<br><img src=\"http://image.zhangxinxu.com/image/blog/201103/2011-03-12_215036.png\" alt=\"点击word中两端对齐按钮 张鑫旭-鑫空间-鑫生活\" title=\"点击word中两端对齐按钮 张鑫旭-鑫空间-鑫生活\"> </p>\n<p>结果文字的右边缘就成了这样：<br><img src=\"http://image.zhangxinxu.com/image/blog/201103/2011-03-12_215318.png\" alt=\"word中两端对齐效果截图 张鑫旭-鑫空间-鑫生活\" title=\"word中两端对齐效果截图 张鑫旭-鑫空间-鑫生活\"> </p>\n<p>右侧完全对齐了，也就是整篇文字全部沿着左边缘和右边缘对齐显示了。 然后这里的“列表元素”指的是具有类似结构的重复列表元素，例如QQ校友中的图片列表：<br><img src=\"http://image.zhangxinxu.com/image/blog/201010/2010-10-28_215059.jpg\" alt=\"列表布局示意 张鑫旭-鑫空间-鑫生活\" title=\"列表布局示意 张鑫旭-鑫空间-鑫生活\"> </p>\n<p>所谓列表元素的两端对齐就是每行列表元素的第一个元素与父容器的左边缘重合，最后一个元素与父容器的右边缘重合。例如淘宝首页的热卖单品，或是人人网的热门分享列表（如下截图）：<br><img src=\"http://image.zhangxinxu.com/image/blog/201103/2011-03-12_221107.png\" alt=\"人人网热门分享列表两端对齐 张鑫旭-鑫空间-鑫生活\" title=\"人人网热门分享列表两端对齐 张鑫旭-鑫空间-鑫生活\"> </p>\n<p>我想我们平时写页面的时候也经常会拿到的列表元素两端对齐的体验舒服的设计图吧。<span id=\"more\"></span></p>\n<h3 id=\"二、如何实现元素的两端对齐\"><a href=\"#二、如何实现元素的两端对齐\" class=\"headerlink\" title=\"二、如何实现元素的两端对齐\"></a>二、如何实现元素的两端对齐</h3><p>CSS2中<code>text-align</code>有一个属性值为<code>justify</code>，为对齐之意。其实现的效果就 是可以让一行文字两端对齐显示（文字内容要超过一行）。如果您现在浏览器的地址是以<a href=\"http://www.zhangxinxu.com/打头的话，就可\">http://www.zhangxinxu.com/打头的话，就可</a> 以发现我的每篇文章都是以两端对齐的方式显示的，所以，有时候就会出现文字非常稀松的情况，如下图所示。</p>\n<p><img src=\"http://image.zhangxinxu.com/image/blog/201103/2011-03-12_211400.png\" alt=\"文字两端对齐下稀疏的排列 张鑫旭-鑫空间-鑫生活\" title=\"文字两端对齐下稀疏的排列 张鑫旭-鑫空间-鑫生活\"></p>\n<p><code>text-align</code>其诞生的意义是控制文字的对齐与显示的，从其属性名上就可以看出来。从其渲染与解析上来看，其主要 是用来控制inline水平元素或inline-block元素的对齐与显示的，例如嵌套行内标签的文字、图片、input表单控件等；而对block水 平的元素是没有作用的。 所以，对于列表元素，理论上，我们只要将原本block水平的列表元素inline化或是inline-block化就可以轻松实现其两端对齐了。 然而考虑到实际情况，inline水平化显然是不可能的，因为不能给列表元素定宽定高，设置垂直方向上的间距等，列表元素就像是一摊烂泥，根本没法用来砌 房子；而inline-block化也是有重重阻碍的，因为IE6/7并不真正意义上的支持inline-block属性。 可见，理论上虽简单，实际上还得从长计议。</p>\n<h3 id=\"三、目前列表元素如何实现两端对齐的\"><a href=\"#三、目前列表元素如何实现两端对齐的\" class=\"headerlink\" title=\"三、目前列表元素如何实现两端对齐的\"></a>三、目前列表元素如何实现两端对齐的</h3><p>方法多多。 ① 首先看<a href=\"http://www.taobao.com/#J_IndexP4P\">淘宝网首页</a>热卖单品的例子，如下截图：</p>\n<p><img src=\"http://image.zhangxinxu.com/image/blog/201103/2011-03-12_223246.png\" alt=\"淘宝网首页热卖单品截图 张鑫旭-鑫空间-鑫生活\" title=\"淘宝网首页热卖单品截图 张鑫旭-鑫空间-鑫生活\"> </p>\n<p>其列表布局使用的是传统的浮动(float)布局，通过<code>width</code>属性强行增大父容器的宽度来实现看上去的“两端对齐”效果的。<br><img src=\"http://image.zhangxinxu.com/image/blog/201103/2011-03-12_223616.png\" alt=\"淘宝网首页增加容器宽度实现两端对齐 张鑫旭-鑫空间-鑫生活\" title=\"淘宝网首页增加容器宽度实现两端对齐 张鑫旭-鑫空间-鑫生活\"> </p>\n<p>② 再看人人网热门分享的两端对齐效果的实现方法，我在之前“<a href=\"http://www.zhangxinxu.com/wordpress/?p=1194\">基于display:inline-block的列表布局</a>”一文中已经提过，人人网这里的列表布局为inline-block布局。<br><img src=\"http://image.zhangxinxu.com/image/blog/201103/2011-03-12_223940.png\" alt=\"人人网热门分享inline-block布局 张鑫旭-鑫空间-鑫生活\" title=\"人人网热门分享inline-block布局 张鑫旭-鑫空间-鑫生活\"> </p>\n<p>其通过也是通过增大父标签的宽度来实现看上去的“两端对齐”效果的，不过其不是通过<code>width</code>属性来增加父标签的宽度的，而是使用的margin负值（我个人推荐使用margin负值而不是定宽）：<br><img src=\"http://image.zhangxinxu.com/image/blog/201103/2011-03-12_224432.png\" alt=\"margin负值增加父容器的宽度 张鑫旭-鑫空间-鑫生活\" title=\"margin负值增加父容器的宽度 张鑫旭-鑫空间-鑫生活\"> </p>\n<p>③ 还有一种方法就是利用<code>white-space: nowrap</code>，此方法需在inline-block布局基础上使用，一般用在实现单行列表元素看上去的“两端对齐”效果上。<code>white-space: nowrap</code>会强制列表元素不换行，于是你无需设定父标签容器的宽度或是通过<code>margin</code>负值等手段增加父容器的宽度等。这里不展开，以后有机会要好好说一说<code>white-space: nowrap</code>这个很有用的CSS声明的。 以上就是目前几种常见的实现列表元素看上去的“两端对齐”效果方法。怎么样，是不是每个都很折腾——首先列表元素排列就已经很折腾人的了（定宽，计算间距），然后还有人为增加父容器的宽度，同时祖辈元素还要溢出隐藏(<code>overflow:hidden</code>)，oh，my lady嘎嘎。我想这就是为什么网上会有前端工程师咆哮体咆哮加班的原因了（关于此图，您可以点击<br><a href=\"http://ww4.sinaimg.cn/bmiddle/41718533jw6df4iuu2d6qj.jpg\">这里</a><br>查看）。 其实，这些活儿都是边喝咖啡，边看微博就可以完成的，关键使用<code>text-align:justify</code>来做两端对齐的布局。</p>\n<h3 id=\"四、text-align-justify实现两端对齐的好处\"><a href=\"#四、text-align-justify实现两端对齐的好处\" class=\"headerlink\" title=\"四、text-align:justify实现两端对齐的好处\"></a>四、text-align:justify实现两端对齐的好处</h3><p>好处就是简单方便。只要一个简单的<code>text-align:justify</code>声明，里面的元素就自动等间距两端对齐布局啦！根本无需计算每个列表元素间的margin间距，更不用去修改父容器的宽度。</p>\n<h3 id=\"五、关于display-inline-block列表布局\"><a href=\"#五、关于display-inline-block列表布局\" class=\"headerlink\" title=\"五、关于display:inline-block列表布局\"></a>五、关于display:inline-block列表布局</h3><p>本文的内容是基于<code>display:inline-block</code>列表布局的，所以如果您只知道浮动布局建议您认真看下我之前“<a href=\"http://www.zhangxinxu.com/wordpress/?p=1194\">拜拜了,浮动布局 – 基于display:inline-block的列表布局</a>”一文，这篇文章非常详细的讲解了<code>display:inline-block</code>列表布局的前世今生，相信会有不少收获。您可能注意到了，在这篇文章的最后其实已经简单提到<code>text-align:justify</code>下的两端对齐布局，然而，那里只是简单展示了个<a href=\"http://www.zhangxinxu.com/study/201011/inline-block-text-justify-layout.html\">例子</a>，对于一些显示上的问题（例如悲剧的最后一行），以及IE6/7浏览器以及IE8浏览器下实现的注意事项并没有详细阐述，而本文就是来解决这些问题的。</p>\n<h3 id=\"六、display-inline-block-text-align-justify下列表的两端对齐布局\"><a href=\"#六、display-inline-block-text-align-justify下列表的两端对齐布局\" class=\"headerlink\" title=\"六、display:inline-block/text-align:justify下列表的两端对齐布局\"></a>六、display:inline-block/text-align:justify下列表的两端对齐布局</h3><p>为了表述上逻辑清晰。我们先把IE6和IE7浏览器晾在一边，看看IE8+浏览器以及现代浏览器下如何<code>display:inline-block</code>+<code>text-align:justify</code>实现列表元素的两端对齐。 说穿了其实很简单，我们不妨以最常见的列表标签-<code>ul</code>, <code>li</code>标签举例，要实现<code>li</code>列表的两端对齐，直接下面这点CSS代码就OK了：</p>\n<p>ul{text-align:justify;}<br>li{display:inline-block;}</p>\n<p>简单得让人当场吐血三升。 唯一需要注意的就是列表元素<strong>首尾标签留空</strong>（或换行），如下图所示：<br><img src=\"http://image.zhangxinxu.com/image/blog/201103/2011-03-13_131033.png\" alt=\"标签首尾换行 张鑫旭-鑫空间-鑫生活\" title=\"标签首尾换行 张鑫旭-鑫空间-鑫生活\"></p>\n<p><img src=\"http://image.zhangxinxu.com/image/blog/201103/2011-03-13_131358.png\" alt=\"首尾标签留空 张鑫旭-鑫空间-鑫生活\" title=\"首尾标签留空 张鑫旭-鑫空间-鑫生活\"><br>不能够上一个标签组的结束标签与下一个标签组的其实标签连在一起，如下图所示：</p>\n<p><img src=\"http://image.zhangxinxu.com/image/blog/201103/2011-03-13_131708.png\" alt=\"标签不能连在一起 张鑫旭-鑫空间-鑫生活\" title=\"标签不能连在一起 张鑫旭-鑫空间-鑫生活\"> </p>\n<p>不仅如此，对于IE8浏览器，列表元素不能处在<code>font-size:0</code>的环境下，至少code&gt;font-size:1px，因为IE8浏览器<code>font-size:0</code>或直接把换行空格或普通空格抹掉而无法实现两端对齐效果。 ok，下面是重头戏了，纠缠不清的IE6/IE7浏览器。显然上面的<code>ul</code>, <code>li</code>样式组合在IE6/7浏览器下是行不通的，即使你使用hack让IE6/7下的<code>li</code>标签有类似于<code>display:inline-block</code>的特性也是没有作用的。那么如何才能让IE6/7浏览器也有列表元素支持<code>text-align:justify</code>属性呢？经过我反复试验与调试，总结了两点：<strong>inline标签化</strong>以及<strong>结束标签连续化</strong>。 <strong>1. inline标签化</strong> 所谓“inline标签化”就是列表元素需要使用inline水平的标签，例如<code>span</code>, <code>a</code>, <code>strong</code>, <code>em</code>等，像<code>li</code>, <code>div</code>这些标签就不可以。 <strong>2. 结束标签连续化</strong> 所谓“结束标签连续化”是指列表元素及其内部标签的结束标签需要连在一起。例如下面这个就是不行的：</p>\n<pre><code>&lt;span&gt;\n    &lt;a href=&quot;#&quot;&gt;\n        &lt;img src=&quot;test.jpg&quot; /&gt;\n    &lt;/a&gt;\n    &lt;span&gt;描述&lt;/span&gt;\n&lt;/span&gt;\n</code></pre><p>而应该是这个样子滴：</p>\n<pre><code>&lt;span&gt;\n    &lt;a href=&quot;#&quot;&gt;\n        &lt;img src=&quot;test.jpg&quot; /&gt;\n    &lt;/a&gt;\n    &lt;span&gt;描述&lt;/span&gt;&lt;/span&gt;\n</code></pre><p>我们已经习惯了结构化的缩进，所以上面结束标签连写看上去很不自然，有些别扭。但是，为了实现效果，这是没有办法的事情。<strong>注意：如果列表标签内嵌多层，则所有层级的结束标签都要连续。</strong> IE6/IE7浏览器同时满足上面的<strong>inline标签化</strong>以及<strong>结束标签连续化</strong>，再加上先前现代浏览器下的<strong>首尾标签留空</strong>，IE6/IE7浏览器也就能够实现列表元素的两端对齐啦！ 为了便于更直观的知道各个浏览器下实现两端对齐效果需要注意的事项，我特地制作了下表：</p>\n<p>各个浏览器实现text-align:justify下的两端对齐布局注意事项表</p>\n<p>浏览器</p>\n<p>注意事项</p>\n<p>IE6</p>\n<p>inline水平列表标签、列表结束标签连续、列表元素间换行或留空</p>\n<p>IE7</p>\n<p>inline水平列表标签、列表结束标签连续、列表元素间换行或留空</p>\n<p>IE8</p>\n<p>列表元素间换行或留空、列表元素的环境字体大小不能为0</p>\n<p>现代浏览器</p>\n<p>列表元素间换行或留空</p>\n<p>  然而，现在还有一个很悲剧的问题没有解决，就是当列表<strong>元素最后一行无法两端对齐</strong>的悲剧。如下图所示：<br>  <img src=\"http://image.zhangxinxu.com/image/blog/201103/2011-03-13_140147.png\" alt=\"text-justify下的悲剧最后一行 张鑫旭-鑫空间-鑫生活\" title=\"text-justify下的悲剧最后一行 张鑫旭-鑫空间-鑫生活\"><br>  其实这个问题很好解决的。 <strong>如何悲剧变喜剧？</strong> 列表（或文字）要两端对齐的前提就是内容必须超过一行，所以，要解决最后一行元素无法两端对齐的文字其实很简单，就是在列表（或文字段）的最后创建一个高度为0的宽度100%的透明的inline-block的标签层就可以了，例如：</p>\n<p>.justify_fix{display:inline-block; width:100%; height:0; overflow:hidden;}</p>\n<p>如下HTML：</p>\n<p><span class=\"justify_fix\"></span></p>\n<p>例如拿先前最后一行列表悲剧的demo举例，现在在该demo列表最后添加上面类名为<code>justify_fix</code>的<code>span</code>元素，结果最后一行两端对齐排列了，如下图变化：<br><img src=\"http://image.zhangxinxu.com/image/blog/201103/2011-03-13_223453.png\" alt=\"末行元素也两端对齐了 张鑫旭-鑫空间-鑫生活\" title=\"末行元素也两端对齐了 张鑫旭-鑫空间-鑫生活\"></p>\n<p>无论您手上的是什么版本的浏览器，您可以狠狠地点击这里：</p>\n<p><a href=\"http://www.zhangxinxu.com/study/201103/inline-block-text-justify-fixed.html\">末行也两端对齐的美女列表demo</a><br>改变浏览器的宽度，您可以更直观地看出两端对齐的效果。 <strong>补充 on 2011-03-16：</strong> 很多时候，我们希望列表的最后一行是左对齐排列的，而不是两端对齐，这时候怎么办呢？原理与上面的两端对齐一致。就是复制几个列表元素的外层标签，等宽，但高度为0，里面就是个<code>&amp;nbsp;</code>(不可缺)，复制的个数一般就是每行元素的列表个数啦，这样肯定可以保证最后一行元素一定是左对齐排列的啦！ 如下HTML代码：</p>\n<pre><code>&lt;div class=&quot;box&quot;&gt;\n    &lt;span class=&quot;list&quot;&gt;&lt;img src=&quot;http://image.zhangxinxu.com/image/study/s/s128/mm9.jpg&quot; /&gt;\n哇哦，美女，口水，鼻血~~~&lt;/span&gt;\n    &lt;span class=&quot;list&quot;&gt;&lt;img src=&quot;http://image.zhangxinxu.com/image/study/s/s128/mm9.jpg&quot; /&gt;\n哇哦，美女，口水，鼻血，不行了，我的小兔乱撞~~&lt;/span&gt;\n    .\n    .\n    .\n    &lt;span class=&quot;list left_fix&quot;&gt;&amp;nbsp;&lt;/span&gt;\n    &lt;span class=&quot;list left_fix&quot;&gt;&amp;nbsp;&lt;/span&gt;\n    &lt;span class=&quot;list left_fix&quot;&gt;&amp;nbsp;&lt;/span&gt;\n    &lt;span class=&quot;list left_fix&quot;&gt;&amp;nbsp;&lt;/span&gt;\n    &lt;span class=&quot;list left_fix&quot;&gt;&amp;nbsp;&lt;/span&gt;\n&lt;/div&gt;\n</code></pre><p>上面HTML中的<code>left_fix</code>样式如下：</p>\n<p>.left_fix{height:0; padding:0; overflow:hidden;}</p>\n<p>结果先前等宽对齐的最后三个图片就与上面元素垂直对齐且左对齐啦！（下图截自IE7浏览器）<br><img src=\"http://image.zhangxinxu.com/image/blog/201103/2011-03-16_204407.png\" alt=\"最后一行元素左对齐实现 张鑫旭-鑫空间-鑫生活\" title=\"最后一行元素左对齐实现 张鑫旭-鑫空间-鑫生活\"></p>\n<p>您可以狠狠地点击这里：<br><a href=\"http://www.zhangxinxu.com/study/201103/inline-block-text-justify-last-left.html\">最后一行元素左对齐排列demo</a> </p>\n<p>于是，综合上面所有讨论，我们就可以相对比较完美地实现列表元素在text-align:justify的两端对齐效果了。</p>\n<h3 id=\"七、text-align-justify下两端对齐效果实例\"><a href=\"#七、text-align-justify下两端对齐效果实例\" class=\"headerlink\" title=\"七、text-align:justify下两端对齐效果实例\"></a>七、text-align:justify下两端对齐效果实例</h3><p>我们拿上面人人网热门分享处的inline-block列表布局举例。 您可以狠狠地点击这里：</p>\n<p><a href=\"http://www.zhangxinxu.com/study/201103/inline-block-text-justify-renren.html\">人人网热门分享列表text-justify下两端对齐demo</a></p>\n<p>效果如下图（截自IE7浏览器）：</p>\n<p><img src=\"http://image.zhangxinxu.com/image/blog/201103/2011-03-13_224718.png\" alt=\"人人网热门列表justify下两端对齐效果截图 张鑫旭-鑫空间-鑫生活\" title=\"人人网热门列表justify下两端对齐效果截图 张鑫旭-鑫空间-鑫生活\"> </p>\n<p>CSS代码如下：</p>\n<pre><code>.video-list&#123;width:540px; margin-left:auto; margin-right:auto; text-align:justify;&#125; /*列表父容器*/\n.text-justify-list&#123;display:inline-block; width:97px; margin-bottom:15px; text-align:left; vertical-align:top;&#125;/*列表元素*/\n\n.\n. /\\* 完全人人网CSS代码*/\n.\n\n.justify_fix&#123;display:inline-block; width:100%; height:0; overflow:hidden;&#125;/*末行悲剧变喜剧*/\n</code></pre><p>可以看到列表元素压根就没有设置垂直方向上的<code>margin</code>或是<code>padding</code>值，就单单一个宽度值，但是列表元素确实两端对齐，等间距排列。没有计算，没有有意去增加父容器宽度等，超简单就实现了。 比对上面提到的些注意事项，看看这个例子中的HTML代码是如何实践上面的注意事项的：<br><strong>①inline水平标签</strong> 如下截图所示：<br><img src=\"http://image.zhangxinxu.com/image/blog/201103/2011-03-13_225547.png\" alt=\"inline标签使用截图 张鑫旭-鑫空间-鑫生活\" title=\"inline标签使用截图 张鑫旭-鑫空间-鑫生活\"> </p>\n<p><strong>②列表结束标签连续</strong> 如下图所示：<br><img src=\"http://image.zhangxinxu.com/image/blog/201103/2011-03-13_225817.png\" alt=\"结束标签连续 张鑫旭-鑫空间-鑫生活\" title=\"结束标签连续 张鑫旭-鑫空间-鑫生活\"> </p>\n<p><strong>③列表标签换行或留空</strong> 如下截图所示：<br><img src=\"http://image.zhangxinxu.com/image/blog/201103/2011-03-13_230124.png\" alt=\"列表标签换行不连续截图 张鑫旭-鑫空间-鑫生活\" title=\"列表标签换行不连续截图 张鑫旭-鑫空间-鑫生活\"> 如此，你也可以轻轻松松实现列表元素的两端对齐布局，而且不用去担心兼容性问题！！GO！大胆的去使用吧！</p>\n<h3 id=\"八、一些补充的话语\"><a href=\"#八、一些补充的话语\" class=\"headerlink\" title=\"八、一些补充的话语\"></a>八、一些补充的话语</h3><p>首先是关于为什么IE6/IE7浏览器列表元素需使用inline水平标签，，同时结束标签需连续，这个问题我也是不知道为什么，浏览器不是我开发的，要问得去问盖茨先生了。 其次，语义化的问题。要兼顾IE6/IE7浏览器，像列表标签<code>ul</code>, <code>li</code>等就不能使用了，所以HTML语义上可能质量要降低了，权衡在你手。 最后，都是自己试验出来的东西，可能您有更好的方法，或者可以解释IE6/IE7下一些奇怪的行为，欢迎以评论的形式进行交流。资历有限，文中难免有表述不准确的地方，欢迎指正。 原创文章，转载请注明来自<a href=\"http://www.zhangxinxu.com/\">张鑫旭-鑫空间-鑫生活</a>[<a href=\"http://www.zhangxinxu.com/\">http://www.zhangxinxu.com</a>]</p>\n",
            "tags": [
                "js",
                "css",
                "web"
            ]
        },
        {
            "id": "https://erik.xyz/2015/01/12/18-ge-css-jing-jian-ya-suo-gong-ju-he-ji-qiao/",
            "url": "https://erik.xyz/2015/01/12/18-ge-css-jing-jian-ya-suo-gong-ju-he-ji-qiao/",
            "title": "18个CSS精简压缩工具和技巧",
            "date_published": "2015-01-12T12:40:00.000Z",
            "content_html": "<p>作者: <a href=\"http://paranimage.com/author/admin/\" title=\"由帕兰发布\">帕兰</a> 我们已看过<a href=\"http://paranimage.com/8-online-css-optimizer/\">8个在线CSS优化工具</a>和<a href=\"http://paranimage.com/css-code-streamlined-tools-and-tricks/\">CSS代码精简技巧</a>，本文则为你带来<strong>18个CSS精简压缩工具和技巧</strong>。</p>\n<h3 id=\"压缩还是不压缩\"><a href=\"#压缩还是不压缩\" class=\"headerlink\" title=\"压缩还是不压缩\"></a>压缩还是不压缩</h3><p>在我们讨论如何压缩CSS之前，需要注意一下在压缩和代码的易读性上常常要有个平衡。很多编码者以其CSS组织清晰为傲，而且并不希望自己的代码被 通过压缩器去掉注释和断行。作为一个设计师，你应该分析你所编写的代码的目标。如果你要创建一个小的只需要几行CSS的网站，可能就没有必要做额外的压 缩。同样，如果你在编写需要和一个开放团队分享的代码，插入额外的注释和断行可以节省你的同事的大量时间并获得他们真心的感谢。然而，如果你在设计一个需 要大量CSS的大型网站，你肯定要注意你的文件大小并进你所能保持其最小。 可能在寻找压缩和可能性之间的完美结合上面需要花一些时间，但是它们都值得挖掘而且实现它们的平衡可以让你的工作变得容易很多。同时，很明显并不是说压缩一定会导致可读性的降低。很多可用于压缩代码的技术都能生成更好更有组织的代码。 考虑到这一点儿，让我们开始了解一些技术已保持CSS文件最小化吧。<span id=\"more\"></span></p>\n<h3 id=\"空白样式定义\"><a href=\"#空白样式定义\" class=\"headerlink\" title=\"空白样式定义\"></a>空白样式定义</h3><p>让我们从明显的开始。如果你有一个空白样式，丢掉它。不要借口稍后或许会用到，你也知道它们是杂乱的。除非你有一个合理的理由，否则不要添加它们。</p>\n<h3 id=\"缩写\"><a href=\"#缩写\" class=\"headerlink\" title=\"缩写\"></a>缩写</h3><p>CSS缩写是一种将多行CSS合并到单行的方法。 养成使用你知道的所有缩写技巧的习惯可以明显的减少你最终写出的代码的行数。这里是个例子： 长写版本:</p>\n<pre><code>#container&#123;\n    padding-top:5px\n    padding-right:10px\n    padding-bottom:30px\n    padding-left:18px\n&#125;\n</code></pre><p>缩写版本:</p>\n<pre><code>#container&#123;\n    padding:5px 10px 30px 18px;\n&#125;\n</code></pre><p>了解更多CSS缩写技巧，可以访问下面的文章： <a href=\"http://www.dustindiaz.com/css-shorthand/\"><img src=\"http://paranimage.com/img/css-compression/shorthand.jpg\" alt=\"screenshot\"></a> 推荐阅读阿捷的文章：《<a href=\"http://www.w3cn.org/article/tips/2005/103.html\">常用CSS缩写语法总结</a>》</p>\n<h3 id=\"CSS-Sprites\"><a href=\"#CSS-Sprites\" class=\"headerlink\" title=\"CSS Sprites\"></a>CSS Sprites</h3><p>CSS sprites背后的最初想法是减少HTTP请求的数量以加快页面的加载时间。Sprite实现这个目标的途径就是拼合多张图片到一个单独的图片文件中， 通常是一个网格格式的图片。每个单独的图片通过切换大的sprite图片的background-position来显示。对于CSS代码来说，使用 sprite技术可以大大的提高代码的重用度和可维护性，这会明显的减少CSS的代码量。</p>\n",
            "tags": [
                "css",
                "php",
                "web",
                "代码",
                "压缩"
            ]
        },
        {
            "id": "https://erik.xyz/2015/01/10/ji-yu-sphinx-gou-jian-zhun-shi-shi-geng-xin-de-fen-bu-shi-tong-yong-sou-suo-yin-qing-ping-tai/",
            "url": "https://erik.xyz/2015/01/10/ji-yu-sphinx-gou-jian-zhun-shi-shi-geng-xin-de-fen-bu-shi-tong-yong-sou-suo-yin-qing-ping-tai/",
            "title": "基于Sphinx构建准实时更新的分布式通用搜索引擎平台",
            "date_published": "2015-01-10T13:21:00.000Z",
            "content_html": "<p>作者：张宴 前言： 2008年7月，我写过一篇文章《<a href=\"http://blog.zyan.cc/post/360/\">基于Sphinx+MySQL的千万级数据全文检索（搜索引擎）架构设计</a>》。有不少网友希望阅读全文，我将该文档整理了一下，分享出来。文档解压后大小为7.33M，共19页。 <strong>本站下载地址：</strong> <a href=\"http://blog.zyan.cc/book/sphinx/sphinx_mysql.zip\">http://blog.zyan.cc/book/sphinx/sphinx_mysql.zip</a> <strong>新浪下载分流：</strong> <a href=\"http://ishare.iask.sina.com.cn/f/6728201.html\">http://ishare.iask.sina.com.cn/f/6728201.html</a> 上述文档架构存在的局限，我在2008年12月的文章《<a href=\"http://blog.zyan.cc/post/385/\">亿级数据的高并发通用搜索引擎架构设计</a>》 中已经指出：一是MySQL本身的并发能力有限，在200～300个并发连接下，查询和更新就比较慢了；二是由于MySQL表的主键与Sphinx索引的 ID一一对应，从而无法跨多表建立整站查询，而且新增加类别还得修改配置文件，比较麻烦；三是因为和MySQL集成，无法发挥出Sphinx的优势。虽然 如此，但对于一些写入量不大的搜索应用，已经足够了，或许对很多人会有帮助。<br><span id=\"more\"></span></p>\n<hr>\n<p>正文： 在这之后，本人基于《<a href=\"http://blog.zyan.cc/post/385/\">亿级数据的高并发通用搜索引擎架构设计</a>》开发的Sphinx分布式通用站内搜索引擎平台，已经在生产环境运行9个月以上，经过运营中的不断完善与改进，目前已形成了一套可扩展的分布式通用站内搜索引擎框架。CMS、视频、论坛等产品发生的增、删、改操作，文本内容实时写入自行开发的 <a href=\"http://blog.zyan.cc/httpsqs\">HTTPSQS</a> 高性能简单消息队列服务，通过队列控制器更新索引和存储。提供支持XML、JSON的API查询接口，支持亿级数据的索引、分布式、中文分词、高亮显示、自动摘要、准实时（1分钟内）增量索引更新。</p>\n<p><a href=\"http://zyan.cc/attachment/201002/search_system.png\"><img src=\"http://zyan.cc/attachment/201002/search_system.png\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\"></a> </p>\n<p>下面是Sphinx新的搜索架构中技术关键点实现方式的一些介绍，与大家分享、交流一下： <strong>1、一元分词和中文分词的结合：</strong> ①、一元分词位于索引更新模块。Sphinx索引引擎对于CJK（中日韩）语言（必须是UTF-8编码）支持一元切分，假设【反恐行动是国产主视角射击 网络游戏】这段文字，Sphinx会将其切成【反 恐 行 动 是 国 产 主 视 角 射 击 网 络 游 戏】，然后对每个字建立反向索引。如果用这句话中包含的字组成一个不存在的词语，例如【恐动】，也会被搜索到，所以搜索时，需要加引号，例如搜索【”反恐 行动”】，就能完全匹配连在一起的四个字，不连续的【”恐动”】就不会被搜索到。但是，这样还有一个问题，搜索【”反恐行动游戏”】或【”国产网络游 戏”】就会搜索不到。对于这个问题，采用位于搜索查询模块的中文分词来处理。 sphinx.conf配置文件中关于UTF-8中文一元分词的配置如下：</p>\n<p>…省略… </p>\n<pre><code>    index t_source_main &#123; \n      source                  = t_source_main\n      path                    = /data0/search/sphinx/data/t_source_main \n      docinfo                 = extern\n      mlock                     = 0 \n      morphology              = none \n      min_word_len            = 1 \n      charset_type            = utf-8 \n      min_prefix_len          = 0 \n      html_strip              = 1 \n      charset_table           = 0..9, A..Z-&gt;a..z, \\_, a..z, U+410..U+42F-&gt;U+430..U+44F, U+430..U+44F \n      ngram_len               = 1 \n      ngram_chars             = U+3000..U+2FA1F \n    &#125;\n</code></pre><p>…省略…</p>\n<p>②、中文分词位于搜索查询模块。搜索“反恐行动游戏”、“国产网络游戏”，先调用独立的中文分词系统，分别切分为“反恐行动 游戏”、“国产 网络游戏”，这时候，再给以空格分隔的词语加上引号，去Sphinx搜索【”反恐行动” “游戏”】或【”国产” “网络游戏”】，就能搜索到这条记录了。中文分词词库发生增、删、改，无需重建整个Sphinx搜索索引。</p>\n<hr>\n<p><strong>2、使用自行开发的HTTPSQS（<a href=\"http://code.google.com/p/httpsqs\">http://code.google.com/p/httpsqs</a>）开源简单队列服务程序，来缓冲高并发数据写入</strong> 新闻、论坛帖子、客服公告、SNS社区等发生的增、删、改操作，文本内容通过更新接口实时写入HTTPSQS队列，再通过队列控制器更新到Sphinx搜索引擎索引中。</p>\n<hr>\n<p><strong>3、Sphinx不能严格按照字段排序的小问题</strong> 如果不想使用权重，只希望严格按照时间、主键等排序，而匹配模式（Matching modes）又为非SPH_MATCH_BOOLEAN时（比较常用的是SPH_MATCH_ALL、 SPH_MATCH_EXTENDED），Sphinx搜索结果在某一页中的排序会不太准确。例如：按照UNIX时间戳倒序排序，0,20为第一 页，20,40为第二页，第一页的最小时间戳一定会大于第二页的最大时间戳，但是，第一页中的0,20条记录却不会严格按照时间戳排序，第二页亦是如此。 因此，如果需要精确排序，用户翻到搜索结果的某一页，就需要对Sphinx在某一搜索结果页中的记录另行再排序，在我的这套搜索架构中，这一再排序操作由 search.php查询接口使用array_multisort()函数处理。一般情况下，一页只会显示5～30条记录，因此，只对几十条记录采用 PHP再排序，速度也是非常快的。</p>\n<hr>\n<p><strong>4、队列控制器中“时间控制”与“数量控制”相结合，实现搜索索引的1分钟内准实时更新：</strong> ①、Sphinx 0.9.9生产环境的建索引速度大约在5.5 Mbytes/秒、6400文档/秒。队列控制器可以设置10秒钟更新一次增量索引，只要Sphinx增量索引数据源的文档数在38万以内，就能保证增量 索引在1～60秒内得到更新，这是从“时间”上进行控制。 ②、为了避免增量索引数据源的文档数增长到38万，队列控制器在增量索引数据源的文档数超过1万时，还将激活增量索引合并入主索引的操作，合并完成的文档将从增量索引数据源中删除，这是从“数量”上进行控制。</p>\n<hr>\n<p><strong>5、自行编写的“搜索引擎查询API接口”调用说明：</strong></p>\n<p><a href=\"http://xxx.xxx.xxx.xxx/search.php?query=%E9%87%91%E5%B1%B1%C2%A0%C2%A0\">http://xxx.xxx.xxx.xxx/search.php?query=%E9%87%91%E5%B1%B1  </a>（搜索关键字。程序能够识别关键字是GBK编码还是UTF-8编码，能够识别关键字是否进行了URL编码） &amp;output=xml  （输出类型支持：xml 或 json） &amp;excerpts=1  （是否开启高亮显示与文本摘要，1开启 或 0关闭） &amp;excerpts_before=<font color=red>  （高亮显示与文本摘要，如果为空值则不进行高亮显示与文本摘要。在匹配的关键字前面插入的字符串。） &amp;excerpts_after=</font>  （高亮显示与文本摘要，如果为空值则不进行高亮显示与文本摘要。在匹配的关键字之后插入的字符串。） &amp;excerpts_limit=256  （高亮显示与文本摘要，如果为空值则不进行高亮显示与文本摘要。摘要最多包含的符号（码点）数。） &amp;excerpts_field=c1,c2,c3,c4,c5  （仅对指定的字段进行高亮显示，其余字段不进行高亮显示，如果此参数为空，则默认所有的字符型字段都进行高亮显示） &amp;offset=0&amp;limit=20  （相当于SQL语句中的limit 0,20） &amp;max_matches=30000  （最大搜索结果集数量） &amp;match_mode=SPH_MATCH_EXTENDED2 &amp;ranking_mode=SPH_RANK_PROXIMITY_BM25 &amp;sort_mode=SPH_SORT_EXTENDED&amp;sort_by=@relevance DESC,u1 ASC,@id DESC  （排序模式：@relevance和@id是内置变量，@relevance代表相关度权值，@id等于search_id，u1为字段名） &amp;field_weights=c1,7;c2,1  （权重设置：字段c1的权重为7，字段c2的权重为1） &amp;filter=u1:0_1_6,false;u2:4,true  （整数值过滤器：匹配字段u1等于0、1或6，并且字段u2不等于4的结果集。false表示等于，true表示不等于） &amp;filter_range=u1:0,100,false;u2:50,90,true  （整数范围过滤器：字段u1 &gt;= 0并且u1 &lt;= 100，字段u2 &lt; 50并且u2 &gt; 90） &amp;filter_range=u1:1.23,99.645,false; u2:1034.3,7834.56,true  （浮点数范围过滤器：字段u1 &gt;= 1.23并且u1 &lt;= 99.645，字段u2 &lt; 1034.3并且u2 &gt; 7834.56）</p>\n<hr>\n<p><strong>6、搜索结果前台页面示例：</strong></p>\n<p><a href=\"http://zyan.cc/attachment/201002/search_example.png\"><img src=\"http://zyan.cc/attachment/201002/search_example.png\" alt=\"点击在新窗口中浏览此图片\" title=\"点击在新窗口中浏览此图片\"></a></p>\n<hr>\n<p><strong>7、同一套服务器平台与API接口，通用于各类产品：</strong> 示例： 金山游戏文章与视频搜索：<a href=\"http://s.xoyo.com/result.php?w=%E5%89%91%E7%BD%913\">http://s.xoyo.com/result.php?w=%E5%89%91%E7%BD%913</a> 金山游戏论坛帖子搜索：<a href=\"http://jx3.bbs.xoyo.com/search2.php?srchtxt=%E4%B8%83%E7%A7%80&amp;select=title\">http://jx3.bbs.xoyo.com/search2.php?srchtxt=%E4%B8%83%E7%A7%80&amp;select=title</a> 原文链接：<a href=\"http://blog.zyan.cc/sphinx_search/\">http://blog.zyan.cc/sphinx_search/</a></p>\n",
            "tags": [
                "web",
                "优化",
                "搜引擎ping服务器",
                "搜索引擎"
            ]
        },
        {
            "id": "https://erik.xyz/2014/12/28/9-ge-php-ku-jian-jie-he-xia-zai/",
            "url": "https://erik.xyz/2014/12/28/9-ge-php-ku-jian-jie-he-xia-zai/",
            "title": "9个PHP库简介和下载",
            "date_published": "2014-12-28T12:44:00.000Z",
            "content_html": "<p>作者: <a href=\"http://paranimage.com/author/admin/\" title=\"由帕兰发布\">帕兰</a> 9个非常有用的PHP类库，相信一定可以为你的WEB开发提供更好和更为快速的方法。</p>\n<h3 id=\"1-ReCAPTCHA\"><a href=\"#1-ReCAPTCHA\" class=\"headerlink\" title=\"1. ReCAPTCHA\"></a>1. ReCAPTCHA</h3><p><a href=\"http://recaptcha.net/plugins/php/\">The reCAPTCHA</a> 库让你可以为网站创建高级的 CAPTCHA 系统，这个系统其实是用来生成验证信息的，甚至包括语音验证。当然还有 reCAPTCHA 服务可以使用，其提供易用的免费 API，值得在你的网站试试。 <a href=\"http://code.google.com/p/recaptcha/downloads/list?q=label:phplib-Latest\">下载 ReCAPTCHA</a> | <a href=\"http://recaptcha.net/api/getkey?app=php\">获得 API Key</a> | <a href=\"http://recaptcha.net/plugins/php/\">文档</a><span id=\"more\"></span></p>\n<h3 id=\"2-Akismet\"><a href=\"#2-Akismet\" class=\"headerlink\" title=\"2. Akismet\"></a>2. Akismet</h3><p><a href=\"http://akismet.com/\">Akismet</a> 是个供小站点使用的免费服务，用来修改规范将加入数据库的评论（防止恶意评论）。这个库一直在改善。 <a href=\"http://net.tutsplus.com/tutorials/tools-and-tips/the-best-ways-to-fight-spam/\">详细参考 Akismet 介绍</a></p>\n<h3 id=\"3-Services-JSON\"><a href=\"#3-Services-JSON\" class=\"headerlink\" title=\"3. Services_JSON\"></a>3. Services_JSON</h3><p>JSON 是人类能容易理解的信息传递格式。不过如果你并未使用 5.2.0 以后版本的 PHP（从那以后 PHP 有了 JSON 官方支持），那么就应该试试这个库。 <a href=\"http://pear.php.net/package/Services_JSON\">查看 Services_JSON</a></p>\n<h3 id=\"4-Smarty\"><a href=\"#4-Smarty\" class=\"headerlink\" title=\"4. Smarty\"></a>4. Smarty</h3><p><a href=\"http://smarty.net/\">Smarty</a>就是鼎鼎大名的官方模版库了。它提供了不少有用的功能。其实使用 PHP 的人都该瞧瞧。 <a href=\"http://smarty.net/download.php\">下载 Smarty</a> | <a href=\"http://smarty.net/docs.php\">官方文档</a></p>\n<h3 id=\"5-pChart\"><a href=\"#5-pChart\" class=\"headerlink\" title=\"5. pChart\"></a>5. pChart</h3><p><a href=\"http://pchart.sourceforge.net/index.php\">pChart</a> 是极其有名的数据图形库。它能为数据展示提供各种美丽的图表。其实使用 PHP 的人都一定会碰到使用它的情况。 <a href=\"http://pchart.sourceforge.net/download.php\">下载 pChart</a> | <a href=\"http://pchart.sourceforge.net/documentation.php\">文档</a>| <a href=\"http://pchart.sourceforge.net/demo.php\">查看演示</a></p>\n<h3 id=\"6-SimplePie\"><a href=\"#6-SimplePie\" class=\"headerlink\" title=\"6. SimplePie\"></a>6. SimplePie</h3><p><a href=\"http://simplepie.org/\">SimplePie</a> 让你轻松提取内容（好比 RSS feeds）。它能和多种语言交互，也能处理各种格式的 feed。 <a href=\"http://simplepie.org/downloads/\">下载 SimplePie</a> | <a href=\"http://simplepie.org/wiki/\">查看文档</a>| <a href=\"http://net.tutsplus.com/videos/screencasts/extending-simplepie-to-parse-unique-rss-feeds/\">为独特的 RSS Feeds 拓展 SimplePie</a></p>\n<h3 id=\"7-XML-RPC-PHP-Library\"><a href=\"#7-XML-RPC-PHP-Library\" class=\"headerlink\" title=\"7. XML-RPC PHP Library\"></a>7. XML-RPC PHP Library</h3><p>有时你需要使用 XML-RPC 技术去和其他网站交互，那么试试这个 <a href=\"http://phpxmlrpc.sourceforge.net/\">XML-RPC PHP</a> 库吧。 <a href=\"http://phpxmlrpc.sourceforge.net/#download\">下载 XML-RPC PHP</a> | <a href=\"http://phpxmlrpc.sourceforge.net/#interest\">查看文档</a></p>\n<h3 id=\"8-Amazon-S3\"><a href=\"#8-Amazon-S3\" class=\"headerlink\" title=\"8. Amazon S3\"></a>8. Amazon S3</h3><p>Amazon 有名的云计算平台叫做 “S3″。这里就有<a href=\"http://undesigned.org.za/2007/10/22/amazon-s3-php-class\">Amazon S3 库</a> 让你不用任何附加工具就可以使用云，上传大量数据文件。 <a href=\"http://amazon-s3-php-class.googlecode.com/files/s3-php5-curl_0.3.9.tar.gz\">下载 Amazon S3 PHP Class</a></p>\n<h3 id=\"9-PHPMailer\"><a href=\"#9-PHPMailer\" class=\"headerlink\" title=\"9. PHPMailer\"></a>9. PHPMailer</h3><p>大多数 web 应用都在使用 PHP 的 mail() 函数。PHPMailer 让你更加灵活地处理 Email 的发出，不但支持任何格式，还可以加入附件并自定义 header。 <a href=\"http://phpmailer.codeworxtech.com/index.php?pg=sf&amp;p=dl\">下载 PHPMailer</a> | <a href=\"http://phpmailer.codeworxtech.com/index.php?pg=tutorial\">查看文档</a></p>\n",
            "tags": [
                "php",
                "web",
                "php库"
            ]
        },
        {
            "id": "https://erik.xyz/2014/12/20/nginx-1-5-2-php-5-5-1-mysql-5-6-10-zai-centos-xia-de-bian-yi-an-zhuang/",
            "url": "https://erik.xyz/2014/12/20/nginx-1-5-2-php-5-5-1-mysql-5-6-10-zai-centos-xia-de-bian-yi-an-zhuang/",
            "title": "Nginx 1.5.2 + PHP 5.5.1 + MySQL 5.6.10 在 CentOS 下的编译安装",
            "date_published": "2014-12-20T11:58:00.000Z",
            "content_html": "<p>by <a href=\"http://zyan.cc/user/2/\">张宴</a> ]</p>\n<p>　　最近配置了几台Web服务器，将安装笔记贴出来吧。没时间像以前那样，将文章写的那样系统了，请见谅。详细配置，可以看以前的旧文章：<a href=\"http://blog.zyan.cc/nginx_php_v6\">http://blog.zyan.cc/nginx_php_v6</a> 1、安装Nginx：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir -p /Data/tgz cd /Data/tgz yum install wget yum install pcre yum install openssl* yum -y install gcc gcc-c++ autoconf libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel glibc glibc-devel glib2 glib2-devel bzip2 bzip2-devel ncurses ncurses-devel curl curl-devel e2fsprogs e2fsprogs-devel krb5 krb5-devel libidn libidn-devel openssl openssl-devel openldap openldap-devel nss_ldap openldap-clients openldap-servers make yum -y install gd gd2 gd-devel gd2-devel /usr/sbin/groupadd www /usr/sbin/useradd -g www www ulimit -SHn 65535 wget [ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.32.tar.gz](ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.32.tar.gz) tar zxvf pcre-8.32.tar.gz cd pcre-8.32 ./configure --prefix=/Data/apps/pcre make &amp;&amp; make install cd ../wget [http://nginx.org/download/nginx-1.5.2.tar.gz](http://nginx.org/download/nginx-1.5.2.tar.gz) tar zxvf nginx-1.5.2.tar.gz cd nginx-1.5.2 ./configure --user=www --group=www --prefix=/Data/apps/nginx --with-http\\_stub\\_status\\_module --with-http\\_ssl\\_module --with-pcre=/Data/tgz/pcre-8.32 --with-http\\_realip\\_module --with-http\\_image\\_filter\\_module make make install cd ../</span><br></pre></td></tr></table></figure><br><span id=\"more\"></span><br>2、安装 MySQL：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget [http://downloads.mysql.com/archives/mysql-5.6/mysql-5.6.10-linux-glibc2.5-x86_64.tar.gz](http://downloads.mysql.com/archives/mysql-5.6/mysql-5.6.10-linux-glibc2.5-x86_64.tar.gz) tar zxvf mysql-5.6.10-linux-glibc2.5-x86\\_64.tar.gz mv mysql-5.6.10-linux-glibc2.5-x86\\_64 /Data/apps/mysql /usr/sbin/groupadd mysql /usr/sbin/useradd -g mysql mysql mkdir -p /Data/data/mysql/data yum install libaio /Data/apps/mysql/scripts/mysql\\_install\\_db --basedir=/Data/apps/mysql --datadir=/Data/data/mysql/data --user=mysqlsed -i &quot;s#/usr/local/mysql#/Data/apps/mysql#g&quot; /Data/apps/mysql/bin/mysqld_safe</span><br></pre></td></tr></table></figure><br>3、安装PHP依赖库<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir -p /Data/apps/libs/ wget [http://www.ijg.org/files/jpegsrc.v9.tar.gz    ](http://www.ijg.org/files/jpegsrc.v9.tar.gz%C2%A0%C2%A0%C2%A0%C2%A0) tar zxvf jpegsrc.v9.tar.gz cd jpeg-9/ ./configure --prefix=/Data/apps/libs --enable-shared --enable-static --prefix=/Data/apps/libs make make install cd ../wget [http://prdownloads.sourceforge.net/libpng/libpng-1.6.2.tar.gz](http://prdownloads.sourceforge.net/libpng/libpng-1.6.2.tar.gz) tar zxvf libpng-1.6.2.tar.gz cd libpng-1.6.2/ ./configure --prefix=/Data/apps/libs make make install cd ../wget [http://download.savannah.gnu.org/releases/freetype/freetype-2.4.12.tar.gz](http://download.savannah.gnu.org/releases/freetype/freetype-2.4.12.tar.gz) tar zxvf freetype-2.4.12.tar.gz cd freetype-2.4.12/ ./configure --prefix=/Data/apps/libs make make install cd ../ wget &quot;http://downloads.sourceforge.net/mhash/mhash-0.9.9.9.tar.gz?big\\_mirror=0&quot; wget &quot;http://downloads.sourceforge.net/mcrypt/libmcrypt-2.5.8.tar.gz?big\\_mirror=0&quot; wget &quot;http://downloads.sourceforge.net/mcrypt/mcrypt-2.6.8.tar.gz?big_mirror=0&quot; tar zxvf libmcrypt-2.5.8.tar.gz cd libmcrypt-2.5.8/ ./configure --prefix=/Data/apps/libs make make install cd libltdl/ ./configure --prefix=/Data/apps/libs --enable-ltdl-install make make install cd ../../ tar zxvf mhash-0.9.9.9.tar.gz cd mhash-0.9.9.9/ ./configure --prefix=/Data/apps/libs make make install cd ../</span><br><span class=\"line\"></span><br><span class=\"line\">vi /etc/ld.so.conf</span><br></pre></td></tr></table></figure><br>添加：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/Data/apps/libs/lib</span><br></pre></td></tr></table></figure><br>然后：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ldconfig</span><br><span class=\"line\"></span><br><span class=\"line\">tar zxvf mcrypt-2.6.8.tar.gz cd mcrypt-2.6.8/ export LDFLAGS=&quot;-L/Data/apps/libs/lib -L/usr/lib&quot; export CFLAGS=&quot;-I/Data/apps/libs/include -I/usr/include&quot; touch malloc.h ./configure --prefix=/Data/apps/libs --with-libmcrypt-prefix=/Data/apps/libs make make install cd ../</span><br></pre></td></tr></table></figure><br>4、编译安装PHP 5.5<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget [http://www.php.net/get/php-5.5.1.tar.gz/from/tw2.php.net/mirror](http://www.php.net/get/php-5.5.1.tar.gz/from/tw2.php.net/mirror) tar zxvf php-5.5.1.tar.gz cd php-5.5.1/ export LIBS=&quot;-lm -ltermcap -lresolv&quot; export DYLD\\_LIBRARY\\_PATH=&quot;/Data/apps/mysql/lib/:/lib/:/usr/lib/:/usr/local/lib:/lib64/:/usr/lib64/:/usr/local/lib64&quot; export LD\\_LIBRARY\\_PATH=&quot;/Data/apps/mysql/lib/:/lib/:/usr/lib/:/usr/local/lib:/lib64/:/usr/lib64/:/usr/local/lib64&quot; ./configure --prefix=/Data/apps/php --with-config-file-path=/Data/apps/php/etc --with-mysql=/Data/apps/mysql --with-mysqli=/Data/apps/mysql/bin/mysql_config --with-iconv-dir --with-freetype-dir=/Data/apps/libs --with-jpeg-dir=/Data/apps/libs --with-png-dir=/Data/apps/libs --with-zlib --with-libxml-dir=/usr --enable-xml --disable-rpath --enable-bcmath --enable-shmop --enable-sysvsem --enable-inline-optimization --with-curl --enable-mbregex --enable-fpm --enable-mbstring --with-mcrypt=/Data/apps/libs --with-gd --enable-gd-native-ttf --with-openssl --with-mhash --enable-pcntl --enable-sockets --with-xmlrpc --enable-zip --enable-soap --enable-opcache --with-pdo-mysql --enable-maintainer-zts make make install cp php.ini-development /Data/apps/php/etc/php.ini cd ../ln -s /Data/apps/mysql/lib/libmysqlclient.18.dylib /usr/lib/libmysqlclient.18.dylib mv /Data/apps/php/etc/php-fpm.conf.default /Data/apps/php/etc/php-fpm.conf</span><br></pre></td></tr></table></figure><br>5、编译安装PHP扩展<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget [http://ftp.gnu.org/gnu/autoconf/autoconf-latest.tar.gz](http://ftp.gnu.org/gnu/autoconf/autoconf-latest.tar.gz) tar zxvf autoconf-latest.tar.gz cd autoconf-2.69/ ./configure --prefix=/Data/apps/libs make make install cd ../wget [http://pecl.php.net/get/memcache-2.2.7.tgz](http://pecl.php.net/get/memcache-2.2.7.tgz) tar zxvf memcache-2.2.7.tgz cd memcache-2.2.7/ export PHP\\_AUTOCONF=&quot;/Data/apps/libs/bin/autoconf&quot; export PHP\\_AUTOHEADER=&quot;/Data/apps/libs/bin/autoheader&quot; /Data/apps/php/bin/phpize ./configure --with-php-config=/Data/apps/php/bin/php-config make make install cd ../</span><br></pre></td></tr></table></figure><br>打开 /Data/apps/php/etc/php.ini 查找 ; extension_dir = “ext” 在其后增加一行：</p>\n<p>extension = “memcache.so”</p>\n",
            "tags": [
                "php",
                "web",
                "php服务器"
            ]
        },
        {
            "id": "https://erik.xyz/2014/10/19/zhi-de-shou-cang-de-14-kuan-xiang-ying-shi-qian-duan-kai-fa-kuang-jia/",
            "url": "https://erik.xyz/2014/10/19/zhi-de-shou-cang-de-14-kuan-xiang-ying-shi-qian-duan-kai-fa-kuang-jia/",
            "title": "值得收藏的14款响应式前端开发框架",
            "date_published": "2014-10-19T14:46:00.000Z",
            "content_html": "<p><strong>摘要</strong>：使用前端开发框架可以大大简化开发过程，所开发网站具有跨浏览器、一致性、响应式等特点。本文收集了14款响应式前端开发框架，且分别指出所包含的UI组件及JavaScript插件。几乎所有的框架都采用了响应式网格系统。 前端开发并不是一个容易的工作，不仅需要掌握HTML、CSS和JavaScript，针对不同的浏览器版本和平台，还需要了解如何设计出跨平台的网站。如今随着响应式设计的流行，前端开发变得越来越困难，且花费的时间更长。 本文收集了14个响应式前端开发框架，可以帮助前端开发人员大大简化开发过程。针对每个框架，文中均指出了它所包含的UI组件及JavaScript插件。几乎所有的框架都采用了响应式网格系统。 <strong>使用这些前端框架，有如下好处</strong>： 跨浏览器。这一点已被证实。 一致性。UI组件，如导航、按钮、标签、表单、下拉框、表格……，在设计上保持风格一致。 快速开发。你可以快速、容易地构建布局。这些框架都配有详细的说明文档。 响应式。所有CSS组件及JavaScript插件可以很好地从桌面过渡到移动设备上。<span id=\"more\"></span> <strong>InK</strong> </p>\n<p><img src=\"http://devbbs-discuzx.stor.sinaapp.com/uc_server/forum/201410/18/004616vp3xhv2wvnskz8ms.jpg\" alt=\"1.jpg\" title=\"1.jpg\"> </p>\n<p>Ink为一个界面工具包，用于快速开发Web界面，具有易于使用、易于扩展特点。它可以为构建布局提供解决方案，可以展示普通的界面元素，可以实现以内容为中心、对用户友好的交互方式。 HTML&amp;CSS：布局、导航、排版、图标、表单、提示框、表格 JS：Gallery、表格、树视图、排序列表、日期选择插件、制表符、表单验证及一些行为（停靠、折叠、关闭） 其他：Sass Mixins <strong>GroundworkCSS Beta</strong> </p>\n<p><img src=\"http://devbbs-discuzx.stor.sinaapp.com/uc_server/forum/201410/18/004648t6t00u0rk3z2902k.jpg\" alt=\"2.jpg\" title=\"2.jpg\"></p>\n<p>GroundworkCSS是一个基于Sass预处理器的开源项目 ，主要用于快速构建响应式Web应用程序。拥有一个灵活的、可嵌套的网格系统，可以创建适应多种浏览设备的布局。GroundworkCSS还提供多种 UI 组件，如导航、按钮、图标、表单、Tabs、对话框、工具提示等等。 HTML&amp;CSS：网格、布局、排版、按键、标题、表单、图标、社交图标、响应式文本、对话框、工具提示 JS：导航、制表符（Tab）、提示框、Cycle2 其他：Sass Mixins <strong>Ivory</strong> </p>\n<p><img src=\"http://devbbs-discuzx.stor.sinaapp.com/uc_server/forum/201410/18/004705lbpcdps0pzjvdj3c.jpg\" alt=\"3.jpg\" title=\"3.jpg\"> </p>\n<p>这是一个灵活、强大的响应式Web框架，使Web开发更快速、更简单。 HTML&amp;CSS：网格、排版、表单、按钮、提示框、页码、面包屑导航（breadcrumb）、列表、表格 JS：提示框、制表符（Tab）、切换开关（Toggle switch）、折叠 <strong>ZURB</strong> </p>\n<p><img src=\"http://devbbs-discuzx.stor.sinaapp.com/uc_server/forum/201410/18/004731eg0061xwwm2rg67v.jpg\" alt=\"4.jpg\" title=\"4.jpg\"><br>Foundation由ZURB公司设计，ZURB是一家产品设计公司，位于加州坎贝尔。Foundation为最先进的响应式前端开发框架，它拥有很多布局模板、CSS样式表及自己开发的优秀JavaScript插件。 HTML&amp;CSS：网格、布局模板、图标字体、响应式表格、SVG格式的社交图标、页码、面包屑导航（breadcrumbs）、侧导航、按键、排版、标签、提示框、面板、价格表、进度栏、表格、缩略图 JS：下拉按钮、拆分按钮、转换开关、Flex视频、灯箱、下拉、响应式布局（通过转换图片大小来实现）、旅游导航、麦哲伦全局导航（Magellan Sticky Nav）、Orbit图片滑动幻灯片插件等 其他：可定制皮肤表单（Custom Skinned Forms）、SCSS Mixin <strong>Grumby</strong> </p>\n<p><img src=\"http://devbbs-discuzx.stor.sinaapp.com/uc_server/forum/201410/18/004805wz6a655pj2q8h8jc.jpg\" alt=\"5.jpg\" title=\"5.jpg\"> </p>\n<p>Gumby 2基于Sass开发。Sass为功能强大的CSS预处理器，利用它可以快速开发Gumby。 HTML&amp;CSS：网格、表单、按钮、导航、标签、Entypo图标 JS：下拉、浮窗、制表符（Tab）、开关与转换（Toggles &amp; Switches） 其他：可定制皮肤表单（Custom Skinned Forms）、SASS和Compass <strong>HTML KickStart</strong></p>\n<p><img src=\"http://devbbs-discuzx.stor.sinaapp.com/uc_server/forum/201410/18/004835cw13ccwaw1a1b3hg.jpg\" alt=\"6.jpg\" title=\"6.jpg\"> </p>\n<p>该框架集合了HTML5、CSS和JavaScript，帮助开发人员快速开发Web产品。它覆盖了所有UI组件，同时也包含一些有用的JavaScript插件。 HTML&amp;CSS：网格、排版按钮、列表、表格、图标、面包屑导航、图片、表单 JS：菜单、代码高亮插件、制表符（Tab）、幻灯片播放、表单验证 其他：CSS帮助文档 <strong>Maxmertkit</strong> </p>\n<p><img src=\"http://devbbs-discuzx.stor.sinaapp.com/uc_server/forum/201410/18/004901ornkznofslo0lftl.jpg\" alt=\"7.jpg\" title=\"7.jpg\"> </p>\n<p>Maxmertkit拥有完整的文档，包含大量实例，并且提供了拖拽生成代码的功能。 HTML&amp;CSS：网格、布局、徽章、按钮、表单、图标、标签、菜单、进度栏、表格、下拉、工具提示 JS：按钮、旋转木马、通知、弹出框、滚动条、制表符（Tab） 其他： Sass、Coffee脚本语言 <strong>Twitter Bootstrap</strong> </p>\n<p><img src=\"http://devbbs-discuzx.stor.sinaapp.com/uc_server/forum/201410/18/004934z4xjkxxkke6ejscz.jpg\" alt=\"8.jpg\" title=\"8.jpg\"> </p>\n<p>大家对Twitter Bootstrap已十分熟悉了。凭借全面的UI组件、易用的网格和组件，Bootstrap已成为众多设计者和开发者最喜欢的快速开发工具。现在已经有很多第三方Bootstrap程序和JavaScript插件可供使用。 HTML&amp;CSS：网格、布局、排版、编码、表格、表单、按键、图片、图标、按钮组、导航、面包屑导航、页码、标签、徽章、缩略图、提示框、进度栏 JS：模态窗口（Modals）、提示效果（Tool Tips）、“泡芙”效果（Popovers）、滚动监控（Scrollspy）、旋转木马（Carousel）、输入提示（Typeahead）等等。 其他：定制器（Customizer）、 LESS CSS <strong>Skeleton</strong> </p>\n<p><img src=\"http://devbbs-discuzx.stor.sinaapp.com/uc_server/forum/201410/18/004958fccafmfsfp1mfm1m.jpg\" alt=\"9.jpg\" title=\"9.jpg\"> </p>\n<p>Skeleton 是一个小的JS和CSS文件集合，可帮你快速开发漂亮的网站，适合各种屏幕设备，包括手机。Skeleton基于960 Grid开发，是一个UI框架。 HTML&amp;CSS：GRid、排版、按钮、表单、媒体查询（Media Queries） <strong>Kube</strong><br><img src=\"http://devbbs-discuzx.stor.sinaapp.com/uc_server/forum/201410/18/005037fdnd6d4p3x47o4xx.jpg\" alt=\"10.jpg\" title=\"10.jpg\"> </p>\n<p>Kube是一款最小化的，支持响应式的前端框架，包括一个简洁的CSS文件，用于方便地创建响应式布局，包括了两个JS文件来完成Tab以及页面的按钮操作。 HTML&amp;CSS：排版、网格、表单、表格、按钮、导航、图标 JS：按钮、制表符（Tab） 其他： LESS CSS <strong>Helium</strong> </p>\n<p><img src=\"http://devbbs-discuzx.stor.sinaapp.com/uc_server/forum/201410/18/005103zkttpiagkgey2a9b.jpg\" alt=\"11.jpg\" title=\"11.jpg\"> </p>\n<p>Helium是一个前端响应式Web框架，使用HTML5、CSS3快速制作原型以及开发产品。Helium很像Twitter Bootstrap和ZURB Foundation，事实上，Helium使用了两者不少的代码。但与这两个框架不同的是，Helium设计更加轻量级，而且更容易修改。Helium 只有30KB左右，而Bootstrap有100KB，ZURB有200多KB。 HTML&amp;CSS：网格、按钮、排版、表单 JS：下拉、表单验证 其他：Sass、Compass <strong>The Markup Framework</strong> </p>\n<p><img src=\"http://devbbs-discuzx.stor.sinaapp.com/uc_server/forum/201410/18/0051240w3e2nb789h239v3.jpg\" alt=\"12.jpg\" title=\"12.jpg\"> </p>\n<p>Markup是一套集布局、小组件、UI组件和字体排版样式为一体的框架。它可以作为你设计自己网站的起点。 HTML&amp;CSS：布局、网格、排版、表单、按钮、面包屑导航、导航列表、导航菜单 JS：没有JavaScripts，只有单纯的CSS <strong>Topcoat</strong> </p>\n<p><img src=\"http://devbbs-discuzx.stor.sinaapp.com/uc_server/forum/201410/18/0051541919wdfb3r23elr7.jpg\" alt=\"13.jpg\" title=\"13.jpg\"> </p>\n<p>TopCoat是一套免费的开源UI元素类库，整套类库不使用任何JavaScript，而是使用CSS和HTML来生成。 HTML&amp;CSS：图标、字体、按键、面包屑导航、表单、下拉、滑动开关、选择、滚动条、切换按钮 JS：没有JavaScripts，只有单纯的CSS <strong>PureCSS</strong> </p>\n<p><img src=\"http://devbbs-discuzx.stor.sinaapp.com/uc_server/forum/201410/18/00522433rcnrs8p5c888rh.jpg\" alt=\"14.jpg\" title=\"14.jpg\"> </p>\n<p>Pure是一个相当小的框架，压缩及最小化后仅有5.7KB。它没有使用任何JavaScript，只是HTML和CSS。该CSS框架为响应式布局，采用模块化结构，每个模块的样式可以单独使用。 HTML&amp;CSS：网格、排版、表单、按键、表格、菜单 JS：没有JavaScripts，只有单纯的CSS 其他：程序皮肤制作工具（Skin Builder）、YU 库。 <strong>结论</strong> 根据你的需要，选择可以与设计相匹配的框架。我们不应该根据框架来构建网站，因为它会很大程度上限制设计者的思维。 如果前端设计/布局不是那么重要，那么我们可以任意选择使用某一框架。   原文转载自：<a href=\"http://cloudbbs.org/forum.php?mod=viewthread&amp;tid=28314\">http://cloudbbs.org/forum.php?mod=viewthread&amp;tid=28314</a></p>\n",
            "tags": [
                "web",
                "web框架"
            ]
        }
    ]
}