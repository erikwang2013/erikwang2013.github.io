{
    "version": "https://jsonfeed.org/version/1",
    "title": "艾瑞可erik • All posts by \"web优化\" tag • All posts by \"undefined\" categories",
    "description": "一只PHP开发的程序猿，偶尔做做运维、Goland、Python、Java、摄影、画画、写作、顺便睡觉，反正整站都搞过。",
    "home_page_url": "https://erik.xyz",
    "items": [
        {
            "id": "https://erik.xyz/2024/06/12/loading-zero-copy/",
            "url": "https://erik.xyz/2024/06/12/loading-zero-copy/",
            "title": "使用懒加载 + 零拷贝后，程序的秒开率提升至99.99%",
            "date_published": "2024-06-12T02:00:56.000Z",
            "content_html": "<h4 id=\"一、5秒钟加载一个页面的真相\"><a href=\"#一、5秒钟加载一个页面的真相\" class=\"headerlink\" title=\"一、5秒钟加载一个页面的真相\"></a>一、5秒钟加载一个页面的真相</h4><p>今天在修改前端页面的时候，发现程序中有一个页面的加载速度很慢，差不多需要5秒，这其实是难以接受的，我也不知道为什么上线这么长时间了，没人提过这个事儿。</p>\n<p>我记得有一个词儿，叫秒开率。<br><span id=\"more\"></span><br>秒开率是指能够在1秒内完成页面的加载。<br><img src=\"/img/2024/20240501.webp\" alt=\"erik.xyz\"></p>\n<p>查询的时候，会访问后台数据库，查询前20条数据，按道理来说，这应该很快才对。追踪代码，看看啥问题，最后发现问题有三：</p>\n<p>1.表中有一个BLOB大字段，存储着一个PDF模板，也就是上图中的运费模板；</p>\n<p>2.查询后会将这个PDF模板存储到本地磁盘点</p>\n<p>3.击线上显示，会读取本地的PDF模板，通过socket传到服务器。</p>\n<h5 id=\"大字段批量查询、批量文件落地、读取大文件并进行网络传输，不慢才怪，这一顿骚操作，5秒能加载完毕，已经烧高香了。\"><a href=\"#大字段批量查询、批量文件落地、读取大文件并进行网络传输，不慢才怪，这一顿骚操作，5秒能加载完毕，已经烧高香了。\" class=\"headerlink\" title=\"大字段批量查询、批量文件落地、读取大文件并进行网络传输，不慢才怪，这一顿骚操作，5秒能加载完毕，已经烧高香了。\"></a>大字段批量查询、批量文件落地、读取大文件并进行网络传输，不慢才怪，这一顿骚操作，5秒能加载完毕，已经烧高香了。</h5><p><img src=\"/img/2024/20240502.webp\" alt=\"erik.xyz\"></p>\n<h4 id=\"二、优化四步走\"><a href=\"#二、优化四步走\" class=\"headerlink\" title=\"二、优化四步走\"></a>二、优化四步走</h4><h5 id=\"1、“懒加载”\"><a href=\"#1、“懒加载”\" class=\"headerlink\" title=\"1、“懒加载”\"></a>1、“懒加载”</h5><p>经过调查发现，这个PDF模板只有在点击运费模板按钮时才会使用。</p>\n<ul>\n<li>优化1： 在点查询按钮时，不查询PDF模板；</li>\n<li>优化2： 点击运费模板时，根据uuid去查询，这样既能触发索引，也不用按时间排序，只是查询单条，速度快了很多很多，我愿称你为“懒加载”。</li>\n<li>优化3： 通过异步，将文件保存到磁盘中。</li>\n</ul>\n<p><img src=\"/img/2024/20240503.webp\" alt=\"erik.xyz\"></p>\n<p><strong>2、线上显示 = 就读取一个文件，为什么会慢呢？</strong></p>\n<p>打开代码一看，居然是通过FileReader读取的，我了个乖乖~这有什么问题吗？</p>\n<p>都是从百度拷贝过来的，百度还会有错吗？而且也测试了，没问题啊。</p>\n<p>嗯，对，是没问题，是可以实现需求，可是，为什么用这个？不知道。更别说效率问题了~</p>\n<p>优化4：通过缓冲流读取文件</p>\n<p><img src=\"/img/2024/20240504.webp\" alt=\"erik.xyz\"></p>\n<h4 id=\"三、先从上帝视角，了解一下啥子是IO流\"><a href=\"#三、先从上帝视角，了解一下啥子是IO流\" class=\"headerlink\" title=\"三、先从上帝视角，了解一下啥子是IO流\"></a>三、先从上帝视角，了解一下啥子是IO流</h4><p>Java I/O (Input/Output) 是对传统 I/O 操作的封装，它是以流的形式来操作数据的。</p>\n<p>1.InputStream代表一个输入流，它是一个抽象类，不能被实例化。InputStream定义了一些通用方法，如read()和skip()等，用于从输入流中读取数据；</p>\n<p>2.OutputStream代表一个输出流，它也是一个抽象类，不能被实例化。OutputStream定义了一些通用方法，如write()和flush()等，用于向输出流中写入数据；</p>\n<p>3.除了字节流，Java还提供字符流，字符流类似于字节流，不同之处在于字符流是按字符读写数据，而不是按字节。Java中最基本的字符流是Reader和Writer，它们是基于InputStream和OutputStream的转换类，用于完成字节流与字符流之间的转换。</p>\n<p>4.BufferedInputStream和BufferedOutputStream是I/O包中提供的缓冲输入输出流。它们可以提高I/O操作的效率，具有较好的缓存机制，能够减少磁盘操作，缩短文件传输时间。使用BufferedInputStream和 BufferedOutputStream进行读取和写入时，Java会自动调整缓冲区的大小，使其能够适应不同的数据传输速度。</p>\n<p>5.可以读取或写入 Java对象的流，比较典型的对象流包括ObjectInputStream 和ObjectOutputStream，将Java对象转换为字节流进行传输或存储；<br><img src=\"/img/2024/20240505.webp\" alt=\"erik.xyz\"></p>\n<p>在上一篇<a href=\"2024/05/06/index-asynchrony-landing/\">《增加索引+异步+不落地后，从12h优化到15min》</a>中，提到了4种优化方式，数据库优化、复用优化、并行优化、算法优化。</p>\n<p><strong>其中Buffered缓冲流就属于复用优化的一种，这个页面的查询完全可以通过复用优化优化一下。</strong></p>\n<h4 id=\"四、写个栗子，测试一下\"><a href=\"#四、写个栗子，测试一下\" class=\"headerlink\" title=\"四、写个栗子，测试一下\"></a>四、写个栗子，测试一下</h4><p><strong>1、通过字符输入流FileReader读取</strong></p>\n<p>FileReader连readLine()方法都没有，我也是醉了~</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static int readFileByReader(String filePath) &#123;</span><br><span class=\"line\">    int result = 0;</span><br><span class=\"line\">    try (Reader reader = new FileReader(filePath)) &#123;</span><br><span class=\"line\">        int value;</span><br><span class=\"line\">        while ((value = reader.read()) != -1) &#123;</span><br><span class=\"line\">            result += value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; catch (Exception e) &#123;</span><br><span class=\"line\">        System.out.println(&quot;readFileByReader异常：&quot; + e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>2、通过缓冲流BufferedReader读取</strong><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static String readFileByBuffer(String filePath) &#123;</span><br><span class=\"line\">    StringBuilder builder = new StringBuilder();</span><br><span class=\"line\">    try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) &#123;</span><br><span class=\"line\">        String data = null;</span><br><span class=\"line\">        while ((data = reader.readLine())!= null)&#123;</span><br><span class=\"line\">            builder.append(data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;catch (Exception e) &#123;</span><br><span class=\"line\">        System.out.println(&quot;readFileByReader异常：&quot; + e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return builder+&quot;&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>通过循环模拟了150000个文件进行测试，FileReader耗时8136毫秒，BufferedReader耗时6718毫秒，差不多相差1秒半的时间，差距还是相当大的，俗话说得好，水滴石穿。</p>\n<p>同样是read方法，只不过是包了一层，有啥不同呢？</p>\n<p>BufferedReader 是一个缓冲字符输入流，可以对 FileRead 进行包装，提供了一个缓存数组，将数据按照一定规则读取到缓存区中，输入流每次读取文件数据时都需要将数据进行字符编码，而 BufferedReader 的出现，降低了输入流访问数据源的次数，将一定大小的数据一次读取到缓存区并进行字符编码，从而提高 IO 的效率。</p>\n<p>如果没有缓冲，每次调用 read() 或 readLine() 都可能导致从文件中读取字节，转换为字符，然后返回，这可能非常低效。</p>\n<p><strong>就像取快递一样，在取快递的时候，肯定是想一次性的取完，避免再来一趟。</strong></p>\n<ul>\n<li><p>FileReader就相当于一件一件的取，乐此不疲；</p>\n</li>\n<li><p>BufferedReader就相当于，你尽可能多的拿你的快递，可是这也有个极限，比如你一次只能拿5件快递，这个 5 就相当于缓冲区，效率上，提升数倍。</p>\n</li>\n</ul>\n<p>对 FileRead 进行包装变成了BufferedReader缓冲字符输入流，其实，Java IO流就是最典型的装饰器模式，装饰器模式通过组合替代继承的方式在不改变原始类的情况下添加增强功能，主要解决继承关系过于复杂的问题，之前整理过一篇装饰器模式，这里就不论述了。</p>\n<p><strong>3、再点进源码瞧瞧。</strong></p>\n<p><strong>（1）FileReader.read()源码很简单，就是直接读取</strong><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public int read(char cbuf[], int off, int len) throws IOException &#123;</span><br><span class=\"line\">   return in.read(cbuf, off, len);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>（2）BufferedReader.read()的源码就较为复杂了，看一下它的核心方法</strong><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fill()private void fill() throws IOException &#123;</span><br><span class=\"line\">   int dst;</span><br><span class=\"line\">    if (markedChar &lt;= UNMARKED) &#123;</span><br><span class=\"line\">        /* No mark */</span><br><span class=\"line\">        dst = 0;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        /* Marked */</span><br><span class=\"line\">        int delta = nextChar - markedChar;</span><br><span class=\"line\">        if (delta &gt;= readAheadLimit) &#123;</span><br><span class=\"line\">            /* Gone past read-ahead limit: Invalidate mark */</span><br><span class=\"line\">            markedChar = INVALIDATED;</span><br><span class=\"line\">            readAheadLimit = 0;</span><br><span class=\"line\">            dst = 0;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            if (readAheadLimit &lt;= cb.length) &#123;</span><br><span class=\"line\">                /* Shuffle in the current buffer */</span><br><span class=\"line\">                System.arraycopy(cb, markedChar, cb, 0, delta);</span><br><span class=\"line\">                markedChar = 0;</span><br><span class=\"line\">                dst = delta;</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                /* Reallocate buffer to accommodate read-ahead limit */</span><br><span class=\"line\">                char ncb[] = new char[readAheadLimit];</span><br><span class=\"line\">                System.arraycopy(cb, markedChar, ncb, 0, delta);</span><br><span class=\"line\">                cb = ncb;</span><br><span class=\"line\">                markedChar = 0;</span><br><span class=\"line\">                dst = delta;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            nextChar = nChars = delta;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    int n;</span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\">        n = in.read(cb, dst, cb.length - dst);</span><br><span class=\"line\">    &#125; while (n == 0);</span><br><span class=\"line\">    if (n &gt; 0) &#123;</span><br><span class=\"line\">        nChars = dst + n;</span><br><span class=\"line\">        nextChar = dst;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><strong>核心方法fill()：</strong></p>\n<p>1.字符缓冲输入流，底层有一个8192个元素的缓冲字符数组，当缓冲区的内容读完时，将使用 fill() 方法从硬盘中读取数据填充缓冲数组；</p>\n<p>2.字符缓冲输出流，底层有一个8192个元素的缓冲字符数组，使用flush方法将缓冲数组中的内容写入到硬盘当中；</p>\n<p>3.使用缓冲数组之后，程序在运行的大部分时间内都是内存和内存直接的数据交互过程。内存直接的操作效率是比较高的。并且降低了CPU通过内存操作硬盘的次数；</p>\n<p>4.关闭字符缓冲流，都会首先释放对应的缓冲数组空间，并且关闭创建对应的字符输入流和字符输出流。</p>\n<p>既然缓冲这么好用，为啥jdk将缓冲字符数组设置的这么小，才8192个字节？这是一个比较折中的方案，如果缓冲区太大的话，就会增加单次读写的时间，同样内存的大小也是有限制的，不可能都让你来干这个一件事。</p>\n<p>很多小伙伴也肯定用过它的read(char[] cbuf)，它内部维护了一个char数组，每次写/读数据时，操作的是数组，这样可以减少IO次数。<br><img src=\"/img/2024/20240506.webp\" alt=\"erik.xyz\"></p>\n<p><strong>（3）buffer四大属性</strong></p>\n<p>1.mark：标记</p>\n<p>2.position：位置，下一个要被读或写的元素的索引， 每次读写缓冲区数据时都会改变改值， 为下次读写作准备</p>\n<p>3.limit：表示缓冲区的当前终点，不能对缓冲区 超过极限的位置进行读写操作。且极限 是可以修改的</p>\n<p>4.capacity：容量，即可以容纳的最大数据量；在缓 冲区创建时被设定并且不能改变。</p>\n<p><strong>4、缓冲流：4次上下文切换+4次拷贝</strong></p>\n<p>传统IO执行的话需要4次上下文切换（用户态-&gt;内核态-&gt;用户态-&gt;内核态-&gt;用户态）和4次拷贝。</p>\n<p>1.磁盘文件DMA拷贝到内核缓冲区</p>\n<p>2.内核缓冲区CPU拷贝到用户缓冲区</p>\n<p>3.用户缓冲区CPU拷贝到Socket缓冲区</p>\n<p>4.Socket缓冲区DMA拷贝到协议引擎。<br><img src=\"/img/2024/20240508.webp\" alt=\"erik.xyz\"></p>\n<h4 id=\"五、NIO之FileChannel\"><a href=\"#五、NIO之FileChannel\" class=\"headerlink\" title=\"五、NIO之FileChannel\"></a>五、NIO之FileChannel</h4><p>NIO中比较常用的是FileChannel，主要用来对本地文件进行 IO 操作。</p>\n<p><strong>1、FileChannel 常见的方法有</strong></p>\n<p>1.read，从通道读取数据并放到缓冲区中；</p>\n<p>2.write，把缓冲区的数据写到通道中；</p>\n<p>3.transferFrom，从目标通道 中复制数据到当前通道；</p>\n<p>4,transferTo，把数据从当 前通道复制给目标通道。</p>\n<p><strong>2、关于Buffer 和 Channel的注意事项和细节</strong></p>\n<p>1.ByteBuffer支持类型化的put和get, put放入的是什么数据类型，get就应该使用 相应的数据类型来取出，否则可能有 BufferUnderflowException 异常；</p>\n<p>2.可以将一个普通Buffer 转成只读Buffer；</p>\n<p>3.NIO 还提供了 MappedByteBuffer， 可以让文件直接在内存（堆外的内存）中进 行修改， 而如何同步到文件由NIO 来完成；</p>\n<p>4.NIO 还支持 通过多个 Buffer (即 Buffer 数组) 完成读写操作，即 Scattering 和 Gathering。</p>\n<p><strong>3、Selector(选择器)</strong></p>\n<p>1.Java的NIO，用非阻塞的IO方式。可以用一个线程，处理多个的客户端连 接，就会使用到Selector(选择器)；</p>\n<p>2.Selector 能够检测多个注册的通道上是否有事件发生，如果有事件发生，便获取事件然 后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个 通道，也就是管理多个连接和请求。</p>\n<p>3.只有在 连接/通道 真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程。</p>\n<p>4,避免了多线程之间的上下文切换导致的开销。</p>\n<p><strong>4、selector的相关方法</strong></p>\n<p>1.open();//得到一个选择器对象</p>\n<p>2.select(long timeout);//监控所有注册的通道，当其中有IO操作可以进行时，将 对应的SelectionKey加入到内部集合中并返回，参数用来设置超时时间</p>\n<p>3.selectedKeys();//从内部集合中得到所有的SelectionKey。</p>\n<h4 id=\"六、内存映射技术mmap\"><a href=\"#六、内存映射技术mmap\" class=\"headerlink\" title=\"六、内存映射技术mmap\"></a>六、内存映射技术mmap</h4><p><strong>1、文件映射</strong></p>\n<p>传统的文件I/O操作可能会变得很慢，这时候mmap就闪亮登场了。</p>\n<p><strong>mmap（Memory-mapped files）是一种在内存中创建映射文件的机制，它可以使我们像访问内存一样访问文件，从而避免频繁的文件I/O操作。</strong></p>\n<p>使用mmap的方式是在内存中创建一个虚拟地址，然后将文件映射到这个虚拟地址上，这个映射的过程是由操作系统完成的。</p>\n<p>实现映射后，进程就可以采用指针的方式读写操作这一段内存，系统会自动回写到对应的文件磁盘上，这样就完成了对文件的读取操作，而不用调用 read、write 等系统函数。</p>\n<p>内核空间对这段区域的修改也会直接反映用户空间，从而可以实现不同进程间的文件共享。<br><img src=\"/img/2024/20240509.webp\" alt=\"erik.xyz\"></p>\n<p><strong>2、Java中使用mmap</strong></p>\n<p>在Java中，mmap技术主要使用了JavaNIO（New IO）库中的FileChannel 类，它提供了一种将文件映射到内存的方法，称为MappedByteBuffer。MappedByteBuffe是ByteBuffer的一个子类，它扩展了ByteBuffer的功能，可以直接将文件映射到内存中。</p>\n<p>根据文件地址创建了一层缓存当作索引，放在虚拟内存中，使用时会根据的地址，直接找到磁盘中文件的位置，把数据分段load到系统内存(pagecache)中。<br><img src=\"/img/2024/20240510.webp\" alt=\"erik.xyz\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static String readFileByMmap(String filePath) &#123;</span><br><span class=\"line\">    File file = new File(filePath);</span><br><span class=\"line\">    String ret = &quot;&quot;;</span><br><span class=\"line\">    StringBuilder builder = new StringBuilder();</span><br><span class=\"line\">    try (FileChannel channel = new RandomAccessFile(file, &quot;r&quot;).getChannel()) &#123;</span><br><span class=\"line\">        long size = channel.size();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 创建一个与文件大小相同的字节数组</span><br><span class=\"line\">        ByteBuffer buffer = ByteBuffer.allocate((int) size);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 将通道上的所有数据都读入到buffer中</span><br><span class=\"line\">        while (channel.read(buffer) != -1) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 切换为只读模式</span><br><span class=\"line\">        buffer.flip();</span><br><span class=\"line\"></span><br><span class=\"line\">        // 从buffer中获取数据并处理</span><br><span class=\"line\">        byte[] data = new byte[buffer.remaining()];</span><br><span class=\"line\">        buffer.get(data);</span><br><span class=\"line\"></span><br><span class=\"line\">        ret = new String(data);</span><br><span class=\"line\">    &#125; catch (IOException e) &#123;</span><br><span class=\"line\">        System.out.println(&quot;readFileByMmap异常：&quot; + e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>3、内存映射技术mmap：4次上下文切换+3次拷贝</strong></p>\n<p><strong>mmap是一种内存映射技术，mmap相比于传统的缓冲流来说，其实就是少了1次CPU 拷贝，变成了数据共享。</strong></p>\n<p>虽然减少了一次拷贝，但是上下文切换的次数还是没变。</p>\n<p>因为存在一次CPU拷贝，因此mmap并不是严格意义上的零拷贝。</p>\n<p>RocketMQ 中就是使用的 mmap 来提升磁盘文件的读写性能。<br><img src=\"/img/2024/20240511.webp\" alt=\"erik.xyz\"></p>\n<h4 id=\"七、sendFile零拷贝\"><a href=\"#七、sendFile零拷贝\" class=\"headerlink\" title=\"七、sendFile零拷贝\"></a>七、sendFile零拷贝</h4><p>零拷贝将上下文切换和拷贝的次数压缩到了极致。</p>\n<p><strong>1、传统IO流</strong></p>\n<p>1.将磁盘中的文件拷贝到内核空间内存；</p>\n<p>2.将内核空间的内容拷贝到用户空间内存；</p>\n<p>3.用户空间将内容写入到内核空间内存；</p>\n<p>4.socket读取内核空间内存，将内容发送给第三方服务器。<br><img src=\"/img/2024/20240512.webp\" alt=\"erik.xyz\"></p>\n<p><strong>2、sendFile零拷贝</strong></p>\n<p>在内核的支持下，零拷贝少了一个步骤，那就是内核缓存向用户空间的拷贝，这样既节省了内存，也节省了 CPU 的调度时间，让效率更高。<br><img src=\"/img/2024/20240513.webp\" alt=\"erik.xyz\"></p>\n<p><strong>3、sendFile零拷贝：2 次上下文切换 + 2次拷贝</strong></p>\n<p><strong>直接将用户缓冲区干掉，而且没有CPU拷贝，故得名零拷贝。</strong><br><img src=\"/img/2024/20240514.webp\" alt=\"erik.xyz\"></p>\n<p><strong>重置优化4：通过零拷贝读取文件</strong><br><img src=\"/img/2024/20240515.webp\" alt=\"erik.xyz\"></p>\n<h4 id=\"八、总结经过\"><a href=\"#八、总结经过\" class=\"headerlink\" title=\"八、总结经过\"></a>八、总结经过</h4><p><strong>4次优化，将页面的加载时间控制在了1秒以内，实打实的提升了程序的秒开率。</strong></p>\n<p>1.批量查询时，不查询BLOB大字段；</p>\n<p>2.点击运费查询时，单独查询+触发索引，实现“懒加载”；</p>\n<p>3.异步存储文件</p>\n<p>4.通过缓冲流-&gt;内存映射技术mmap-&gt; sendFile零拷贝读取本地文件；</p>\n<p><strong>通过一次页面优化，收获颇丰：</strong></p>\n<p>1.通过业务优化，将BLOB大字段进行“懒加载”；</p>\n<p>2.异步存储文件；</p>\n<p>3.系统的学习了Java IO流，输入输出流、字符流、字符流、转换流；</p>\n<p>4.通过NIO的FileChannel读取文件时，较于缓冲流性能上显著提升；</p>\n<p>5.内存映射技术mmap 相比于传统的 缓冲流 来说，其实就是少了1次内核缓冲区到用户缓冲区的CPU拷贝，将其变成了数据共享；</p>\n<p>6.sendFile零拷贝，舍弃了用户空间内存，舍弃了CUP拷贝，完美的零拷贝方案。</p>\n<p>7.通过代码实例，横向对比了FileReader、BufferedReader、NIO之FileChannel、内存映射技术mmap、sendFile零拷贝之间的性能差距；</p>\n<p>转载自：<a href=\"https://mp.weixin.qq.com/s/kaogMK5qz5vkfs9-BYu0Mg\">哪吒编程</a></p>\n",
            "tags": [
                "web",
                "web前端",
                "web优化"
            ]
        }
    ]
}