{
    "version": "https://jsonfeed.org/version/1",
    "title": "艾瑞可erik • All posts by \"redis分布式锁\" tag • All posts by \"undefined\" categories",
    "description": "一只PHP开发的程序猿，偶尔做做运维、Goland、Python、Java、摄影、画画、写作、顺便睡觉，反正整站都搞过。",
    "home_page_url": "https://erik.xyz",
    "items": [
        {
            "id": "https://erik.xyz/2021/11/15/reids-info-lock/",
            "url": "https://erik.xyz/2021/11/15/reids-info-lock/",
            "title": "细说Redis分布式锁",
            "date_published": "2021-11-15T13:43:00.000Z",
            "content_html": "<p>谈起Redis锁，下面三个，算是出现最多的高频词汇：</p>\n<ul>\n<li>Setnx</li>\n<li>Redlock</li>\n<li>Redisson</li>\n</ul>\n<p>Setnx</p>\n<p>其实目前通常所说的Setnx命令，并非单指Redis的setnx key value这条命令。</p>\n<span id=\"more\"></span>\n<p>一般代指Redis中对set命令加上nx参数进行使用，set这个命令，目前已经支持这么多参数可选：</p>\n<pre><code>SET key value [EX seconds|PX milliseconds] [NX|XX] [KEEPTTL]\n</code></pre><p>当然了，就不在文章中默写API了，基础参数还有不清晰的，可以蹦到官网：<a href=\"https://redis.io/commands/set\">https://redis.io/commands/set</a></p>\n<p><img src=\"/2021/11/20211115214422.jpg\" alt=\"\"></p>\n<p>上图是笔者画的Setnx大致原理，主要依托了它的key不存在才能set成功的特性，进程A拿到锁，在没有删除锁的Key时，进程B自然获取锁就失败了。</p>\n<p>那么为什么要使用PX 30000去设置一个超时时间？</p>\n<p>是怕进程A不讲道理啊，锁没等释放呢，万一崩了，直接原地把锁带走了，导致系统中谁也拿不到锁。</p>\n<p>就算这样，还是不能保证万无一失。</p>\n<p>如果进程A又不讲道理，操作锁内资源超过笔者设置的超时时间，那么就会导致其他进程拿到锁，等进程A回来了，回手就是把其他进程的锁删了，如图：</p>\n<p><img src=\"/2021/11/20211115214716.jpg\" alt=\"\"></p>\n<p>还是刚才那张图，将T5时刻改成了锁超时，被Redis释放。</p>\n<p>进程B在T6开开心心拿到锁不到一会，进程A操作完成，回手一个del，就把锁释放了。</p>\n<p>当进程B操作完成，去释放锁的时候（图中T8时刻）：</p>\n<p>找不到锁其实还算好的，万一T7时刻有个进程C过来加锁成功，那么进程B就把进程C的锁释放了。</p>\n<p>以此类推，进程C可能释放进程D的锁，进程D……（禁止套娃），具体什么后果就不得而知了。</p>\n<p>所以在用Setnx的时候，key虽然是主要作用，但是value也不能闲着，可以设置一个唯一的客户端ID，或者用UUID这种随机数。</p>\n<p>当解锁的时候，先获取value判断是否是当前进程加的锁，再去删除。伪代码：</p>\n<pre><code>String uuid = xxxx;\n// 伪代码，具体实现看项目中用的连接工具\n// 有的提供的方法名为set，有的叫setIfAbsent\nset Test uuid NX PX 3000\ntry&#123;\n// biz handle....\n&#125; finally &#123;\n    // unlock\n    if(uuid.equals(redisTool.get(&#39;Test&#39;))&#123;\n        redisTool.del(&#39;Test&#39;);\n    &#125;\n&#125;\n</code></pre><p>这回看起来是不是稳了。</p>\n<p>相反，这回的问题更明显了，在finally代码块中，get和del并非原子操作，还是有进程安全问题。</p>\n<p>为什么有问题还说这么多呢？</p>\n<p>第一，搞清劣势所在，才能更好的完善。</p>\n<p>第二点，其实上文中最后这段代码，还是有很多公司在用的。</p>\n<p>大小项目悖论：大公司实现规范，但是小司小项目虽然存在不严谨，可并发倒也不高，出问题的概率和大公司一样低。——鲁迅</p>\n<p>那么删除锁的正确姿势之一，就是可以使用Lua脚本，通过Redis的eval/evalsha命令来运行：</p>\n<pre><code>-- Lua删除锁：\n-- KEYS和ARGV分别是以集合方式传入的参数，对应上文的Test和uuid。\n-- 如果对应的value等于传入的uuid。\nif redis.call(&#39;get&#39;, KEYS[1]) == ARGV[1] \n    then \n -- 执行删除操作\n        return redis.call(&#39;del&#39;, KEYS[1]) \n    else \n -- 不成功，返回0\n        return 0 \nend\n</code></pre><p>通过Lua脚本能保证原子性的原因说的通俗一点：</p>\n<p>就算你在Lua里写出花，执行也是一个命令（eval/evalsha）去执行的，一条命令没执行完，其他客户端是看不到的。</p>\n<p>那么既然这么麻烦，有没有比较好的工具呢？就要说到Redisson了。</p>\n<p>介绍Redisson之前，笔者简单解释一下为什么现在的Setnx默认是指set命令带上nx参数，而不是直接说是Setnx这个命令。</p>\n<p>因为Redis版本在2.6.12之前，set是不支持nx参数的，如果想要完成一个锁，那么需要两条命令：</p>\n<pre><code>1. setnx Test uuid\n2. expire Test 30\n</code></pre><p>即放入Key和设置有效期，是分开的两步，理论上会出现1刚执行完，程序挂掉，无法保证原子性。</p>\n<p>但是早在2013年，也就是7年前，Redis就发布了2.6.12版本，并且官网（set命令页[1]），也早早就说明了“SETNX，SETEX，PSETEX可能在未来的版本中，会弃用并永久删除”。</p>\n<p>笔者曾阅读过一位大佬的文章，其中就有一句指导入门者的面试小套路，具体文字忘记了，大概意思如下：</p>\n<pre><code>说到Redis锁的时候，可以先从Setnx讲起，最后慢慢引出set命令的可以加参数，可以体现出自己的知识面。\n</code></pre><p>如果有缘你也阅读过这篇文章，并且学到了这个套路，作为本文的笔者我要加一句提醒：</p>\n<p>请注意你的工作年限！首先回答官网表明即将废弃的命令，再引出set命令七年前的“新特性”，如果是刚毕业不久的人这么说，面试官会以为自己穿越了。</p>\n<p>你套路面试官，面试官也会套路你。——vt・沃兹基硕德</p>\n<p>Redisson</p>\n<p>Redisson是Java的Redis客户端之一，提供了一些API方便操作Redis。</p>\n<p>但是Redisson这个客户端可有点厉害，笔者在官网截了仅仅是一部分的图：</p>\n<p><img src=\"/2021/11/20211115214952.jpg\" alt=\"\"></p>\n<p>这个特性列表可以说是太多了，是不是还看到了一些JUC包下面的类名，Redisson帮我们搞了分布式的版本，比如AtomicLong，直接用RedissonAtomicLong就行了，连类名都不用去新记，很人性化了。</p>\n<p>锁只是它的冰山一角，并且从它的wiki[2]页面看到，对主从，哨兵，集群等模式都支持，当然了，单节点模式肯定是支持的。</p>\n<p>本文还是以锁为主，其他的不过多介绍。</p>\n<p>Redisson普通的锁实现源码主要是RedissonLock这个类，还没有看过它源码的盆友，不妨去瞧一瞧。</p>\n<p>源码中加锁/释放锁操作都是用Lua脚本完成的，封装的非常完善，开箱即用。</p>\n<p>这里有个小细节，加锁使用Setnx就能实现，也采用Lua脚本是不是多此一举？笔者也非常严谨的思考了一下：这么厉害的东西哪能写废代码？</p>\n<p>其实笔者仔细看了一下，加锁解锁的Lua脚本考虑的非常全面，其中就包括锁的重入性，这点可以说是考虑非常周全，我也随手写了代码测试一下：</p>\n<p><img src=\"/2021/11/20211115215028.jpg\" alt=\"\"></p>\n<p>的确用起来像JDK的ReentrantLock一样丝滑，那么Redisson实现的已经这么完善，RedLock又是什么？</p>\n<p>RedLock</p>\n<p>RedLock的中文是直译过来的，就叫红锁。</p>\n<p>红锁并非是一个工具，而是Redis官方提出的一种分布式锁的算法。</p>\n<p>就在刚刚介绍完的Redisson中，就实现了redLock版本的锁。也就是说除了getLock方法，还有getRedLock方法。</p>\n<p>笔者大概画了一下对红锁的理解：</p>\n<p><img src=\"/2021/11/20211115215116.jpg\" alt=\"\"></p>\n<p>如果你不熟悉Redis高可用部署，那么没关系。RedLock算法虽然是需要多个实例，但是这些实例都是独自部署的，没有主从关系。</p>\n<p>RedLock作者指出，之所以要用独立的，是避免了redis异步复制造成的锁丢失，比如：主节点没来的及把刚刚set进来这条数据给从节点，就挂了。</p>\n<p>有些人是不是觉得大佬们都是杠精啊，天天就想着极端情况。其实高可用嘛，拼的就是99.999……%中小数点后面的位数。</p>\n<p>回到上面那张简陋的图片，红锁算法认为，只要(N/2) + 1个节点加锁成功，那么就认为获取了锁， 解锁时将所有实例解锁。流程为：</p>\n<p>  1.顺序向五个节点请求加锁</p>\n<p>  2.根据一定的超时时间来推断是不是跳过该节点</p>\n<p>  3.三个节点加锁成功并且花费时间小于锁的有效期</p>\n<p>  4.认定加锁成功</p>\n<p>也就是说，假设锁30秒过期，三个节点加锁花了31秒，自然是加锁失败了。</p>\n<p>这只是举个例子，实际上并不应该等每个节点那么长时间，就像官网所说的那样，假设有效期是10秒，那么单个Redis实例操作超时时间，应该在5到50毫秒（注意时间单位）。</p>\n<p>还是假设我们设置有效期是30秒，图中超时了两个Redis节点。那么加锁成功的节点总共花费了3秒，所以锁的实际有效期是小于27秒的。</p>\n<p>即扣除加锁成功三个实例的3秒，还要扣除等待超时Redis实例的总共时间。</p>\n<p>看到这，你有可能对这个算法有一些疑问，那么你不是一个人。</p>\n<p>回头看看Redis官网关于红锁的描述[3]。</p>\n<p>就在这篇描述页面的最下面，你能看到著名的关于红锁的神仙打架事件。</p>\n<p>即Martin Kleppmann和Antirez的RedLock辩论。一个是很有资历的分布式架构师，一个是Redis之父。</p>\n<p>官方挂人，最为致命。</p>\n<p>开个玩笑，要是质疑能被官方挂到官网，说明肯定是有价值的。</p>\n<p>所以说如果项目里要使用红锁，除了红锁的介绍，不妨要多看两篇文章，即：</p>\n<ul>\n<li><p>Martin Kleppmann的质疑贴：<a href=\"http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html\">http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html</a></p>\n</li>\n<li><p>Antirez的反击贴：<a href=\"http://antirez.com/news/101\">http://antirez.com/news/101</a></p>\n</li>\n</ul>\n<p>总结</p>\n<p>看了这么多，是不是发现如何实现，都不能保证100%的稳定。</p>\n<p>程序就是这样，没有绝对的稳定，所以做好人工补偿环节也是重要的一环，毕竟：技术不够，人工来凑～</p>\n<p>相关链接：</p>\n<p><a href=\"https://redis.io/commands/set\">https://redis.io/commands/set</a></p>\n<p><a href=\"https://github.com/redisson/redisson/wiki/Table-of-Content\">https://github.com/redisson/redisson/wiki/Table-of-Content</a></p>\n<p><a href=\"https://redis.io/topics/distlock\">https://redis.io/topics/distlock</a></p>\n<p>原文链接：<a href=\"https://juejin.cn/post/6844904082860146695\">https://juejin.cn/post/6844904082860146695</a></p>\n",
            "tags": [
                "redis",
                "redis锁",
                "redis分布式锁"
            ]
        }
    ]
}