{
    "version": "https://jsonfeed.org/version/1",
    "title": "艾瑞可erik • All posts by \"go加密\" tag • All posts by \"undefined\" categories",
    "description": "一只PHP开发的程序猿，偶尔做做运维、Goland、Python、Java、摄影、画画、写作、顺便睡觉，反正整站都搞过。",
    "home_page_url": "https://erik.xyz",
    "items": [
        {
            "id": "https://erik.xyz/2022/07/16/go-zhong-jia-jie-mi/",
            "url": "https://erik.xyz/2022/07/16/go-zhong-jia-jie-mi/",
            "title": "go中加解密",
            "date_published": "2022-07-16T02:35:00.000Z",
            "content_html": "<pre><code>func PKCS7Padding(ciphertext []byte, blockSize int) []byte &#123;\n    padding := blockSize - len(ciphertext)%blockSize\n    //Repeat()函数的功能是把切片[]byte&#123;byte(padding)&#125;复制padding个，然后合并成新的字节切片返回\n    padtext := bytes.Repeat([]byte&#123;byte(padding)&#125;, padding)\n    return append(ciphertext, padtext...)\n&#125;\n</code></pre><span id=\"more\"></span>\n<pre><code>  //填充的反向操作，删除填充字符串\n  func PKCS7UnPadding(origData []byte) ([]byte, error) &#123;\n      //获取数据长度\n      length := len(origData)\n      if length == 0 &#123;\n          return nil, errors.New(&quot;加密字符串错误！&quot;)\n      &#125; else &#123;\n          //获取填充字符串长度\n          unpadding := int(origData[length-1])\n          //截取切片，删除填充字节，并且返回明文\n          return origData[:(length - unpadding)], nil\n      &#125;\n  &#125;\n\n  //实现加密\n  func AesEcrypt(origData []byte, key []byte) ([]byte, error) &#123;\n      //创建加密算法实例\n      block, err := aes.NewCipher(key)\n      if err != nil &#123;\n          return nil, err\n      &#125;\n      //获取块的大小\n      blockSize := block.BlockSize()\n      //对数据进行填充，让数据长度满足需求\n      origData = PKCS7Padding(origData, blockSize)\n      //采用AES加密方法中CBC加密模式\n      blocMode := cipher.NewCBCEncrypter(block, key[:blockSize])\n      crypted := make([]byte, len(origData))\n      //执行加密\n      blocMode.CryptBlocks(crypted, origData)\n      return crypted, nil\n  &#125;\n\n  //实现解密\n  func AesDeCrypt(cypted []byte, key []byte) ([]byte, error) &#123;\n      //创建加密算法实例\n      block, err := aes.NewCipher(key)\n      if err != nil &#123;\n          return nil, err\n      &#125;\n      //获取块大小\n      blockSize := block.BlockSize()\n      //创建加密客户端实例\n      blockMode := cipher.NewCBCDecrypter(block, key[:blockSize])\n      origData := make([]byte, len(cypted))\n      //这个函数也可以用来解密\n      blockMode.CryptBlocks(origData, cypted)\n      //去除填充字符串\n      origData, err = PKCS7UnPadding(origData)\n      if err != nil &#123;\n          return nil, err\n      &#125;\n      return origData, err\n  &#125;\n\n  //加密base64\n  func EnPwdCode(pwd []byte) (string, error) &#123;\n      result, err := AesEcrypt(pwd, getKey())\n      if err != nil &#123;\n          return &quot;&quot;, err\n      &#125;\n      return base64.StdEncoding.EncodeToString(result), err\n  &#125;\n\n  //解密\n  func DePwdCode(pwd string) ([]byte, error) &#123;\n      //解密base64字符串\n      pwdByte, err := base64.StdEncoding.DecodeString(pwd)\n      if err != nil || len(pwdByte) &lt;= 0 &#123;\n          return nil, err\n      &#125;\n      //执行AES解密\n      return AesDeCrypt(pwdByte, getKey())\n  &#125;\n\n  //加密base64\n  func EnPwdUserCode(pwd []byte) (string, error) &#123;\n      result, err := AesEcrypt(pwd, getUserKey())\n      if err != nil &#123;\n          return &quot;&quot;, err\n      &#125;\n      return base64.StdEncoding.EncodeToString(result), err\n  &#125;\n\n  //解密\n  func DePwdUserCode(pwd string) ([]byte, error) &#123;\n      //解密base64字符串\n      pwdByte, err := base64.StdEncoding.DecodeString(pwd)\n      if err != nil || len(pwdByte) &lt;= 0 &#123;\n          return nil, err\n      &#125;\n      //执行AES解密\n      return AesDeCrypt(pwdByte, getUserKey())\n  &#125;\n</code></pre>",
            "tags": [
                "go加密",
                "go解密"
            ]
        }
    ]
}